<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lmxy1990 &#39; Blog</title>
  <subtitle>love code, enjoy life .</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="https://lmxy1990.github.io/"/>
  <updated>2017-01-24T01:35:48.593Z</updated>
  <id>https://lmxy1990.github.io/</id>
  
  <author>
    <name>lmxy1990</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql日期处理函数</title>
    <link href="https://lmxy1990.github.io/2017/01/23/mysql%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/"/>
    <id>https://lmxy1990.github.io/2017/01/23/mysql日期处理函数/</id>
    <published>2017-01-23T08:45:58.000Z</published>
    <updated>2017-01-24T01:35:48.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过滤指定日期"><a href="#过滤指定日期" class="headerlink" title="过滤指定日期"></a>过滤指定日期</h3><hr>
<p>1.近1天<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select * from table where to_days(column_time) = to_days(now());</div><div class="line"></div><div class="line">select * from table where date(column_time) = curdate();</div></pre></td></tr></table></figure></p>
<p>2.近7天<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from table where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(column_time);</div></pre></td></tr></table></figure></p>
<p>3.近一个月<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select * from table where DATE_SUB(CURDATE(), INTERVAL 1 MONTH) &lt;= date(column_time);</div></pre></td></tr></table></figure></p>
<h3 id="筛选出需要的日期的值"><a href="#筛选出需要的日期的值" class="headerlink" title="筛选出需要的日期的值"></a>筛选出需要的日期的值</h3><p>1.筛选出年月日<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select DATA(column_time) from table ;</div></pre></td></tr></table></figure></p>
<p>2.筛选出年月<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select Extract(year_month FROM column_time) from table ;</div></pre></td></tr></table></figure></p>
<p>3.筛选出年.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select Extract(year FROM column_time) from table ;</div></pre></td></tr></table></figure></p>
<p>4.筛选出月<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select Extract(month FROM column_time) from table ;</div></pre></td></tr></table></figure></p>
<p>5.筛选出日<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select Extract(day FROM column_time) from table ;</div></pre></td></tr></table></figure></p>
<p>6.筛选出时分秒<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select time(day FROM column_time) from table ;</div></pre></td></tr></table></figure></p>
<h3 id="比较日期"><a href="#比较日期" class="headerlink" title="比较日期"></a>比较日期</h3><p>1.间隔天数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SELECT match_date,create_time FROM table_name WHERE  datediff(match_date,create_time) = 60</div></pre></td></tr></table></figure></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_datediff" target="_blank" rel="external">详见:https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_datediff</a></p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;过滤指定日期&quot;&gt;&lt;a href=&quot;#过滤指定日期&quot; class=&quot;headerlink&quot; title=&quot;过滤指定日期&quot;&gt;&lt;/a&gt;过滤指定日期&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;1.近1天&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;
    
    </summary>
    
      <category term="sql" scheme="https://lmxy1990.github.io/categories/sql/"/>
    
    
  </entry>
  
  <entry>
    <title>xshell故障</title>
    <link href="https://lmxy1990.github.io/2017/01/23/xshell%E6%95%85%E9%9A%9C/"/>
    <id>https://lmxy1990.github.io/2017/01/23/xshell故障/</id>
    <published>2017-01-23T02:05:02.000Z</published>
    <updated>2017-01-23T02:09:01.654Z</updated>
    
    <content type="html"><![CDATA[<h3 id="故障1-登录成功-会话断开"><a href="#故障1-登录成功-会话断开" class="headerlink" title="故障1,登录成功.会话断开."></a>故障1,登录成功.会话断开.</h3><ul>
<li>这种原因google了很久,都没找到.后来才知道是因为窗口太大了.服务器那边可能不支持大屏显示吧.缩小窗口就可以了.</li>
</ul>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;故障1-登录成功-会话断开&quot;&gt;&lt;a href=&quot;#故障1-登录成功-会话断开&quot; class=&quot;headerlink&quot; title=&quot;故障1,登录成功.会话断开.&quot;&gt;&lt;/a&gt;故障1,登录成功.会话断开.&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;这种原因google了很久,都没找到
    
    </summary>
    
      <category term="工作日志" scheme="https://lmxy1990.github.io/categories/%E5%B7%A5%E4%BD%9C%E6%97%A5%E5%BF%97/"/>
    
    
  </entry>
  
  <entry>
    <title>java内存模型</title>
    <link href="https://lmxy1990.github.io/2017/01/22/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://lmxy1990.github.io/2017/01/22/java内存模型/</id>
    <published>2017-01-22T01:26:06.000Z</published>
    <updated>2017-01-22T02:11:03.590Z</updated>
    
    <content type="html"><![CDATA[<h3 id="运行时的内存模型"><a href="#运行时的内存模型" class="headerlink" title="运行时的内存模型"></a>运行时的内存模型</h3><hr>
<ul>
<li>java目前使用的虚拟机是HotSpot.运行时的内存模型可以简单分为:方法栈,堆,程序计数器,虚拟机栈,本地方法栈.其中堆与方法栈是所有线程共享的.虚拟机栈与本地方法栈,程序计数器是县城独享的.程序计数器,虚拟机栈的生命周期与线程的周期是一样的.</li>
</ul>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul>
<li>程序计数器可以见到那看作是当前线程的运行状态.进行指令分配的一小段内存块.它的功能是记录当前线程的一些状态,值.以便于线程的唤醒,启动.异常处理等线程功能都由它来完成.</li>
</ul>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><ul>
<li>虚拟机栈中保存的是局部变量,操作数栈,程序的出口信息.动态连接等.它的主要作用是存储线程执行的一些数据(线程内部数据).</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><ul>
<li>本地方法栈也是用来保存方法内的变量(局部变量),动态连接,出口数据等线程私有的数据.只是它对应的是本地方法(本地函数?),而虚拟机栈对应的是java的方法.</li>
</ul>
<h4 id="方法栈"><a href="#方法栈" class="headerlink" title="方法栈"></a>方法栈</h4><ul>
<li>方法栈是线程公有的.它主要保存所有类的信息,常量,静态变量.方法模型的基本信息.非静态成员变量也保存在此.所以成员变量需要考虑线程安全性的问题.</li>
</ul>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><ul>
<li>java堆是内存中最大的一部分,几乎所有的对象实例都保存于此.GC回收最主要部分也是这里.</li>
</ul>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;运行时的内存模型&quot;&gt;&lt;a href=&quot;#运行时的内存模型&quot; class=&quot;headerlink&quot; title=&quot;运行时的内存模型&quot;&gt;&lt;/a&gt;运行时的内存模型&lt;/h3&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;java目前使用的虚拟机是HotSpot.运行时的内存模型可以简单分为
    
    </summary>
    
      <category term="jvm" scheme="https://lmxy1990.github.io/categories/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>windows下删除文件过深命令</title>
    <link href="https://lmxy1990.github.io/2017/01/19/windows%E4%B8%8B%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E8%BF%87%E6%B7%B1%E5%91%BD%E4%BB%A4/"/>
    <id>https://lmxy1990.github.io/2017/01/19/windows下删除文件过深命令/</id>
    <published>2017-01-19T01:35:18.000Z</published>
    <updated>2017-01-19T01:40:24.004Z</updated>
    
    <content type="html"><![CDATA[<p>命令: robocopy windows的可靠文件复制.<br>原理: 新建一个文件夹,然后使用可靠复制命令.将新建的正常文件夹覆盖需要删除的文件夹.<br>示例: robocopy /MIR 正常文件夹 需要删除的文件夹.</p>
<p>查看命令所有参数:robocopy /?</p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;命令: robocopy windows的可靠文件复制.&lt;br&gt;原理: 新建一个文件夹,然后使用可靠复制命令.将新建的正常文件夹覆盖需要删除的文件夹.&lt;br&gt;示例: robocopy /MIR 正常文件夹 需要删除的文件夹.&lt;/p&gt;
&lt;p&gt;查看命令所有参数:robocopy
    
    </summary>
    
      <category term="小技巧" scheme="https://lmxy1990.github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>java多线程概念</title>
    <link href="https://lmxy1990.github.io/2017/01/16/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
    <id>https://lmxy1990.github.io/2017/01/16/java多线程概念/</id>
    <published>2017-01-16T03:14:32.000Z</published>
    <updated>2017-01-16T03:25:22.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>多线程是线程切换,多线程中的线程安全指的是在统一资源中.多线程在读取与修改的时候.资源是否同步.对于属于线程的资源,则无需考虑多线程安全问题.因为该资源是该县城独占.不存在线程安全问题.</li>
</ul>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul>
<li>并发与多线程是一个意思.并发描述侧重于业务.多线程描述侧重于编码机制.</li>
</ul>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;多线程是线程切换,多线程中的线程安全指的是在统一资源中.多线程在读取与修改的时候.资源是否同步.对于属于线程的资源,则无需考虑多
    
    </summary>
    
      <category term="笔记" scheme="https://lmxy1990.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>list,map,queue,dequeue区别</title>
    <link href="https://lmxy1990.github.io/2017/01/16/list-map-queue-dequeue%E5%8C%BA%E5%88%AB/"/>
    <id>https://lmxy1990.github.io/2017/01/16/list-map-queue-dequeue区别/</id>
    <published>2017-01-16T02:21:18.000Z</published>
    <updated>2017-01-16T03:09:43.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><ul>
<li>list是最常用的集合类.这里需要注意的是arraylist是非线程同步的.如果资源共享时候,需要考虑同步的话可以使用vector类.也可以使用同步队列.arraylist是一局数组的动态扩充来实现的.如果超过长度,则会一次性扩充当前长度的1.5倍.</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul>
<li>map也是集合中最为常用的集合类.hashMap,tableMap的区别是多线程时候,该资源是否同步.hashmap的底层实现是根据hashcode与next来进行判断.对于不同对象的相同hashcode,hashmap会在该节点产生一个链表.hashmap的put依托于重写equals方法.hashmap中的hashcode也是重新生成的.null可以作为key. hashcode的无符号右位移16位的次方(<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>).hashmap的的对象是Entry类型.所以equals时候,需比较hashcode与key对象的equals.来判断是否相等.然后执行是插入还哦是更新</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>队列比较特殊,它是集合类.但是它比一般的集合类功能要多一点.对于非阻塞无界队列来说,它功能上与list来说是一样的.队列有一个特性是阻塞,它表示的意义是只容许插入指定的数据,如果是插满,则在put方法时候会一直处于等待插入状态,add方法会抛出异常.offer方法则会插入失败,但不会抛出异常.功能上来说,队列优于list,set.</li>
</ul>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;list&quot;&gt;&lt;a href=&quot;#list&quot; class=&quot;headerlink&quot; title=&quot;list&quot;&gt;&lt;/a&gt;list&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;list是最常用的集合类.这里需要注意的是arraylist是非线程同步的.如果资源共享时候,需要考虑同步的话可
    
    </summary>
    
      <category term="笔记" scheme="https://lmxy1990.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>项目命令规范</title>
    <link href="https://lmxy1990.github.io/2017/01/16/%E9%A1%B9%E7%9B%AE%E5%91%BD%E4%BB%A4%E8%A7%84%E8%8C%83/"/>
    <id>https://lmxy1990.github.io/2017/01/16/项目命令规范/</id>
    <published>2017-01-16T01:44:10.000Z</published>
    <updated>2017-01-16T01:48:14.903Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Alpha："><a href="#Alpha：" class="headerlink" title="Alpha："></a>Alpha：</h4><ul>
<li>Alpha是内部测试版,一般不向外部发布,会有很多Bug.除非你也是测试人员,否则不建议使用.是希腊字母的第一位,表示最初级的版本，alpha 就是α，beta 就是β ，alpha 版就是比<br>beta还早的测试版，一般都是内部测试的版本。<h4 id="Beta"><a href="#Beta" class="headerlink" title="Beta:"></a>Beta:</h4></li>
<li>该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一缺陷，需要经过多次测试来进一步消除。这个阶段的版本会一直加入新的功能。        <h4 id="RC：-Release-Candidate"><a href="#RC：-Release-Candidate" class="headerlink" title="RC：(Release Candidate)"></a>RC：(Release Candidate)</h4></li>
<li>Candidate是候选人的意思，用在软件上就是候选版本。Release.Candidate.就是发行候选版本。和Beta版最大的差别在于Beta阶段会一直加入新的功能，但是到了RC版本，几乎<br>就不会加入新的功能了，而主要着重于除错!  RC版本是最终发放给用户的最接近正式版的版本，发行后改正bug就是正式版了，就是正式版之前的最后一个测试版。<h4 id="GA：（general-availability）"><a href="#GA：（general-availability）" class="headerlink" title="GA：（general availability）"></a>GA：（general availability）</h4></li>
<li>比如：Apache Struts 2 GA这是Apache Struts 2首次发行稳定的版本，GA意味着GeneralAvailability，也就是官方开始推荐广泛使用了。<h4 id="Release"><a href="#Release" class="headerlink" title="Release:"></a>Release:</h4></li>
<li>该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(R)。<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4></li>
<li>第一位表示主版本,一般是产品重大迭代.第二位表示小版本.一般表示小功能的增加.第三位表示修复版本.如果是4位数字的,那么最后一位代表bug修复/优化版本.</li>
</ul>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Alpha：&quot;&gt;&lt;a href=&quot;#Alpha：&quot; class=&quot;headerlink&quot; title=&quot;Alpha：&quot;&gt;&lt;/a&gt;Alpha：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Alpha是内部测试版,一般不向外部发布,会有很多Bug.除非你也是测试人员,否则不建议使用.是
    
    </summary>
    
      <category term="常识" scheme="https://lmxy1990.github.io/categories/%E5%B8%B8%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>java编程的一些建议</title>
    <link href="https://lmxy1990.github.io/2017/01/16/java%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/"/>
    <id>https://lmxy1990.github.io/2017/01/16/java编程的一些建议/</id>
    <published>2017-01-16T01:19:14.000Z</published>
    <updated>2017-01-16T01:43:38.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><ul>
<li>list方法的subList是返回视图上的子类.使用该方法之后,不能对其父类再进行一些操作.否则会有size的异常.subList还是不要使用的好,因为它没有产生新的对象.</li>
<li>排序的打乱是用自带的shuffle方法.</li>
<li>多线程对统一资源的操作时,使用vector或者hashtable.也可以使用同步队列.</li>
<li>集合对象可以采用谷歌的Guava包.</li>
</ul>
<hr>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a><center>未完待续</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;集合类&quot;&gt;&lt;a href=&quot;#集合类&quot; class=&quot;headerlink&quot; title=&quot;集合类&quot;&gt;&lt;/a&gt;集合类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;list方法的subList是返回视图上的子类.使用该方法之后,不能对其父类再进行一些操作.否则会有size的异常.su
    
    </summary>
    
      <category term="笔记" scheme="https://lmxy1990.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>altimu-designer常用快捷键</title>
    <link href="https://lmxy1990.github.io/2017/01/11/altimu-designer%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://lmxy1990.github.io/2017/01/11/altimu-designer常用快捷键/</id>
    <published>2017-01-11T04:34:35.000Z</published>
    <updated>2017-01-11T06:24:21.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理图快捷键列表"><a href="#原理图快捷键列表" class="headerlink" title="原理图快捷键列表"></a>原理图快捷键列表</h3><ol>
<li>p 放置器件</li>
<li>tab 在放置之前,设置器件的属性设置</li>
<li>space 器件90度旋转.</li>
<li>x 器件X轴镜像</li>
<li>y 器件Y轴镜像</li>
<li>鼠标左键 放置器件</li>
<li>鼠标右键 取消放置</li>
<li>按住右键, 拖拽图纸</li>
<li>ctrl+滚轮 放大/缩小</li>
<li>ctrl+按住鼠标右键,滑动鼠标 以器件为中心缩放</li>
</ol>
<h3 id="ltium-Designer14-PCB快捷键："><a href="#ltium-Designer14-PCB快捷键：" class="headerlink" title="ltium Designer14 PCB快捷键："></a>ltium Designer14 PCB快捷键：</h3><p><strong>旋转：Space；</strong><br>X轴镜像：X；<br>Y轴镜像：Y；<br>板层管理：L；<br>栅格设置：G；<br>单位进制切换：Q；</p>
<p>对齐-水平：A，D；<br>对齐-垂直：A，I，I，Enter；<br>对齐-顶部：A，T；<br>对齐-底部：A，B；<br>对齐-左侧：A，L；<br>对齐-右侧：A，R；</p>
<p>设计-类设置：D，C;<br>设计-板层管理：D，K；<br>设计-规则：D，R；<br>设计-规则向导：D，W；<br>设计-拷贝ROOM格式：D，M，C；<br>设计-放置ROOM：D，M，R；<br>设计-根据选择对象定义板子形状：D，S，D；<br>设计-编辑网络：D，N，N；</p>
<p>编辑-删除：E，D；<br>编辑-切断轨迹：E，K；<br>编辑-设定原点：E，O，S；<br>编辑-复位原点：E，O，R；</p>
<p>移动-移动：M，M；<br>移动-拖拽：M，D；<br>移动-器件：M，C；<br>移动-打断走线：M，B；<br>移动-器件翻转板层：M，I；</p>
<p>网络-显示网络：N，S，N；<br>网络-显示器件：N，S，O；<br>网络-显示全部：N，S，A；<br>网络-隐藏网络：N，H，N；<br>网络-隐藏器件：N，H，O；<br>网络-隐藏全部：N，H，A；</p>
<p>放置-坐标：P，O；<br>放置-焊盘：P，P；<br>放置-字符：P，S；<br>放置-过孔：P，V；<br>放置-多边形：P，R；<br>放置-填充：P，F；<br>放置-敷铜：P，G；<br>放置-线性尺寸：P，D，L；<br>放置-走线：P，T；<br>放置-差分对布线：P，I；<br>放置-多根布线：P，M，Enter；</p>
<p>选择-全选：S，A；<br>选择-线选：S，L；<br>选择-区域（内部）：S，I；<br>选择-区域（外部）：S，O；</p>
<p>工具-交叉探测对象：T，C；( Ctrl:跳转到目标文件)</p>
<p>工具-泪滴选项：T，E；<br>工具-设计规则检查：T，D；<br>工具-复位错误标志：T，M；<br>工具-从选择元素创建板剪切：T，V，B<br>工具-网络等长调节：T，R；</p>
<p>取消布线-全部：U，A；<br>取消布线-网络：U，N；<br>取消布线-连接：U，C；<br>取消布线-器件：U，O；<br>取消布线-ROOM：U，R；</p>
<p>查看-合适区域：V，A；<br>查看-翻转板子：V，B；<br>查看-适合文件：V，D；<br>查看-合适板子：V，F；<br>查看-合适图纸：V，H；</p>
<p>测距：Ctrl M；</p>
<p>清除蒙板： Shift Ｃ；<br>查找相似对象： Shift F;<br>显示走线长度： Shift G；<br>单层显示： Shift S；<br>改变走线模式：Shift Space；</p>
<p>切换二维显示：2(主键盘)；<br>切换三维显示：3(主键盘)；<br>顶层底层切换：*(小键盘 )；<br>板层切换： /-(小键盘)；<br>智能走线：在放置走线状态， Ctrl；</p>
<p>移动多边形顶点：右键，Y，V；<br>器件联合：右键，U；</p>
<p>增大弧度：长按 &gt;；<br>减小弧度：长按 &lt;；<br>减小多根交互式布线间距：长按Shift B；<br>增加多根交互式布线间距：长按Shift B；</p>
<p><strong>3D模式下：</strong><br>0°旋转：0（主键盘）；<br>90°旋转：9（主键盘）；</p>
<p><strong>布等长线状态下：</strong><br>增加蛇形线拐角弧度：1；<br>减少蛇形线拐角弧度：2；<br>增加蛇形线宽度：3；<br>减少蛇形线宽度：4；<br>增加蛇形线拐角振幅：。；<br>减少蛇形线拐角振幅：，；</p>
<p><strong>Altium Designer14 SCH快捷键：</strong></p>
<p>对齐-水平：A，D；<br>对齐-垂直：A，I；<br>对齐-顶部：A，T；<br>对齐-底部：A，B；<br>对齐-左侧：A，L；<br>对齐-右侧：A，R；</p>
<p>打破线：E，W；</p>
<p>放置总线：P，B；<br>放置总线入库：P，U；<br>放置节点：P，J；<br>放置网络标号：P，N；<br>放置端口：P，R；<br>放置字符串：P，T；<br>放置走线：P，W；<br>放置线：P，D，L；<br>放置差分对标示：P，V，F；<br>放置Blanket：P，V，L；<br>放置网络类：P，V，C；</p>
<p>从原理图选择PCB器件： T，S；<br>封装管理器：T，G；<br>强制标注所有器件：T，N；</p>
<p>查看-合适区域：V，A；<br>查看-适合文件：V，D；<br>查看-合适板子：V，F；</p>
<p>清除蒙板： Shift Ｃ；<br>改变走线模式：Shift Space</p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原理图快捷键列表&quot;&gt;&lt;a href=&quot;#原理图快捷键列表&quot; class=&quot;headerlink&quot; title=&quot;原理图快捷键列表&quot;&gt;&lt;/a&gt;原理图快捷键列表&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;p 放置器件&lt;/li&gt;
&lt;li&gt;tab 在放置之前,设置器件的属性设置&lt;/li&gt;
    
    </summary>
    
      <category term="微电子" scheme="https://lmxy1990.github.io/categories/%E5%BE%AE%E7%94%B5%E5%AD%90/"/>
    
    
  </entry>
  
  <entry>
    <title>java的lambda表达式</title>
    <link href="https://lmxy1990.github.io/2017/01/09/java%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://lmxy1990.github.io/2017/01/09/java的lambda表达式/</id>
    <published>2017-01-09T01:30:48.000Z</published>
    <updated>2017-01-09T01:38:36.484Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>lambda 表达式是1.8的特性.原预计是1.7的需求,但是因为竞争,收购,资金等等原因到1.8才出现.另外,java的lambda表达式与.net的有一定区别的.两者实现的方式不一样.java的lambda表达式是建立在匿名类(接口)之下延伸的.而.net是使用委托这一特性实现的.增加该特性的话,代码会简洁一些.</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>无论是java还是.net使用方式都差不多.就是() -&gt; “return data” .入参 -&gt; 回参.</p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;lambda 表达式是1.8的特性.原预计是1.7的需求,但是因为竞争,收购,资金等等原因到1.8才出现.另外,java的lambda表达式
    
    </summary>
    
      <category term="JAVA基本工具类" scheme="https://lmxy1990.github.io/categories/JAVA%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>java消息队列</title>
    <link href="https://lmxy1990.github.io/2017/01/07/java%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>https://lmxy1990.github.io/2017/01/07/java消息队列/</id>
    <published>2017-01-07T09:14:19.000Z</published>
    <updated>2017-01-07T10:00:58.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Queue队列的所有已知实现类"><a href="#Queue队列的所有已知实现类" class="headerlink" title="Queue队列的所有已知实现类:"></a>Queue队列的所有已知实现类:</h3><hr>
<ol>
<li>该接口继承Iterable,Collection接口.除了继承的接口的方法外,它有自身操作队列的一些公有的方法:offer/poll/peek.</li>
<li>队列里面的插入:offer,取出顶层元素:poll,查询顶层元素:peek/element.不建议使用集合类的方法,add,remove,addAll.因为操作失败是报异常,需要去捕获异常然后调用线程等待之类的方法.</li>
<li>另外,队列的传入值一般不建议插入null.<h3 id="子接口"><a href="#子接口" class="headerlink" title="子接口:"></a>子接口:</h3></li>
</ol>
<hr>
<ol>
<li>BlockingQueue<e></e></li>
</ol>
<ul>
<li>不容许插入null对象,如果取出顶层元素失败(执行poll),则返回null.<br>可能是有边界的,这种情况下,该队列如果制定边界.那么超过边界的对象不再被接受.如果没指名边界,那么边界就是整行的最大值.不支持close/shutdown这样的方法,线程安全.</li>
<li>是BlockingDeque,Transfer的父接口.一般该实现类都有边界.因为是阻塞的.<br>集合类方法:add/remove/addAll等,在操作失败抛出异常.<br>队列方法:offer/poll/peek,在操作失败返回null或者false.<br>队列方法put/take/操作失败一直重试.<br>队列方法:put(e,time,unit),重试最大时间,如果还是失败就退出.</li>
</ul>
<ol>
<li>Deque<e>,</e></li>
</ol>
<ul>
<li>双端队列接口,继承自Queue.子接口BlockingDeque.<br>该接口的实现类一般都是无边界的队列(大小自由).<br>首端元素的添加/取出/查询:offerFrist/pollFrist/peekFrist.尾端为Last.<br>也可以使用Queue接口的方法:poll,peek.操作首端元素.这里的offer方法操作的是尾端元素.从尾端添加.首端添加是Stack的push方法.或者offerFrist方法.<br>使用Stack方法:push,pop,peek操作首端元素.</li>
</ul>
<ol>
<li>BlockingDeque<e>,</e></li>
</ol>
<ul>
<li>继承自BlockingQueue与Deque接口.具有二者的共性.<br>双端阻塞队列,所以操作方法是addFrist/addLast,removeFrist/removeLast…这样的方法.操作失败特性与BrokingQueue一样.</li>
</ul>
<ol>
<li>TransferQueue<e>,</e></li>
</ol>
<ul>
<li>继承自BlockingQueue接口.使用场景:生产者–&gt;消费者.生产这产生对象,添加到转移队列,消费者从转移队列取出对象.一般该接口的实现类是有边界的.这种情况下,如果消费者一直没有去走元素,那么该生产这就不能在队列满的情况下继续添加.必须要等到队列空出位置.getWaitingConsumerCount()方法:查询消费者的数量.hasWaitConsumer() :是否有消费者正在等待消费.transfer(E e) :转移对象给消费者.如果没有消费者,则一直等待.tryTransfer(E e) :立即转移给消费者.没有返回false.tryTransfer(E e,long time,timeUnit unit) :尝试转移,等待最大时间之后就不再等待.其他方法与其父接口一致.<h3 id="子实现类"><a href="#子实现类" class="headerlink" title="子实现类:"></a>子实现类:</h3></li>
</ul>
<hr>
<ol>
<li>AbstractQueue,</li>
</ol>
<ul>
<li>抽象类,所有子队列的顶层.实现Queue的接口.所以Queue接口的方法都具有.<br>下面的类都是该类的子类.下面不再重复说明.</li>
</ul>
<ol>
<li>ArrayBlockingQueue,</li>
</ol>
<ul>
<li>基于数组实现的阻塞队列.拥有边界.实现BlockingQueue接口与序列化接口.</li>
</ul>
<ol>
<li>ArrayDeque,</li>
</ol>
<ul>
<li>基于数组的双端队列.无界,初始化未指定大小,默认为16容量.实现Deque接口,克隆接口,序列化接口.关于克隆接口:Cloneable</li>
</ul>
<ol>
<li>ConcurrentLinkedDeque,</li>
</ol>
<ul>
<li>基于链表实现的没有边界的同步双端队列.适用线程安全的多线程并发插入/移除/访问等操作.因为是双端操作,所以集合类的方法遍历可能结果不准确.不容许插入null值.</li>
</ul>
<ol>
<li>ConcurrentLinkedQueue,</li>
</ol>
<ul>
<li>基于链表实现的没边界的同步队列.与之前的一样,也是线程安全的.同样不容许插入null.这一条之后不再重复.一般队列都不容许插入null.</li>
</ul>
<ol>
<li>DelayQueue,</li>
</ol>
<ul>
<li>无界延迟队列.只有到达时间的对象才能被消费.实现BlockingQueue接口.传入参数必须是实现Delayed接口的对象方法多了个size/take..</li>
</ul>
<ol>
<li>LinkedBlockingDeque,</li>
</ol>
<ul>
<li>基于链表的双端队列.有界,如果初始化未指定容量大小,则默认为整型最大值.实现BlcokingDeque与序列化接口.方法定义与BlockingQueue一致性.</li>
</ul>
<ol>
<li>LinkedBlockingQueue,</li>
</ol>
<ul>
<li>基于链表的阻塞队列,如果初始化时候没有制定大小.默认为整型最大值.遵循FIFO,连接的节点在插入新的对象时候动态创建,知道超出容量限制.</li>
</ul>
<ol>
<li>LinkedList,</li>
</ol>
<ul>
<li>实现List<e>, Deque<e>, Cloneable, Serializable,接口.实现模式是双端队列,使用两条链表操作.该队列是非同步的.官方给出同步的处理方式:Collections.synchronizedList(new LinkedList(…)</e></e></li>
</ul>
<ol>
<li>LinkedTransferQueue,</li>
</ol>
<ul>
<li>基于链表实现的传输队列.无界实现TransferQueue与序列化接口.跟大部分非同步队列一样,由于多线程异步的原因,size方法取到的值不能作为准确的判断队列的数量.建议使用队列的方法取出.</li>
</ul>
<ol>
<li>PriorityQueue,</li>
</ol>
<ul>
<li>指定顺序的队列(优先级),无界.继承自AbstractQueue抽象类.传入对象需要实现排序接口 Comparator 来排序.初始化未指定参数,默认容量为11,排序方式为自然排序: natural ordering.</li>
</ul>
<ol>
<li>PriorityBlockingQueue,</li>
</ol>
<ul>
<li>优先阻塞队列,无界.实现阻塞接口与序列化接口.与阻塞队列相比,它多了一个排序的功能.</li>
</ul>
<ol>
<li>SynchronousQueue</li>
</ol>
<ul>
<li>同步队列,无界.实现BlockingQueue接口与序列化接口.可以指定是否FIFO,初始化默认是非公平队列.即不保证先插入的元素一定最先取出.了解队列特性,建议先了解接口特性.例外的就只有同步队列/排序队列(姑且这么翻译)不是实现接口而产生的功能,其他大体都<br>是接口定义的特性.</li>
</ul>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Queue队列的所有已知实现类&quot;&gt;&lt;a href=&quot;#Queue队列的所有已知实现类&quot; class=&quot;headerlink&quot; title=&quot;Queue队列的所有已知实现类:&quot;&gt;&lt;/a&gt;Queue队列的所有已知实现类:&lt;/h3&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;该接口继承
    
    </summary>
    
      <category term="Java基本工具类" scheme="https://lmxy1990.github.io/categories/Java%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>idea快捷键</title>
    <link href="https://lmxy1990.github.io/2017/01/07/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://lmxy1990.github.io/2017/01/07/idea快捷键/</id>
    <published>2017-01-07T08:28:00.000Z</published>
    <updated>2017-01-07T08:30:36.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最重要的两个快捷键"><a href="#最重要的两个快捷键" class="headerlink" title="最重要的两个快捷键"></a>最重要的两个快捷键</h2><hr>
<p>ctrl+shfit+a 查询所有命令快捷键<br>ctrl+j 查询所有语句快捷键(eg:sout等于输出语句)</p>
<h2 id="编辑快捷键"><a href="#编辑快捷键" class="headerlink" title="编辑快捷键"></a>编辑快捷键</h2><hr>
<p>Alt+Insert get/set/constructor/overrider..<br>Alt+Enter 编译器建议.<br>代码提示建议修改为Alt+/<br>Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）<br>Shift+F6，重构 - 重命名<br>Ctrl+O，覆写父类方法Overrider<br>Alt+Insert 自动生成Get/Set方法.<br>Ctrl+Alt+T 自动生成try/catch方法.<br>Ctrl+Shift+Up/Down，向上/下移动语句<br>Ctrl+D 复制当前行<br>Ctrl+Y 删除当前行<br>Ctrl+X，剪切行<br>Ctrl+V 粘贴<br>Ctrl+Alt+L 自动格式化代码块.<br>Ctrl+Alt+I 自动缩进排版<br>Ctrl+Alt+O 删除多余的导入类.<br>Ctrl+Enter 自动导入需要的Jar包.<br>Ctrl+”+/-“，当前方法展开、折叠<br>Ctrl+Shift+”+/-“，全部展开、折叠<br>Ctrl+Shift+U，大小写转化</p>
<h2 id="查找定位快捷键"><a href="#查找定位快捷键" class="headerlink" title="查找定位快捷键"></a>查找定位快捷键</h2><hr>
<p>Ctrl+W/Ctrl+Shift+W 智能选择对应代码块.<br>F2 或 Shift+F2，错误快速定位<br>Ctrl+U，转到父类<br>Ctrl+Alt+B 跳到实现类/实现方法<br>Ctrl+B 跳到定义<br>Ctrl+Q 查看注释<br>Ctrl+H，显示类结构图<br>Ctrl+F12 列出当前类的所有方法,变量.<br>Ctrl+F 查找文本<br>Ctrl+Shift+F，全局查找<br>Ctrl+R 替换文本<br>Ctrl+G，定位行<br>Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择<br>Alt+F7，查找整个工程中使用的某一个类、方法或者变量的位置<br>Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失<br>Ctrl+N 根据类名查找类<br>Ctrl+Shift+N 根据文件名查找文件(包括类)<br>Ctrl+Shift+Alt+N，查找所有类中的方法或变量<br>Ctrl+Shift+S，高级搜索<br>Alt+F3，逐个往下查找相同文本，并高亮显示<br>Alt+F8，计算变量值<br>Ctrl+Alt+left/right，返回至上次浏览的位置<br>Ctrl+Alt+F7，显示用法<br>Ctrl+Shift+A 查看所有快捷键<br>Ctrl+Tab 工作界面切换.</p>
<h2 id="Debug快捷键"><a href="#Debug快捷键" class="headerlink" title="Debug快捷键"></a>Debug快捷键</h2><hr>
<p>Alt+Shift+F9，选择 Debug<br>Alt+Shift+F10，选择 Run<br>F7，步入<br>F8，步过<br>Shift+F8 跳出方法<br>F9，恢复程序<br>Alt+F9 跳到鼠标指定的位置/断点/直接跳出<br>Alt+F10，查看当前断点<br>Ctrl+Shift+F8 查看全部断点<br>Shift+F7，智能步入<br>Shift+F8，智能步出<br>Alt+Shift+F7，强制步入<br>Alt+Shift+F8，强制步过</p>
<h2 id="CVS快捷键"><a href="#CVS快捷键" class="headerlink" title="CVS快捷键"></a>CVS快捷键</h2><hr>
<p>Alt+~，VCS 操作菜单<br>Ctrl+K，提交更改<br>Ctrl+T，更新项目<br>Ctrl+Alt+Shift+D，显示变化【常规】</p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;最重要的两个快捷键&quot;&gt;&lt;a href=&quot;#最重要的两个快捷键&quot; class=&quot;headerlink&quot; title=&quot;最重要的两个快捷键&quot;&gt;&lt;/a&gt;最重要的两个快捷键&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;ctrl+shfit+a 查询所有命令快捷键&lt;br&gt;ctrl+j 查询所有
    
    </summary>
    
      <category term="IDE" scheme="https://lmxy1990.github.io/categories/IDE/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之命令模式</title>
    <link href="https://lmxy1990.github.io/2017/01/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lmxy1990.github.io/2017/01/06/设计模式之命令模式/</id>
    <published>2017-01-06T02:39:36.000Z</published>
    <updated>2017-01-06T03:21:43.051Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><hr>
<ul>
<li>命令模式是对调用者与执行者的解耦.解耦之后,调用者需要添加新的功能或者执行者添加新的功能时,很容易实现.命令模式与代理模式有一定共性.但也有一定区别.都是对源对象的解耦.增加对需求变化的应变能力.</li>
<li>命令模式调用者–&gt;发出命令–&gt;命令接收对象–&gt;具体执行者执行.需要对命令的跟踪,以方便对其暂停/结束之类的操作.代理模式无需保存具体执行的一些信息.只是作为中间件来调用具体的对象.进行一些处理.</li>
</ul>
<h3 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h3><hr>
<ul>
<li>命令接口</li>
<li>命令接口的实现类</li>
<li>命令接收接口</li>
<li>命令接收的实现类</li>
<li>命令执行接口</li>
<li>命令执行实现类</li>
</ul>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/img/design_pattern/commond_pattern.png" alt="类图"></h2><h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;命令模式是对调用者与执行者的解耦.解耦之后,调用者需要添加新的功能或者执行者添加新的功能时,很容易实现.命令模式与代理
    
    </summary>
    
      <category term="设计模式" scheme="https://lmxy1990.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>使用反射将Object转换为HashMap</title>
    <link href="https://lmxy1990.github.io/2017/01/06/%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%B0%86Object%E8%BD%AC%E6%8D%A2%E4%B8%BAHashMap/"/>
    <id>https://lmxy1990.github.io/2017/01/06/使用反射将Object转换为HashMap/</id>
    <published>2017-01-06T01:49:44.000Z</published>
    <updated>2017-01-06T06:06:36.416Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class MapUtils &#123;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 使用反射获取对象的成员名作为key,值作为value</div><div class="line">     *</div><div class="line">     * @param o</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static Map&lt;String, String&gt; objectField2Map(Object o) &#123;</div><div class="line">        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();</div><div class="line">        if (o == null) return result;</div><div class="line">        Class oClass = o.getClass();</div><div class="line">        Field[] fields = oClass.getDeclaredFields() ;</div><div class="line">        String key;</div><div class="line">        String value;</div><div class="line">        if (fields != null &amp;&amp; fields.length != 0) &#123;</div><div class="line">            for (Field field : fields) &#123;</div><div class="line">                try &#123;</div><div class="line">                    key = field.getName();</div><div class="line">                    if (&quot;serialVersionUID&quot;.equalsIgnoreCase(key)) continue;</div><div class="line">                    field.setAccessible(true);</div><div class="line">                    Object o1 = field.get(o) ;</div><div class="line">                    value = o1.toString();</div><div class="line">                    result.put(key, value);</div><div class="line">                &#125; catch (IllegalAccessException e) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div c
    
    </summary>
    
      <category term="工具类" scheme="https://lmxy1990.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>apache httpclient工具类</title>
    <link href="https://lmxy1990.github.io/2017/01/06/apache-httpclient%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://lmxy1990.github.io/2017/01/06/apache-httpclient工具类/</id>
    <published>2017-01-06T01:46:54.000Z</published>
    <updated>2017-01-06T01:50:20.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="httpclient的简单封装"><a href="#httpclient的简单封装" class="headerlink" title="httpclient的简单封装"></a>httpclient的简单封装</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div></pre></td><td class="code"><pre><div class="line">public class IntelliHttpClientUtils &#123;</div><div class="line"></div><div class="line">    private static final Logger logger = LoggerFactory.getLogger(IntelliHttpClientUtils.class);</div><div class="line">    //HttpClient</div><div class="line">    private volatile static CloseableHttpClient httpClient;</div><div class="line">    //设置请求和传输超时时间 1000*6 秒</div><div class="line">    private static final RequestConfig requestConfig = RequestConfig.custom().setSocketTimeout(0b1011101110000).setConnectTimeout(0b1011101110000).build();</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * HTTP GET</div><div class="line">     *</div><div class="line">     * @param url</div><div class="line">     * @param encode</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static String httpGet(String url, String encode) &#123;</div><div class="line">        if (encode == null) encode = &quot;utf-8&quot;;</div><div class="line">        String resultStr = null;</div><div class="line">        CloseableHttpClient closeableHttpClient = getHttpClient();</div><div class="line">        HttpGet httpGet = new HttpGet(url);</div><div class="line">        httpGet.setConfig(requestConfig);</div><div class="line">        CloseableHttpResponse httpResponse = null;</div><div class="line">        try &#123;</div><div class="line">            httpResponse = closeableHttpClient.execute(httpGet);</div><div class="line">            if (httpResponse.getStatusLine().getStatusCode() &lt; HttpStatus.SC_BAD_REQUEST) &#123;</div><div class="line">                HttpEntity entity = httpResponse.getEntity();</div><div class="line">                resultStr = EntityUtils.toString(entity, encode);</div><div class="line">            &#125;</div><div class="line">            //请求失败 直接返回null</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            logger.info(&quot;Intelli.IntelliHttpClientUtils.httpGet 产生异常:&#123;&#125;&quot;, e.getMessage());</div><div class="line">        &#125; finally &#123;</div><div class="line">            HttpClientUtils.closeQuietly(httpResponse);</div><div class="line">        &#125;</div><div class="line">        return resultStr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * HTTP POST 请求</div><div class="line">     *</div><div class="line">     * @param url</div><div class="line">     * @param encode</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static String httpPost(String url, Map&lt;String, String&gt; params, String encode) &#123;</div><div class="line">        if (encode == null) &#123;</div><div class="line">            encode = &quot;utf-8&quot;;</div><div class="line">        &#125;</div><div class="line">        CloseableHttpClient closeableHttpClient = getHttpClient();</div><div class="line">        HttpPost httpPost = new HttpPost(url);</div><div class="line">        httpPost.setConfig(requestConfig);</div><div class="line">        //组织请求参数</div><div class="line">        List&lt;NameValuePair&gt; paramList = new ArrayList&lt;NameValuePair&gt;();</div><div class="line">        Set&lt;String&gt; keySet = params.keySet();</div><div class="line">        for (String key : keySet) &#123;</div><div class="line">            paramList.add(new BasicNameValuePair(key, params.get(key)));</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            httpPost.setEntity(new UrlEncodedFormEntity(paramList, encode));</div><div class="line">        &#125; catch (UnsupportedEncodingException e1) &#123;</div><div class="line">            logger.info(&quot;Intelli.IntelliHttpClientUtils.httpPost (Map请求添加参数时)产生异常:&#123;&#125;&quot;, e1.getMessage());</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">        String resultStr = getResponse2Str(encode, closeableHttpClient, httpPost);</div><div class="line"></div><div class="line">        return resultStr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Http Post 请求</div><div class="line">     *</div><div class="line">     * @param url</div><div class="line">     * @param jsonStr</div><div class="line">     * @param encode</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static String httpPost(String url, String jsonStr, String encode) &#123;</div><div class="line">        if (encode == null) &#123;</div><div class="line">            encode = &quot;utf-8&quot;;</div><div class="line">        &#125;</div><div class="line">        CloseableHttpClient closeableHttpClient = HttpClients.createDefault();</div><div class="line">        HttpPost httpPost = new HttpPost(url);</div><div class="line">        httpPost.setConfig(requestConfig);</div><div class="line">        httpPost.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;);</div><div class="line"></div><div class="line">        //组织请求参数</div><div class="line">        StringEntity stringEntity = new StringEntity(jsonStr, encode);</div><div class="line">        httpPost.setEntity(stringEntity);</div><div class="line">        String resultStr = getResponse2Str(encode, closeableHttpClient, httpPost);</div><div class="line"></div><div class="line">        return resultStr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取 CloseableHttpClient</div><div class="line">     *</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private static CloseableHttpClient getHttpClient() &#123;</div><div class="line">        if (httpClient == null) &#123;</div><div class="line">            synchronized (IntelliHttpClientUtils.class) &#123;</div><div class="line">                if (httpClient == null) &#123;</div><div class="line">                    HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();</div><div class="line">                    httpClientBuilder.setConnectionManager(new BasicHttpClientConnectionManager());</div><div class="line">                    httpClient = httpClientBuilder.build();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return httpClient;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 关闭httpClient</div><div class="line">     */</div><div class="line">    private void closeHttpClient() &#123;</div><div class="line">        if (IntelliHttpClientUtils.httpClient == null) return;</div><div class="line">        HttpClientUtils.closeQuietly(IntelliHttpClientUtils.httpClient);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /***</div><div class="line">     * 关闭httpClient</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    protected void finalize() throws Throwable &#123;</div><div class="line">        this.closeHttpClient();</div><div class="line">        super.finalize();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 执行 POST 请求</div><div class="line">     *</div><div class="line">     * @param encode</div><div class="line">     * @param closeableHttpClient</div><div class="line">     * @param httpPost</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private static String getResponse2Str(String encode, CloseableHttpClient closeableHttpClient, HttpPost httpPost) &#123;</div><div class="line">        CloseableHttpResponse httpResponse = null;</div><div class="line">        String resultStr = null;</div><div class="line">        try &#123;</div><div class="line">            httpResponse = closeableHttpClient.execute(httpPost);</div><div class="line">            if (httpResponse.getStatusLine().getStatusCode() &lt; HttpStatus.SC_BAD_REQUEST) &#123;</div><div class="line">                HttpEntity entity = httpResponse.getEntity();</div><div class="line">                resultStr = EntityUtils.toString(entity, encode);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            logger.info(&quot;Intelli.IntelliHttpClientUtils.getResponse2Str 产生异常:&#123;&#125;&quot;, e.getMessage());</div><div class="line">        &#125; finally &#123;</div><div class="line">            HttpClientUtils.closeQuietly(httpResponse);</div><div class="line">        &#125;</div><div class="line">        return resultStr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;httpclient的简单封装&quot;&gt;&lt;a href=&quot;#httpclient的简单封装&quot; class=&quot;headerlink&quot; title=&quot;httpclient的简单封装&quot;&gt;&lt;/a&gt;httpclient的简单封装&lt;/h3&gt;&lt;hr&gt;
&lt;figure class=&quot;h
    
    </summary>
    
      <category term="http" scheme="https://lmxy1990.github.io/categories/http/"/>
    
    
  </entry>
  
  <entry>
    <title>http协议状态码</title>
    <link href="https://lmxy1990.github.io/2017/01/05/http%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://lmxy1990.github.io/2017/01/05/http协议状态码/</id>
    <published>2017-01-05T13:34:19.000Z</published>
    <updated>2017-01-06T01:39:33.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码列表"><a href="#代码列表" class="headerlink" title="代码列表"></a>代码列表</h2><hr>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><hr>
<p>200 服务器成功返回网页 404 – 请求的网页不存在 503 – 服务不可用<br>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。<br>代码 说明<br>100   （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。<br>101   （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</p>
<h4 id="2xx-成功-表示成功处理了请求的状态代码。"><a href="#2xx-成功-表示成功处理了请求的状态代码。" class="headerlink" title="2xx  (成功)表示成功处理了请求的状态代码。"></a>2xx  (成功)表示成功处理了请求的状态代码。</h4><hr>
<p>200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201   （已创建）  请求成功并且服务器创建了新的资源。<br>202   （已接受）  服务器已接受请求，但尚未处理。<br>203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204   （无内容）  服务器成功处理了请求，但没有返回任何内容。<br>205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206   （部分内容）  服务器成功处理了部分 GET 请求。</p>
<h4 id="3xx-（重定向）-表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。"><a href="#3xx-（重定向）-表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。" class="headerlink" title="3xx （重定向） 表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。"></a>3xx （重定向） 表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。</h4><hr>
<p>300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p>
<h4 id="4xx（请求错误）-这些状态代码表示请求可能出错，妨碍了服务器的处理。"><a href="#4xx（请求错误）-这些状态代码表示请求可能出错，妨碍了服务器的处理。" class="headerlink" title="4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。"></a>4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。</h4><hr>
<p>400   （错误请求） 服务器不理解请求的语法。<br>401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403   （禁止） 服务器拒绝请求。<br>404   （未找到） 服务器找不到请求的网页。<br>405   （方法禁用） 禁用请求中指定的方法。<br>406   （不接受） 无法使用请求的内容特性响应请求的网页。<br>407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408   （请求超时）  服务器等候请求时发生超时。<br>409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。<br>411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415   （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417   （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p>
<h4 id="5xx（服务器错误）-这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。"><a href="#5xx（服务器错误）-这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。" class="headerlink" title="5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。"></a>5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</h4><hr>
<p>500   （服务器内部错误）  服务器遇到错误，无法完成请求。<br>501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>
<h4 id="新"><a href="#新" class="headerlink" title="新"></a>新</h4><hr>
<p>RFC 6585 最近刚刚发布，该文档描述了 4 个新的 HTTP 状态码。</p>
<p>HTTP 协议还在变化？是的，HTTP 协议一直在演变，新的状态码对于开发 REST 服务或者说是基于 HTTP 的服务非常有用，下面我们为你详细介绍这四个新的状态码以及是否应该使用。</p>
<p>428 Precondition Required (要求先决条件)</p>
<p>先决条件是客户端发送 HTTP 请求时，如果想要请求能成功必须满足一些预设的条件。</p>
<p>一个好的例子就是 If-None-Match 头，经常在 GET 请求中使用，如果指定了 If-None-Match ，那么客户端只在响应中的 ETag 改变后才会重新接收回应。</p>
<p>先决条件的另外一个例子就是 If-Match 头，这个一般用在 PUT 请求上用于指示只更新没被改变的资源，这在多个客户端使用 HTTP 服务时用来防止彼此间不会覆盖相同内容。</p>
<p>当服务器端使用 428 Precondition Required 状态码时，表示客户端必须发送上述的请求头才能执行请求，这个方法为服务器提供一种有效的方法来阻止 ‘lost update’ 问题。</p>
<p>429 Too Many Requests (太多请求)</p>
<p>当你需要限制客户端请求某个服务数量时，该状态码就很有用，也就是请求速度限制。</p>
<p>在此之前，有一些类似的状态码，例如 ‘509 Bandwidth Limit Exceeded’. Twitter 使用 420 （这不是HTTP定义的状态码）</p>
<p>如果你希望限制客户端对服务的请求数，可使用 429 状态码，同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务。</p>
<p>431 Request Header Fields Too Large (请求头字段太大)</p>
<p>某些情况下，客户端发送 HTTP 请求头会变得很大，那么服务器可发送 431 Request Header Fields Too Large 来指明该问题。</p>
<p>我不太清楚为什么没有 430 状态码，而是直接从 429 跳到 431，我尝试搜索但没有结果。唯一的猜测是 430 Forbidden 跟 403 Forbidden 太像了，为了避免混淆才这么做的，天知道！</p>
<p>511 Network Authentication Required (要求网络认证)</p>
<p>对我来说这个状态码很有趣，如果你在开发一个 HTTP 服务器，你不一定需要处理该状态码，但如果你在编写 HTTP 客户端，那这个状态码就非常重要。</p>
<p>如果你频繁使用笔记本和智能手机，你可能会注意到大量的公用 WIFI 服务要求你必须接受一些协议或者必须登录后才能使用。</p>
<p>这是通过拦截HTTP流量，当用户试图访问网络返回一个重定向和登录，这很讨厌，但是实际情况就是这样的。</p>
<p>使用这些“拦截”客户端，会有一些讨厌的副作用。在 RFC 中有提到这两个的例子：</p>
<p>如果你在登录WIFI前访问某个网站，网络设备将会拦截首个请求，这些设备往往也有自己的网站图标 ‘favicon.ico’。登录后您会发现，有一段时间内你访问的网站图标一直是WIFI登录网站的图标。<br>如果客户端使用HTTP请求来查找文档（可能是JSON），网络将会响应一个登录页，这样你的客户端就会解析错误并导致客户端运行异常，在现实中这种问题非常常见。<br>因此 511 状态码的提出就是为了解决这个问题。</p>
<h2 id="如果你正在编写-HTTP-的客户端，你最好还是检查-511-状态码以确认是否需要认证后才能访问。"><a href="#如果你正在编写-HTTP-的客户端，你最好还是检查-511-状态码以确认是否需要认证后才能访问。" class="headerlink" title="如果你正在编写 HTTP 的客户端，你最好还是检查 511 状态码以确认是否需要认证后才能访问。"></a>如果你正在编写 HTTP 的客户端，你最好还是检查 511 状态码以确认是否需要认证后才能访问。</h2><h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码列表&quot;&gt;&lt;a href=&quot;#代码列表&quot; class=&quot;headerlink&quot; title=&quot;代码列表&quot;&gt;&lt;/a&gt;代码列表&lt;/h2&gt;&lt;hr&gt;
&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="http" scheme="https://lmxy1990.github.io/categories/http/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之装饰者模式</title>
    <link href="https://lmxy1990.github.io/2017/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lmxy1990.github.io/2017/01/04/设计模式之装饰者模式/</id>
    <published>2017-01-04T01:30:19.000Z</published>
    <updated>2017-01-05T13:55:36.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="装饰者模式简述"><a href="#装饰者模式简述" class="headerlink" title="装饰者模式简述"></a>装饰者模式简述</h2><ul>
<li>装饰者模式可以形象的比喻一所大房子,外面只有一个门.打开门里面还有门.打开门获取一点金钱.你可以无限的进门..</li>
</ul>
<ul>
<li>Component（被装饰对象的基类）</li>
<li>ConcreteComponent（具体被装饰对象）</li>
<li>Decorator（装饰者抽象类）</li>
<li>ConcreteDecorator（具体装饰者）<br><br></li>
</ul>
<hr>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="/img/design_pattern/decorator.jpg" alt="装饰者"></p>
<hr>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol>
<li><p>定义一个抽象类(非必须)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.pan.component;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 抽象类</div><div class="line"> * </div><div class="line"> * @author xinyi.pan</div><div class="line"> *</div><div class="line"> */</div><div class="line">public abstract class Animal &#123;</div><div class="line"></div><div class="line">    private String name;</div><div class="line"></div><div class="line">    public Animal(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>定义一个被装饰的接口(定义公共的方法).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">package com.pan.component;</div><div class="line"></div><div class="line">public interface Fight &#123;</div><div class="line">    </div><div class="line">    //公共方法(门)</div><div class="line">    public String fightPower() ;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>单独类cat</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package com.pan.component;</div><div class="line"></div><div class="line">public class Cat extends Animal implements Fight &#123;</div><div class="line"></div><div class="line">    public Cat(String name) &#123;</div><div class="line">        super(name);</div><div class="line">    &#125;</div><div class="line">    //基类的门,里面不再有门..</div><div class="line">    public String fightPower() &#123;</div><div class="line">        return super.getName() +&quot; fighting&quot; ;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>单独类cattle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package com.pan.component;</div><div class="line"></div><div class="line">public class Cattle extends Animal implements Fight &#123;</div><div class="line"></div><div class="line">    public Cattle(String name) &#123;</div><div class="line">        super(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String fightPower() &#123;</div><div class="line">        return super.getName() + &quot; sleep&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>定义抽象装饰类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">package com.pan.decorator;</div><div class="line"></div><div class="line">import com.pan.component.Fight;</div><div class="line"></div><div class="line">public abstract class AnimalDecorator implements Fight &#123;</div><div class="line"></div><div class="line">    private Fight fight;</div><div class="line">    // 构造函数添加被装饰着对象</div><div class="line">    public AnimalDecorator(Fight fight) &#123;</div><div class="line">        this.fight = fight;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //拆包装饰者</div><div class="line">    public String fightPower() &#123;</div><div class="line">        //调用装饰者公共方法</div><div class="line">        doDecoratorFight();</div><div class="line">        //打开下一个门</div><div class="line">        return fight.fightPower();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //装饰者的公共方法.</div><div class="line">    public abstract void doDecoratorFight() ;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>cattle装饰类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.pan.decorator;</div><div class="line"></div><div class="line">import com.pan.component.Fight;</div><div class="line"></div><div class="line">public class CattleDecorator extends AnimalDecorator &#123;</div><div class="line"></div><div class="line">    public CattleDecorator(Fight fight) &#123;</div><div class="line">        super(fight);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String fightPower() &#123;</div><div class="line">        return super.fightPower();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void doDecoratorFight() &#123;</div><div class="line">        System.out.println(&quot;cattle 打豆豆&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>测试方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.pan.test;</div><div class="line"></div><div class="line">import com.pan.component.Cat;</div><div class="line">import com.pan.decorator.CatDecorator;</div><div class="line">import com.pan.decorator.CattleDecorator;</div><div class="line"></div><div class="line">public class CalTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        </div><div class="line">        System.out.println(&quot;==================未装饰cat==================&quot;);</div><div class="line">        System.out.println(new Cat(&quot;cat&quot;).fightPower());</div><div class="line">        System.out.println(&quot;===================装饰cat======================&quot;);</div><div class="line">        CatDecorator catDecorator = new CatDecorator(new Cat(&quot;cat&quot;)) ;</div><div class="line">        System.out.println(catDecorator.fightPower());</div><div class="line">        CattleDecorator cattleDecorator = new CattleDecorator(catDecorator) ;</div><div class="line">        System.out.println(&quot;====================cattle装饰cat装饰=====================&quot;);</div><div class="line">        System.out.println(cattleDecorator.fightPower());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">==================未装饰cat==================</div><div class="line">cat fighting</div><div class="line">===================装饰cat======================</div><div class="line">cat 打豆豆</div><div class="line">cat fighting</div><div class="line">====================cattle装饰cat装饰=====================</div><div class="line">cattle 打豆豆</div><div class="line">cat 打豆豆</div><div class="line">cat fighting</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;装饰者模式简述&quot;&gt;&lt;a href=&quot;#装饰者模式简述&quot; class=&quot;headerlink&quot; title=&quot;装饰者模式简述&quot;&gt;&lt;/a&gt;装饰者模式简述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;装饰者模式可以形象的比喻一所大房子,外面只有一个门.打开门里面还有门.打开门获取一点金钱
    
    </summary>
    
      <category term="设计模式" scheme="https://lmxy1990.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>去百度右侧推广方法</title>
    <link href="https://lmxy1990.github.io/2017/01/02/%E5%8E%BB%E7%99%BE%E5%BA%A6%E6%8E%A8%E5%B9%BF%E6%96%B9%E6%B3%95/"/>
    <id>https://lmxy1990.github.io/2017/01/02/去百度推广方法/</id>
    <published>2017-01-02T03:19:12.000Z</published>
    <updated>2017-01-02T04:32:36.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="百度越来越恶心了…"><a href="#百度越来越恶心了…" class="headerlink" title="百度越来越恶心了…"></a>百度越来越恶心了…</h2><hr>
<h3 id="下面介绍一种简单的去百度推广方法-采用的是chrome浏览器"><a href="#下面介绍一种简单的去百度推广方法-采用的是chrome浏览器" class="headerlink" title="下面介绍一种简单的去百度推广方法,采用的是chrome浏览器."></a>下面介绍一种简单的去百度推广方法,采用的是chrome浏览器.</h3><hr>
<ol>
<li>安装adb去广告插件.<br><img src="/img/suggest/adb_plus.jpg" alt="添加adb_plus插件"></li>
<li>添加自定义规则.<br><img src="/img/suggest/add_rude.jpg" alt="添加自定义规则"></li>
<li>右侧推广去掉的结果<br><img src="/img/suggest/remove_result.jpg" alt="结果1"></li>
<li>但是还有搜索的推广<br><img src="/img/suggest/bad_ad.jpg" alt="左侧推广"></li>
<li>添加清除左侧推广规则<br><img src="/img/suggest/remove_list.jpg" alt="清除左侧推广"></li>
<li>全部结果<br><img src="/img/suggest/all_result.jpg" alt="结果"><br>7.规则:<ul>
<li><code>##div[class*=&quot;cr-content&quot;]</code></li>
<li><code>##div[class*=&quot;opr-recommends-merge-panel&quot;]</code></li>
<li><code>##div[id*=&quot;con-ar&quot;]</code></li>
<li><code>##div[style*=&quot;!important&quot;]</code></li>
</ul>
</li>
</ol>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;百度越来越恶心了…&quot;&gt;&lt;a href=&quot;#百度越来越恶心了…&quot; class=&quot;headerlink&quot; title=&quot;百度越来越恶心了…&quot;&gt;&lt;/a&gt;百度越来越恶心了…&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;下面介绍一种简单的去百度推广方法-采用的是chrome浏览器&quot;&gt;
    
    </summary>
    
      <category term="小技巧" scheme="https://lmxy1990.github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之观察者模式</title>
    <link href="https://lmxy1990.github.io/2016/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lmxy1990.github.io/2016/12/30/设计模式之观察者模式/</id>
    <published>2016-12-30T04:30:42.000Z</published>
    <updated>2016-12-30T05:33:12.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><hr>
<ul>
<li>观察者模式一般使用在订阅/推送功能下,数据提供方推送数据–&gt;数据接收方.其实在开发中该模式使用应该是很普遍的.例如站内信/信息中心/订阅都是用的是该设计模式.<br><br><ul>
<li>方式1:数据推送方—&gt;查询订购对象—&gt;推送给订购对象.</li>
<li>方式2:订购的对象 —&gt;查询订阅的数据—&gt;拉取需要的数据.<br><br></li>
</ul>
</li>
<li>本质上其实就是发送方与接收方的依赖隔离,也就是说数据发送方发送数据,<br>不是直接发送给订购的对象,而是先查询哪些订购了.然后统一发送出<br><br></li>
</ul>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;观察者模式一般使用在订阅/推送功能下,数据提供方推送数据–&amp;gt;数据接收方.其实在开发中该模
    
    </summary>
    
      <category term="设计模式" scheme="https://lmxy1990.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>java volatile 关键字</title>
    <link href="https://lmxy1990.github.io/2016/12/29/java-volatile-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://lmxy1990.github.io/2016/12/29/java-volatile-关键字/</id>
    <published>2016-12-29T12:56:42.000Z</published>
    <updated>2016-12-29T13:18:21.121Z</updated>
    
    <content type="html"><![CDATA[<p><br></p>
<h2 id="volatile关键字的使用"><a href="#volatile关键字的使用" class="headerlink" title="volatile关键字的使用"></a>volatile关键字的使用</h2><hr>
<ul>
<li>volatile关键字的作用是告诉编译器,该变量是易变的.不要将该变量的值存储在寄存器中,而是放在内存中(一般指的是静态也就是栈).</li>
<li>某些静态变量,如果使用频繁.可能会直接存放于寄存器中,以便加快计算的速度.但是,如果我们期望该值不应   该存在多个不一样的值时候,除了使用final定义为常量.还可以使用该关键字.</li>
<li>该关键字既可以避免一个变量出现多个值的可能,也可以避免常量的不可改变性.</li>
</ul>
<hr>
<p><br></p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点:"></a>注意点:</h3><ul>
<li>使用场景应该如下:<ul>
<li>多个线程中,该变量只能拥有一个对象.</li>
<li>该变量可能需要变化.即该变量需要动态创建/销毁.</li>
<li>它本身无法保证运行中只存在一个对象.它只是告诉jvm,<br>它的值需要从内存中去读取,而不是在寄存器(1级缓存/2级缓存/3级缓存)中获取该值.</li>
</ul>
</li>
<li>如果只是需要一个对象,使用final关键字即可.如果该对象使用不频繁,减少内存开销.可以使用该关键字,配合多线程的同步锁,可以实现单例.</li>
</ul>
<hr>
<center>End</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;volatile关键字的使用&quot;&gt;&lt;a href=&quot;#volatile关键字的使用&quot; class=&quot;headerlink&quot; title=&quot;volatile关键字的使用&quot;&gt;&lt;/a&gt;volatile关键字的使用&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li
    
    </summary>
    
      <category term="java" scheme="https://lmxy1990.github.io/categories/java/"/>
    
    
  </entry>
  
</feed>
