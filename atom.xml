<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lmxy1990 &#39; Blog</title>
  <subtitle>love code, enjoy life .</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="https://lmxy1990.github.io/"/>
  <updated>2018-05-03T11:26:04.346Z</updated>
  <id>https://lmxy1990.github.io/</id>
  
  <author>
    <name>lmxy1990</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文档根元素_beans_必须匹配_DOCTYPE_根_null</title>
    <link href="https://lmxy1990.github.io/2018/05/03/%E6%96%87%E6%A1%A3%E6%A0%B9%E5%85%83%E7%B4%A0_beans_%E5%BF%85%E9%A1%BB%E5%8C%B9%E9%85%8D_DOCTYPE_%E6%A0%B9_null/"/>
    <id>https://lmxy1990.github.io/2018/05/03/文档根元素_beans_必须匹配_DOCTYPE_根_null/</id>
    <published>2018-05-03T11:16:06.000Z</published>
    <updated>2018-05-03T11:26:04.346Z</updated>
    
    <content type="html"><![CDATA[<h3 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h3><p>网上说的是因为:文件名是不能取名为application.xml.(错误)<br>真实原因是spring解析xml的时候死循环了.</p>
<p>a.xml  -&gt; b.xml … -&gt; a.xml<br>也就是说a.xml 引入了自己.这样,一直加载下一级,当下一级是父级就会抛出该异常.<br>至于为什么有的人说文件名的问题,应该是安卓默认application.xml -&gt; 用户的application.xml -&gt; 安卓默认的application.xml</p>
<p>总之,不要自己引入自己就不会出现这个异常了.</p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;错误原因&quot;&gt;&lt;a href=&quot;#错误原因&quot; class=&quot;headerlink&quot; title=&quot;错误原因&quot;&gt;&lt;/a&gt;错误原因&lt;/h3&gt;&lt;p&gt;网上说的是因为:文件名是不能取名为application.xml.(错误)&lt;br&gt;真实原因是spring解析xml的时候死循
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>idea_artifacts依赖错误</title>
    <link href="https://lmxy1990.github.io/2018/05/03/idea-artifacts%E4%BE%9D%E8%B5%96%E9%94%99%E8%AF%AF/"/>
    <id>https://lmxy1990.github.io/2018/05/03/idea-artifacts依赖错误/</id>
    <published>2018-05-03T11:14:32.000Z</published>
    <updated>2018-05-03T11:34:06.689Z</updated>
    
    <content type="html"><![CDATA[<h3 id="idea折腾一天"><a href="#idea折腾一天" class="headerlink" title="idea折腾一天"></a>idea折腾一天</h3><p>今天搭项目时候,明明pom文件依赖有了,model的依赖也正常.<br>偏偏artifacts的依赖就坑爹了.<br>现象是导出的war包没有依赖.反复检查配置文件,发现<em>.iml没有对应的依赖配置.手动修改</em>.iml也没卵用.又会自动修改回去.<br>后面感觉还是项目配置的问题,反复折腾N个小时.MD,IDEA就是个ZZ,我的maven项目是父项目 -&gt; 3个子项目 ,我添加进来的pom是父项目.然后我要导出的war是子项目.这时候,子项目就拿不到依赖了.</p>
<h2 id="这尼玛坑逼啊-折腾N久才发现者逼东西"><a href="#这尼玛坑逼啊-折腾N久才发现者逼东西" class="headerlink" title="这尼玛坑逼啊,折腾N久才发现者逼东西."></a>这尼玛坑逼啊,折腾N久才发现者逼东西.</h2><p>后面引入项目的时候,只引入子项目.不引入父项目就OK了.<br>引入子项目的时候,会自动生成*.iml.<br>该文件的依赖是正常的,导出的war也正常了.</p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;idea折腾一天&quot;&gt;&lt;a href=&quot;#idea折腾一天&quot; class=&quot;headerlink&quot; title=&quot;idea折腾一天&quot;&gt;&lt;/a&gt;idea折腾一天&lt;/h3&gt;&lt;p&gt;今天搭项目时候,明明pom文件依赖有了,model的依赖也正常.&lt;br&gt;偏偏artifact
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>spring 拦截器</title>
    <link href="https://lmxy1990.github.io/2018/04/18/spring-%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>https://lmxy1990.github.io/2018/04/18/spring-拦截器/</id>
    <published>2018-04-18T05:59:31.000Z</published>
    <updated>2018-05-03T11:02:53.052Z</updated>
    
    <content type="html"><![CDATA[<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>请求的路径:<br>client -&gt; tcp/ip -&gt; 服务器系统层 -&gt; 应用层(nginx -&gt; tomcat -&gt; servlet层 -&gt; DispatcherServlet -&gt; 拦截处理handler/adapter -&gt; controller -&gt; 试图渲染 -&gt;tcp/ip -&gt; 客户端 -&gt;客户端浏览器)</p>
<p>1.拦截器一般实现HandlerInterceptor接口或者继承HandlerInterceptorAdapter.<br>也可以实现WebRequestInterceptor 接口</p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;拦截器&quot;&gt;&lt;a href=&quot;#拦截器&quot; class=&quot;headerlink&quot; title=&quot;拦截器&quot;&gt;&lt;/a&gt;拦截器&lt;/h3&gt;&lt;p&gt;请求的路径:&lt;br&gt;client -&amp;gt; tcp/ip -&amp;gt; 服务器系统层 -&amp;gt; 应用层(nginx -&amp;gt; t
    
    </summary>
    
      <category term="拦截器" scheme="https://lmxy1990.github.io/categories/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM一些理解:</title>
    <link href="https://lmxy1990.github.io/2018/03/17/JVM%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>https://lmxy1990.github.io/2018/03/17/JVM一些理解/</id>
    <published>2018-03-17T00:49:37.000Z</published>
    <updated>2018-04-18T05:58:48.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="##JVM  内存模型"></a>##JVM  内存模型</h2><p>内存模型分为:方法区,堆区,虚拟机栈,本地方法栈,程序计数器.</p>
<ol>
<li><p>方法区(线程共享)<br>存储了每一个类的结构信息，例如运行时常量池（ Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法.(jdk7 hotspot 中采用来实现永久带,1.8采用元数据区来实现.)</p>
</li>
<li><p>堆区(线程共享)<br>存放对象的区域</p>
</li>
<li><p>虚拟机栈<br>方法运行时创建的栈帧,用于存放局部变量,操作数栈,动态链接,方法出口,每个方法局部变量是隔离的.</p>
</li>
<li><p>本地方法栈<br>native方法运行时,存放局部变量,操作数栈,方法出口的信息.</p>
</li>
<li><p>程序计数器<br>当前程序执行字节码的指示器,通过改变计数器来选取下一条需要执行的字节码指令.</p>
</li>
<li><p>元数据区<br>作用类似用永久带</p>
</li>
</ol>
<p>总结:JVM 内存模型,分为5块.方法区,堆区,虚拟机栈,本地方法栈,程序计数器.我的理解是,方法区的作用类似一个hashTable.里面记录的是各个类的骨架信息,执行方法的程序计数器指令的位置,以及一些其他必要参数.通过这些参数,在方法调用的时候,通过方法区的指引,执行相关的程序指令,创建用于该方法的虚拟机栈或者本地方法栈来处理一些过程数据,最后返回相应的结果给到调用者.这里虚拟机栈创建的对象存放于堆区,方法区修改对象,实际上是修改的堆中的对象.但局部变量在虚拟机栈中,所以方法里面修改局部变量,其实是不影响全局变量的.但是修改对象就会.原因就在这里.<br>所以,虚拟机垃圾回收的主要集中在堆区.对方法区也有可能触发.方法区申请新的内存区域不足是,会抛出相应异常.</p>
<p>垃圾回收区域:新生代,老年代,永久带(元数据区). 永久带垃圾回收效率低.</p>
<h2 id="JVM-GC回收机制"><a href="#JVM-GC回收机制" class="headerlink" title="##JVM GC回收机制"></a>##JVM GC回收机制</h2><h1 id="判断是否为垃圾的算法"><a href="#判断是否为垃圾的算法" class="headerlink" title="判断是否为垃圾的算法"></a>判断是否为垃圾的算法</h1><ol>
<li>引用标计算法<br>每一个对象,对有一个引用计数器.存在引用则计数器+1,缺点:引用计数器不能解决循环引用的问题,而且引用计数器本身存在内存开销.</li>
<li>根搜索算法<br>将某些特殊的对象定义为GC Root . 某个对象 与其他所有对象的引用关系组成一条链. 如果组成的这条链无限延伸都没有GC根相连,则证明该链上的所有对象都是可以回收的垃圾对象.GC根对象指的是:虚拟机栈中引用的对象,方法区常量引用的对象,方法区静态属性引用的对象,本地方法栈中JNI引用的对象,活跃的线程.(其实就是正在运行的数据+静态数据)</li>
</ol>
<h1 id="执行垃圾回收的算法"><a href="#执行垃圾回收的算法" class="headerlink" title="执行垃圾回收的算法"></a>执行垃圾回收的算法</h1><ol>
<li>copy 算法(年轻代)</li>
<li>标记-清除/整理 算法</li>
</ol>
<h1 id="spothot-提供的垃圾回收器"><a href="#spothot-提供的垃圾回收器" class="headerlink" title="spothot 提供的垃圾回收器"></a>spothot 提供的垃圾回收器</h1><ol>
<li>SerialGC 串行(copy)垃圾回收器(年轻代)</li>
<li>SerialOldGC 串行(老年代)</li>
<li>ParNewGC 并行(copy)垃圾回收器(年轻代)</li>
<li>ParallelGC 并行(copy),提高吞吐量.(年轻代)</li>
<li>ParallelOldGC 并行(copy),(老年代)</li>
<li>ConcMarkSweepGC 标记清除(老年代) ,新生代 ParNewGC</li>
<li>G1GC 新生代/老年代(G1)</li>
</ol>
<p>##JVM 性能调优</p>
<p>应尽量避免FULL GC</p>
<ol>
<li>避免出现Full GC</li>
<li>根据对应的场景选取适配的垃圾回收器</li>
<li>配置合理的内存整理次数.</li>
<li></li>
</ol>
<hr>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JVM-内存模型&quot;&gt;&lt;a href=&quot;#JVM-内存模型&quot; class=&quot;headerlink&quot; title=&quot;##JVM  内存模型&quot;&gt;&lt;/a&gt;##JVM  内存模型&lt;/h2&gt;&lt;p&gt;内存模型分为:方法区,堆区,虚拟机栈,本地方法栈,程序计数器.&lt;/p&gt;
&lt;ol&gt;
    
    </summary>
    
      <category term="jvm" scheme="https://lmxy1990.github.io/categories/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>java tensorflow</title>
    <link href="https://lmxy1990.github.io/2018/02/07/java-tensorflow/"/>
    <id>https://lmxy1990.github.io/2018/02/07/java-tensorflow/</id>
    <published>2018-02-07T01:08:51.000Z</published>
    <updated>2018-02-07T01:38:07.463Z</updated>
    
    <content type="html"><![CDATA[<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p>参考:<a href="https://www.tensorflow.org/api_docs/java/reference/org/tensorflow/package-summary" target="_blank" rel="external">https://www.tensorflow.org/api_docs/java/reference/org/tensorflow/package-summary</a></p>
<h2 id="常用类说明"><a href="#常用类说明" class="headerlink" title="常用类说明"></a>常用类说明</h2><p>Tensor<t><br>一个静态类型的多维数组，其元素是由T描述的类型</t></p>
<p>Tensors<br>静态工厂方法创建一个Tensor.</p>
<p>Shape<br>操作产生的tensor可能的形状。</p>
<p>Graph<br>TensorFlow计算的数据流图。</p>
<p>OperationBuilder<br>执行Graph操作的构建器。</p>
<p>Operation<br>在Tensor上执行计算的Graph节点。</p>
<p>Output<t><br>由操作产生的tensor处理对象。</t></p>
<p>SavedModelBundle<br>表示从存储装载的模型。</p>
<p>Session<br>图形执行的驱动程序。</p>
<p>Session.Run<br>输出tensors和执行session时获得的元数据。</p>
<p>Session.Runner<br>运行操作并计算Tensors。</p>
<p>TensorFlow<br>TensorFlow运行时的静态实用程序方法。</p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;api&quot;&gt;&lt;a href=&quot;#api&quot; class=&quot;headerlink&quot; title=&quot;api&quot;&gt;&lt;/a&gt;api&lt;/h3&gt;&lt;p&gt;参考:&lt;a href=&quot;https://www.tensorflow.org/api_docs/java/reference/org
    
    </summary>
    
      <category term="java tensorflow" scheme="https://lmxy1990.github.io/categories/java-tensorflow/"/>
    
    
  </entry>
  
  <entry>
    <title>linux svn服务器安装</title>
    <link href="https://lmxy1990.github.io/2017/12/08/linux-svn%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85/"/>
    <id>https://lmxy1990.github.io/2017/12/08/linux-svn服务器安装/</id>
    <published>2017-12-08T02:15:03.000Z</published>
    <updated>2017-12-18T07:37:57.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>官方安装说明:<br><code>https://subversion.apache.org/packages.html#centos</code></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li>创建一个svn库文件夹：<br><code>mkdir -p /opt/svn/repo/</code></li>
<li><p>将该文件夹初始化为SVN库：<br><code>svnadmin create /opt/svn/repo/</code></p>
</li>
<li><p>生成如下目录和文件：<br> 目录：locks<br> 目录：hooks<br> 目录：db<br> 目录：conf<br> 文件：format<br> 文件：README.txt</p>
</li>
<li>conf 是配置文件夹<br> svnserve.conf 是 svn 服务综合配置文件<br> passwd 是用户名和密码配置文件<br> authz 是权限配置文件</li>
<li><p>配置svnserve<br><code>vim /opt/svn/repo/conf/svnserve.conf</code></p>
<ol>
<li>anon-access： 对不在授权名单中的用户访问仓库的权限控制，有三个可选性：write、read、none<br>none 表示没有任何权限<br>read 表示只有只读权限<br>write 表示有读写权限</li>
<li>auth-access：<br>对在授权名单中的用户访问仓库的权限控制，有三个可选性：write、read、none<br>none 表示没有任何权限<br>read 表示只有只读权限<br>write 表示有读写权限</li>
</ol>
</li>
<li><p>password-db：用户数据配置文件</p>
</li>
<li><p>authz-db：用户权限配置文件</p>
</li>
<li><p>realm：指定版本库的认证域.<br>即在登录时提示的认证域名称。若两个版本库的认证域相同，建议使用相同的用户名口令数据文件<br>当前实例的配置内容：realm = myrepo</p>
</li>
<li><p>添加用户<br><code>vim /opt/svn/repo/conf/passwd</code><br>添加一个格式为：用户名 = 密码</p>
</li>
<li><p>设置用户/用户组权限<br><code>vim /opt/svn/repo/conf/authz</code></p>
</li>
</ol>
<p>[groups] 配置</p>
<p>用户组:组名 = 用户1,用户2<br>使用组权限方式：@组名 = rw</p>
<ul>
<li>= 表示除了上面设置的权限用户组以外，其他所有用户都设置空权限，空权限表示禁止访问本目录.</li>
</ul>
<p>启动服务<br><code>svnserve -d -r /opt/svn/repo/ --listen-port 3690</code></p>
<p>-d 表示后台运行<br>-r /opt/svn/repo/ 表示指定根目录<br>–listen-port 3690 表示指定端口，默认就是 3690，所以如果要用默认端口这个也是可以省略掉的</p>
<p>停止服务<br><code>killall svnserve</code></p>
<h3 id="http服务配置"><a href="#http服务配置" class="headerlink" title="http服务配置"></a>http服务配置</h3><p>安装svn驱动模块<br><code>yum install mod_dav_svn</code></p>
<p>安装http服务<br><code>yum install httpd</code></p>
<p>查看http服务配置,是否监听80端口.<br><code>vim /etc/httpd/conf/httpd.conf</code></p>
<p>配置http的用户密码文件.<br><code>htpasswd -cm /opt/svn/repo/conf/svn-auth-conf admin</code></p>
<p>该命令,是添加一个用户admin,密码会提示输入.</p>
<p>修改http的用户密码文件<br><code>htpasswd -m /opt/svn/repo/conf/svn-auth-conf admin</code></p>
<p>将该密码文件配置到http服务.<br><code>vim /etc/httpd/conf.modules.d/odules.d/10-subversion.conf</code></p>
<p>这里的配置,是http模块的配置文件,在之前的http的配置里面其实有说明,http服务启动的时候,会加在该目录下的所有文件.<br>编辑这个文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LoadModule dav_svn_module     modules/mod_dav_svn.so</span><br><span class="line">LoadModule authz_svn_module   modules/mod_authz_svn.so</span><br><span class="line">LoadModule dontdothat_module  modules/mod_dontdothat.so</span><br><span class="line">DAV svn</span><br><span class="line">SVNPath /opt/svn/repo</span><br><span class="line">#SVNParentPath /home/svn/data</span><br><span class="line">AuthzSVNAccessFile /opt/svn/repo/conf/passwd</span><br><span class="line">AuthType Basic</span><br><span class="line">AuthName &quot;Subversion repos&quot;</span><br><span class="line">AuthUserFile /opt/svn/repo/conf/svn-auth-conf</span><br><span class="line">Require valid-user</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;官方安装说明:&lt;br&gt;&lt;code&gt;https://subversion.apache.org/packages.html#centos&lt;/c
    
    </summary>
    
      <category term="svn" scheme="https://lmxy1990.github.io/categories/svn/"/>
    
    
  </entry>
  
  <entry>
    <title>dubbo 源码学习</title>
    <link href="https://lmxy1990.github.io/2017/11/27/dubbo-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://lmxy1990.github.io/2017/11/27/dubbo-源码学习/</id>
    <published>2017-11-27T08:09:56.000Z</published>
    <updated>2018-03-09T03:17:13.375Z</updated>
    
    <content type="html"><![CDATA[<h3 id="dubbo-需要解决的问题"><a href="#dubbo-需要解决的问题" class="headerlink" title="dubbo 需要解决的问题"></a>dubbo 需要解决的问题</h3><ol>
<li>负载均衡</li>
<li>远程 rpc 调用</li>
<li>权限控制</li>
<li>dubbo运行状态监控</li>
</ol>
<h3 id="RPC-调用"><a href="#RPC-调用" class="headerlink" title="RPC 调用"></a>RPC 调用</h3><hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;dubbo-需要解决的问题&quot;&gt;&lt;a href=&quot;#dubbo-需要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;dubbo 需要解决的问题&quot;&gt;&lt;/a&gt;dubbo 需要解决的问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;远程 rpc
    
    </summary>
    
      <category term="dubbo 源码" scheme="https://lmxy1990.github.io/categories/dubbo-%E6%BA%90%E7%A0%81/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 泛型</title>
    <link href="https://lmxy1990.github.io/2017/11/27/Java-%E6%B3%9B%E5%9E%8B/"/>
    <id>https://lmxy1990.github.io/2017/11/27/Java-泛型/</id>
    <published>2017-11-27T07:51:28.000Z</published>
    <updated>2017-11-27T07:59:20.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><ol>
<li>extends</li>
<li>super<br>extends 确定的是上界,super 约定的是下界.</li>
</ol>
<p>上界约束set,下界约束get.</p>
<h3 id="与-T-E-K-Object"><a href="#与-T-E-K-Object" class="headerlink" title="?与 T,E,K,Object"></a><code>?</code>与 T,E,K,Object</h3><ol>
<li>? 代表通配符.</li>
<li>泛型确定类型约束</li>
<li>Object超类.</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>使用场景,接口的定义应该是符合业务逻辑.然后范围竟可能的狭隘.<br>考虑的顺序:<br>泛型 -&gt; 统配类型(带上下界) -&gt; 超类<br>泛型 :约束某一个类型.<br>?:约束某一种类型<br>Object: 无约束</p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;边界&quot;&gt;&lt;a href=&quot;#边界&quot; class=&quot;headerlink&quot; title=&quot;边界&quot;&gt;&lt;/a&gt;边界&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;extends&lt;/li&gt;
&lt;li&gt;super&lt;br&gt;extends 确定的是上界,super 约定的是下界.&lt;/li&gt;
&lt;/ol
    
    </summary>
    
      <category term="泛型" scheme="https://lmxy1990.github.io/categories/%E6%B3%9B%E5%9E%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>后如何同步更新&#39;</title>
    <link href="https://lmxy1990.github.io/2017/11/10/fork%E5%90%8E%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0/"/>
    <id>https://lmxy1990.github.io/2017/11/10/fork后如何同步更新/</id>
    <published>2017-11-10T01:59:17.000Z</published>
    <updated>2017-11-10T06:50:09.291Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git-fork之后-如何保持代码的更新"><a href="#git-fork之后-如何保持代码的更新" class="headerlink" title="git fork之后,如何保持代码的更新."></a>git fork之后,如何保持代码的更新.</h3><p>第一步:将源添加到一个更新的组里面.(这里认为你已经clone下来你的项目)<br>添加的名字可以随意,与后面操作一致即可.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add updateOrigin https://github.com/更新源的地址.git</span><br></pre></td></tr></table></figure></p>
<p>第二步:更新 updateOrigin 代码到最新.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch updateOrigin</span><br></pre></td></tr></table></figure></p>
<p>第三步:合并最新代码到你的master.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge updateOrigin/master</span><br></pre></td></tr></table></figure></p>
<p>第四步:提交变更到master.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;git-fork之后-如何保持代码的更新&quot;&gt;&lt;a href=&quot;#git-fork之后-如何保持代码的更新&quot; class=&quot;headerlink&quot; title=&quot;git fork之后,如何保持代码的更新.&quot;&gt;&lt;/a&gt;git fork之后,如何保持代码的更新.&lt;/h3
    
    </summary>
    
      <category term="git fork" scheme="https://lmxy1990.github.io/categories/git-fork/"/>
    
    
  </entry>
  
  <entry>
    <title>&#39;多个集合排列组合&#39;</title>
    <link href="https://lmxy1990.github.io/2017/11/03/%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    <id>https://lmxy1990.github.io/2017/11/03/多个集合排列组合/</id>
    <published>2017-11-03T03:45:17.000Z</published>
    <updated>2017-11-10T06:42:55.417Z</updated>
    
    <content type="html"><![CDATA[<h3 id="笛卡尔乘积"><a href="#笛卡尔乘积" class="headerlink" title="笛卡尔乘积"></a>笛卡尔乘积</h3><h2 id="1-两个集合-组成新的集合"><a href="#1-两个集合-组成新的集合" class="headerlink" title="1.两个集合,组成新的集合."></a>1.两个集合,组成新的集合.</h2><p>处理的思想:<br>1.从一个集合中,取出一个元素. 这个元素与另外的一个集合做一次组合.组成新的集合.<br>第一个集合遍历完成,则组合完成.</p>
<p>即记第一个集合的长度是M ,另一个集合的长度是N.<br>则需要遍历的次数是M*N .<br>因为集合1中的每一个元素,都需要遍历N次.</p>
<p>而笛卡尔乘积亦是M*N</p>
<h2 id="2-多个集合-组成的笛卡尔乘积"><a href="#2-多个集合-组成的笛卡尔乘积" class="headerlink" title="2.多个集合,组成的笛卡尔乘积."></a>2.多个集合,组成的笛卡尔乘积.</h2><p>这里有两种思路:<br>第一种是采用递归.<br>第二种是采用循环.</p>
<p>原理上来说,我的解决思路是多个集合的笛卡尔乘积拆分成2个笛卡尔乘积的运算.<br>每次都是当前的集合与下一个集合做<code>2个迪卡而乘积运算</code>.</p>
<p>递归的写法是写一个处理2个集合的方法,然后有条件的递归调用.递归写起来比较简单.</p>
<p>循环的思想,可以考虑采用栈.</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>笛卡尔乘积使用场景还是很多的,例如组合排列.商品sku.等等</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码:"></a>示例代码:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 数据组装:递归处理</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 思路:从第一层取出该层所有元素,与下一层的每一个元素拼接.组成中间变量,继续拼接下一层.直到层数拼接完成.</span><br><span class="line"> * 这时候,该层的所有数据已完成拼接.则返回拼接数据的list.</span><br><span class="line"> *</span><br><span class="line"> * @param layer     层</span><br><span class="line"> * @param nowString 当前组合的中间变量</span><br><span class="line"> * @param lists     待组合的所有数据,</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static List&lt;String&gt; fxEachShangPin(int layer, String nowString, List&lt;List&lt;ShangPin&gt;&gt; lists) &#123;</span><br><span class="line">    List&lt;String&gt; strings = new ArrayList&lt;&gt;();</span><br><span class="line">    if (layer &lt; lists.size()) &#123;//有下一个List</span><br><span class="line">        List&lt;ShangPin&gt; nextList = lists.get(layer);</span><br><span class="line">        for (int i = 0; i &lt; nextList.size(); i++) &#123;</span><br><span class="line">            ShangPin subShangPin = nextList.get(i);</span><br><span class="line">            String tmpStr = subShangPin.getSpName();</span><br><span class="line">            //当前层级与下一层级组装</span><br><span class="line">            if (StringUtils.isNotBlank(nowString)) &#123;</span><br><span class="line">                tmpStr = nowString + &quot;-&quot; + tmpStr;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;String&gt; subStr = fxEachShangPin(layer + 1, tmpStr, lists);</span><br><span class="line">            strings.addAll(subStr);</span><br><span class="line">        &#125;</span><br><span class="line">        return strings;</span><br><span class="line">    &#125; else &#123; //没有下一层</span><br><span class="line">        return Lists.newArrayList(nowString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line"> * 使用循环来解决,有栈的思想</span><br><span class="line"> *</span><br><span class="line"> * @param lists</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static List&lt;String&gt; fxStackShangPin(List&lt;List&lt;ShangPin&gt;&gt; lists) &#123;</span><br><span class="line">    if (CollectionUtils.isEmpty(lists)) return new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; rs = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; tmpList = new ArrayList&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    stack.push(0);</span><br><span class="line">    while (stack.size() != 0) &#123;</span><br><span class="line">        Integer layer = stack.pop();</span><br><span class="line">        List&lt;ShangPin&gt; shangPins = lists.get(layer);</span><br><span class="line">        if (CollectionUtils.isEmpty(shangPins)) continue;</span><br><span class="line">        //初次塞值</span><br><span class="line">        if (CollectionUtils.isEmpty(rs)) &#123;</span><br><span class="line">            for (int i = 0; i &lt; shangPins.size(); i++) &#123;</span><br><span class="line">                ShangPin shangPin = shangPins.get(i);</span><br><span class="line">                if (shangPin == null) continue;</span><br><span class="line">                tmpList.add(shangPin.getSpName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //二级数据组装</span><br><span class="line">        if (!CollectionUtils.isEmpty(rs)) &#123;</span><br><span class="line">            for (int i = 0; i &lt; rs.size(); i++) &#123;//数据组装</span><br><span class="line">                String s = rs.get(i);</span><br><span class="line">                for (int j = 0; j &lt; shangPins.size(); j++) &#123;</span><br><span class="line">                    ShangPin shangPin = shangPins.get(j);</span><br><span class="line">                    if (shangPin == null) continue;</span><br><span class="line">                    String tmp = shangPin.getSpName();</span><br><span class="line">                    if (StringUtils.isNotBlank(s)) &#123;</span><br><span class="line">                        tmp = s + &quot;-&quot; + shangPin.getSpName();</span><br><span class="line">                    &#125;</span><br><span class="line">                    tmpList.add(i, tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //临时变量传递</span><br><span class="line">        rs.clear();</span><br><span class="line">        rs.addAll(tmpList);</span><br><span class="line">        tmpList.clear();</span><br><span class="line">        layer++;</span><br><span class="line">        //下一层级</span><br><span class="line">        if (layer &lt; lists.size()) &#123;</span><br><span class="line">            stack.push(layer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;笛卡尔乘积&quot;&gt;&lt;a href=&quot;#笛卡尔乘积&quot; class=&quot;headerlink&quot; title=&quot;笛卡尔乘积&quot;&gt;&lt;/a&gt;笛卡尔乘积&lt;/h3&gt;&lt;h2 id=&quot;1-两个集合-组成新的集合&quot;&gt;&lt;a href=&quot;#1-两个集合-组成新的集合&quot; class=&quot;header
    
    </summary>
    
      <category term="排列 组合 笛卡尔乘积" scheme="https://lmxy1990.github.io/categories/%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88-%E7%AC%9B%E5%8D%A1%E5%B0%94%E4%B9%98%E7%A7%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>背包问题求解</title>
    <link href="https://lmxy1990.github.io/2017/09/28/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%B1%82%E8%A7%A3/"/>
    <id>https://lmxy1990.github.io/2017/09/28/背包问题求解/</id>
    <published>2017-09-28T11:04:03.000Z</published>
    <updated>2017-09-28T11:08:29.130Z</updated>
    
    <content type="html"><![CDATA[<h3 id="求解代码"><a href="#求解代码" class="headerlink" title="求解代码"></a>求解代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br></pre></td><td class="code"><pre><span class="line">package com.pan.test.domain;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.apache.commons.collections4.CollectionUtils;</span><br><span class="line">import org.apache.commons.lang3.builder.EqualsBuilder;</span><br><span class="line">import org.apache.commons.lang3.builder.HashCodeBuilder;</span><br><span class="line">import org.assertj.core.util.Lists;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class AlgorithmTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //eg1:背包问题,限定重量 5kg .</span><br><span class="line">        dpAlgorithm();</span><br><span class="line"></span><br><span class="line">        //eg1:多集合交集覆盖范围问题.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 动态规划:背包问题,限定重量 5kg ,选取价值最大的商品组合.(可以重复选取)</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 问题分析:该类问题,选取个数无限制,唯一限制的是重量(权重).</span><br><span class="line">     * 对于该类问题,使用动态规划的原理是,每个因子,都是可以替换的.</span><br><span class="line">     * 故而可以采用递归选优的方式,层级递归.(这里可以用循环代替,但思想是层级递归)</span><br><span class="line">     * 也就是说,第一层与第二层在限定条件下,选取最优解,选取出来的最优解与第三层比较,选取更优解.</span><br><span class="line">     * 直到所有因子选完,则该解为最优解.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * ps:此类算法无法解决球队选球员问题.及多集合选取最优解,每个集合只能选取一个.不能解决此问题的原因是,一个球队是一个整体,</span><br><span class="line">     * 这个整体的最优解,来源依赖每一个位置的集合.而每个位置只能有一个人.他的权重比值是分布在整个球员身上.</span><br><span class="line">     * 也无法采用迪克斯特拉算法,因为这里存在限制条件,而这个限制条件是整个球队的.所以球员的限制条件其实是不确定的.如果采用迪克斯特拉算法,</span><br><span class="line">     * 那么,选取出来的路径,可能走不到终点.</span><br><span class="line">     */</span><br><span class="line">    public static void dpAlgorithm() &#123;</span><br><span class="line"></span><br><span class="line">        //待选商品</span><br><span class="line">        Product banana = new Product(&quot;香蕉&quot;, 7, 1);</span><br><span class="line">        Product apple = new Product(&quot;苹果&quot;, 15, 2);</span><br><span class="line">        Product orange = new Product(&quot;桔子&quot;, 24, 3);</span><br><span class="line">        Product durian = new Product(&quot;榴莲&quot;, 31, 4);</span><br><span class="line">        List&lt;Product&gt; products = Lists.newArrayList(apple, banana, durian, orange);</span><br><span class="line">        //100个背包</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            Bag bag = new Bag(&quot;小背包&quot; + i, 3 + i, new ArrayList&lt;&gt;(), 0, 0);</span><br><span class="line">            for (int j = 0; j &lt; products.size(); j++) &#123;</span><br><span class="line">                Product product = products.get(j);</span><br><span class="line">                bag = fillBag(bag, product, products);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;背包:&quot; + bag.getBagName() + &quot;\t 总价:&quot; + bag.getSumPrice() + &quot;\t 限重:&quot; + bag.getMaxWeight() + &quot;\t 总重量:&quot; + bag.getSumWeight());</span><br><span class="line">            //输出选取商品名</span><br><span class="line">            String pickName = null;</span><br><span class="line">            List&lt;Product&gt; bagProducts = bag.getProducts();</span><br><span class="line">            for (int j = 0; j &lt; bagProducts.size(); j++) &#123;</span><br><span class="line">                Product product = bagProducts.get(j);</span><br><span class="line">                if (pickName == null) &#123;</span><br><span class="line">                    pickName = product.getName();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                pickName += &quot;-&quot; + product.getName();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;背包:&quot; + bag.getBagName() + &quot;\t 挑选的商品:&quot; + pickName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将商品放入背包</span><br><span class="line">     *</span><br><span class="line">     * @param bag</span><br><span class="line">     * @param product</span><br><span class="line">     * @param products</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Bag fillBag(Bag bag, Product product, List&lt;Product&gt; products) &#123;</span><br><span class="line">        Map&lt;Float, Product&gt; productMap = setupProductMap(products);</span><br><span class="line">        float minWeight = products.stream().min(Comparator.comparing(Product::getWeight)).get().getWeight();</span><br><span class="line">        float maxWeight = bag.getMaxWeight();</span><br><span class="line">        List&lt;Product&gt; pickList = bag.getProducts();</span><br><span class="line">        float sumPrice = bag.getSumPrice();</span><br><span class="line">        float sumWeight = bag.getSumWeight();</span><br><span class="line">        //第一次塞入</span><br><span class="line">        if (CollectionUtils.isEmpty(pickList)) &#123;</span><br><span class="line">            while (sumWeight &lt;= maxWeight - product.getWeight()) &#123;</span><br><span class="line">                pickList.add(product);</span><br><span class="line">                sumWeight += product.getWeight();</span><br><span class="line">                sumPrice += product.getPrice();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //替换</span><br><span class="line">            List&lt;Product&gt; needAdd = new ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;Product&gt; needRemove = new ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;Product&gt; subRemove = new ArrayList&lt;&gt;();</span><br><span class="line">            float removeWeight = 0;</span><br><span class="line">            float removePrice = 0;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; pickList.size(); i++) &#123;</span><br><span class="line">                Product tmp = pickList.get(i);</span><br><span class="line">                //单个替换</span><br><span class="line">                if (tmp.getPrice() / tmp.getWeight() &lt; product.getPrice() / product.getWeight() &amp;&amp; tmp.getWeight() + (maxWeight - sumWeight) &gt;= product.getWeight()) &#123;</span><br><span class="line">                    sumWeight += product.getWeight() - tmp.getWeight();</span><br><span class="line">                    sumPrice += product.getPrice() - tmp.getPrice();</span><br><span class="line">                    needAdd.add(product);</span><br><span class="line">                    needRemove.add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                //组合替换</span><br><span class="line">                subRemove.add(tmp);</span><br><span class="line">                removeWeight += tmp.getWeight();</span><br><span class="line">                removePrice += tmp.getPrice();</span><br><span class="line">                if (removePrice / removeWeight &lt; product.getPrice() / product.getWeight() &amp;&amp; removeWeight + (maxWeight - sumWeight) &gt;= product.getWeight()) &#123;</span><br><span class="line">                    sumWeight += product.getWeight() - removeWeight;</span><br><span class="line">                    sumPrice += product.getPrice() - removePrice;</span><br><span class="line">                    needAdd.add(product);</span><br><span class="line"></span><br><span class="line">                    needRemove.addAll(subRemove);</span><br><span class="line">                    subRemove.clear();</span><br><span class="line">                    removeWeight = 0;</span><br><span class="line">                    removePrice = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                //剩余空间塞值</span><br><span class="line">                float surplus = maxWeight - sumWeight;</span><br><span class="line">                Product surPlus = getSurPlus(products, productMap, surplus);</span><br><span class="line">                while (surplus &gt;= minWeight &amp;&amp; surPlus != null) &#123;</span><br><span class="line">                    sumWeight += surPlus.getWeight();</span><br><span class="line">                    sumPrice += surPlus.getPrice();</span><br><span class="line">                    needAdd.add(surPlus);</span><br><span class="line">                    surplus = maxWeight - sumWeight;</span><br><span class="line">                    surPlus = getSurPlus(products, productMap, surplus);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //删除替换掉的</span><br><span class="line">            Iterator&lt;Product&gt; removes = needRemove.iterator();</span><br><span class="line">            Iterator&lt;Product&gt; pickIt = pickList.iterator();</span><br><span class="line">            while (removes.hasNext()) &#123;</span><br><span class="line">                Product remove = removes.next();</span><br><span class="line">                while (pickIt.hasNext()) &#123;</span><br><span class="line">                    Product pick = pickIt.next();</span><br><span class="line">                    if (pick.equals(remove)) &#123;</span><br><span class="line">                        pickIt.remove();</span><br><span class="line">                        removes.remove();</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pickList.addAll(needAdd);</span><br><span class="line">        &#125;</span><br><span class="line">        bag.setMaxWeight(maxWeight);</span><br><span class="line">        bag.setSumPrice(sumPrice);</span><br><span class="line">        bag.setSumWeight(sumWeight);</span><br><span class="line">        bag.setProducts(pickList);</span><br><span class="line">        return bag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取指定可选重量下,最佳选择的商品</span><br><span class="line">     *</span><br><span class="line">     * @param products</span><br><span class="line">     * @param setupProductMap</span><br><span class="line">     * @param surplus</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static Product getSurPlus(List&lt;Product&gt; products, Map&lt;Float, Product&gt; setupProductMap, float surplus) &#123;</span><br><span class="line">        Product product = setupProductMap.get(surplus);</span><br><span class="line">        if (product != null) &#123;</span><br><span class="line">            return product;</span><br><span class="line">        &#125;</span><br><span class="line">        //重新查找</span><br><span class="line">        for (int i = 0; i &lt; products.size(); i++) &#123;</span><br><span class="line">            Product tmp = products.get(i);</span><br><span class="line">            if (tmp.getWeight() &lt;= surplus) &#123;</span><br><span class="line">                if (product == null) &#123;</span><br><span class="line">                    product = tmp;</span><br><span class="line">                &#125; else if (product.getPrice() &lt; tmp.getPrice()) &#123;</span><br><span class="line">                    product = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setupProductMap.put(surplus, product);</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 相同商品重量的最高价值商品map</span><br><span class="line">     *</span><br><span class="line">     * @param products</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static Map&lt;Float, Product&gt; setupProductMap(List&lt;Product&gt; products) &#123;</span><br><span class="line">        Map&lt;Float, Product&gt; productMap = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; products.size(); i++) &#123;</span><br><span class="line">            Product tmp = products.get(i);</span><br><span class="line">            Product old = productMap.get(tmp.getWeight());</span><br><span class="line">            if (old == null) &#123;</span><br><span class="line">                productMap.put(tmp.getWeight(), tmp);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (old.getPrice() &lt; tmp.getPrice()) &#123;</span><br><span class="line">                productMap.put(tmp.getWeight(), tmp);</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return productMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 背包实体类</span><br><span class="line"> */</span><br><span class="line">class Bag implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 3554907573665360761L;</span><br><span class="line"></span><br><span class="line">    public Bag(String bagName, float maxWeight, List&lt;Product&gt; products, float sumPrice, float sumWeight) &#123;</span><br><span class="line">        this.bagName = bagName;</span><br><span class="line">        this.maxWeight = maxWeight;</span><br><span class="line">        this.products = products;</span><br><span class="line">        this.sumPrice = sumPrice;</span><br><span class="line">        this.sumWeight = sumWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        if (this == o) return true;</span><br><span class="line"></span><br><span class="line">        if (!(o instanceof Bag)) return false;</span><br><span class="line"></span><br><span class="line">        Bag bag = (Bag) o;</span><br><span class="line"></span><br><span class="line">        return new EqualsBuilder()</span><br><span class="line">                .append(getMaxWeight(), bag.getMaxWeight())</span><br><span class="line">                .append(getSumPrice(), bag.getSumPrice())</span><br><span class="line">                .append(getSumWeight(), bag.getSumWeight())</span><br><span class="line">                .append(getBagName(), bag.getBagName())</span><br><span class="line">                .append(getProducts(), bag.getProducts())</span><br><span class="line">                .isEquals();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        return new HashCodeBuilder(17, 37)</span><br><span class="line">                .append(getBagName())</span><br><span class="line">                .append(getMaxWeight())</span><br><span class="line">                .append(getProducts())</span><br><span class="line">                .append(getSumPrice())</span><br><span class="line">                .append(getSumWeight())</span><br><span class="line">                .toHashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String bagName;</span><br><span class="line"></span><br><span class="line">    private float maxWeight;</span><br><span class="line"></span><br><span class="line">    private List&lt;Product&gt; products;</span><br><span class="line"></span><br><span class="line">    private float sumPrice;</span><br><span class="line">    private float sumWeight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public String getBagName() &#123;</span><br><span class="line">        return bagName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBagName(String bagName) &#123;</span><br><span class="line">        this.bagName = bagName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public float getMaxWeight() &#123;</span><br><span class="line">        return maxWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMaxWeight(float maxWeight) &#123;</span><br><span class="line">        this.maxWeight = maxWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Product&gt; getProducts() &#123;</span><br><span class="line">        return products;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProducts(List&lt;Product&gt; products) &#123;</span><br><span class="line">        this.products = products;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public float getSumPrice() &#123;</span><br><span class="line">        return sumPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSumPrice(float sumPrice) &#123;</span><br><span class="line">        this.sumPrice = sumPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public float getSumWeight() &#123;</span><br><span class="line">        return sumWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSumWeight(float sumWeight) &#123;</span><br><span class="line">        this.sumWeight = sumWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 商品实体类</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">class Product implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 5594269264643217406L;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Product(String name, float price, float weight) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.price = price;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private float price;</span><br><span class="line"></span><br><span class="line">    private float weight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public float getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(float price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public float getWeight() &#123;</span><br><span class="line">        return weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setWeight(float weight) &#123;</span><br><span class="line">        this.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;求解代码&quot;&gt;&lt;a href=&quot;#求解代码&quot; class=&quot;headerlink&quot; title=&quot;求解代码&quot;&gt;&lt;/a&gt;求解代码&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
    
    </summary>
    
      <category term="算法" scheme="https://lmxy1990.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>递归转化为栈</title>
    <link href="https://lmxy1990.github.io/2017/09/27/%E9%80%92%E5%BD%92%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%A0%88/"/>
    <id>https://lmxy1990.github.io/2017/09/27/递归转化为栈/</id>
    <published>2017-09-27T02:06:30.000Z</published>
    <updated>2017-09-27T02:44:15.494Z</updated>
    
    <content type="html"><![CDATA[<p>问题:找到某个门后面的人.</p>
<p>递归:大门 -&gt; 很多小门 -&gt; 很多小门 … </p>
<p>栈:大门 -&gt; 栈 ,出栈,打开门 –&gt; 小门入栈 –&gt; 出栈,打开门 – 小门入栈.</p>
<p>栈与递归的差别是,递归在内存之中,最外层的门其实未释放的.而递归是一直在压栈,出栈,拆解.所以,一般而言递归不会程序栈(内存)溢出.</p>
<p>递归代码:<br><code><br>Man open(Door door) {<br>    if (door.isHasMan){<br>    return door.man ;<br>    }<br>    if (door.isHasNextDoor){<br>        //递归<br>        return open(door.nextDoor)<br>    }<br>}<br></code><br>栈代码:<br><code><br>Man open(Door door){<br>    Man man ;<br>    Stack<door> stack = new Stack() ;<br>    stack.push(door) ;<br>    Door tmp ;<br>    while(stack.size() != 0){<br>        tmp = stack.peer() ;<br>        if (tmp.isHasMan){<br>            man = tmp.man ;<br>            break ;<br>        }<br>        if (tmp.hasNextDoor){<br>            stack.push(tmp.nextDoor) ;<br>        }<br>    }<br>}<br></door></code></p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题:找到某个门后面的人.&lt;/p&gt;
&lt;p&gt;递归:大门 -&amp;gt; 很多小门 -&amp;gt; 很多小门 … &lt;/p&gt;
&lt;p&gt;栈:大门 -&amp;gt; 栈 ,出栈,打开门 –&amp;gt; 小门入栈 –&amp;gt; 出栈,打开门 – 小门入栈.&lt;/p&gt;
&lt;p&gt;栈与递归的差别是,递归在内存之中,最
    
    </summary>
    
      <category term="递归 栈" scheme="https://lmxy1990.github.io/categories/%E9%80%92%E5%BD%92-%E6%A0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>算法笔记</title>
    <link href="https://lmxy1990.github.io/2017/09/14/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://lmxy1990.github.io/2017/09/14/算法笔记/</id>
    <published>2017-09-14T02:56:04.000Z</published>
    <updated>2017-11-03T04:21:38.182Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h3><hr>
<p>算法分析:<br>解决问题的途径有很多,意味着有很多的算法可供选择.那么,如何选择以及消耗的时间/性能在不同算法之间.会存在巨大的差异.在了解算法前,应学会如何分析算法.</p>
<p>数据量 n ;(输入规模)<br>单次执行时间 t(单次循环执行语句消耗时间)</p>
<p>在算法的比较中, t 可以认为全部为1(即单挑语句的执行时间认为一致).</p>
<p>从而获得一个关于输入量n的函数. 根据这个函数,与实际可能出现的n分布情况.</p>
<p>散列表(hash表) </p>
<p>NP 问题 :<br>可以简述为阶乘组合问题.(最常见,也最难解决)</p>
<p>最短路径:<br>多地点,多路径,路径有权值.权值为限制最佳条件.(单向路径最佳,双向也可以)</p>
<p>贪婪算法:<br>对于NP 问题,求取近似的最佳结果的算法.(结果非最佳).<br>第一步选取权值最大的一项,后面递减.</p>
<p>迪克斯特拉算法:<br>求解最短路径问题的算法.算法思想是两点之间,直连或借助其他点,每段分路径.取权值最小.加权之后,得出的路径根据权值筛选最佳路径.<br>目的 是A -&gt; D .其中有路径 A -&gt; D , A -&gt; B -&gt; D ,A -&gt; C -&gt; D<br>则 求解思路是 求出 A -&gt; B 所有方案的最优解,B -&gt; D 所有方案的最优解. 各个子最优解之和,取最优解.</p>
<p>动态规划<br>用于解决NP问题的算法.递归求出最小最优解,然后获得最佳最优解.<br>详情见后续叙述.</p>
<p>最近临近值<br>根据属性分类,来源新数据与旧类别比较.更为相似的作为同一类.(主要用于智能推送)</p>
<p>广度优先搜索.<br>多因素,取主因素最快速的算法.(例子:朋友圈经销商查找.)</p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法基础&quot;&gt;&lt;a href=&quot;#算法基础&quot; class=&quot;headerlink&quot; title=&quot;算法基础&quot;&gt;&lt;/a&gt;算法基础&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;算法分析:&lt;br&gt;解决问题的途径有很多,意味着有很多的算法可供选择.那么,如何选择以及消耗的时间/性能在不同算法之
    
    </summary>
    
      <category term="算法" scheme="https://lmxy1990.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL 锁</title>
    <link href="https://lmxy1990.github.io/2017/09/12/MySQL-%E9%94%81/"/>
    <id>https://lmxy1990.github.io/2017/09/12/MySQL-锁/</id>
    <published>2017-09-12T07:36:42.000Z</published>
    <updated>2017-09-12T08:55:15.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><hr>
<p>数据库锁,是为了支持对共享资源进行并发访问,保持数据一致性,完整性的一个特性.<br>与程序锁的概念类似.</p>
<h3 id="innoDB锁类型"><a href="#innoDB锁类型" class="headerlink" title="innoDB锁类型"></a>innoDB锁类型</h3><hr>
<p>共享锁(S):容许事物读取一行数据.</p>
<p>排它锁(X):容许事物删除或更新一行数据.</p>
<p>意向共享锁(IS):</p>
<p>意向排它锁(IX):</p>
<p>读取操作,使用共享锁.对于update操作,采用排它锁.</p>
<h3 id="锁获取"><a href="#锁获取" class="headerlink" title="锁获取"></a>锁获取</h3><hr>
<p>事物获取共享锁的条件:该行不存在排它锁.(可以存在共享锁)</p>
<p>事物获取排它锁的条件:该行没有共享锁,也没有排它锁.</p>
<p>S锁获取流程 : 是否有X锁,如果有.则需要等待X锁释放后加S锁.<br>X锁获取流程 : 是否存在X/S锁,如果有,则等待释放,然后加X锁.</p>
<h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读."></a>一致性非锁定读.</h3><hr>
<p>InnoDB 默认的读取操作,采用的是一致性非锁定读.也就是说,在读取数据时,不考虑当前数据是否被加锁.如果该行被锁定,则返回该行历史版本的最新一个版本.否则返回该行数据.一致性非锁定读,极大提升数据库的并发读的性能.</p>
<h3 id="共享锁读数据"><a href="#共享锁读数据" class="headerlink" title="共享锁读数据"></a>共享锁读数据</h3><hr>
<p>一致性非锁定读性能极大提升,但是某些时候.需要数据的完整性,而不是获取历史快照.是希望取到最新的数据.这时候,就需要采用共享锁了.</p>
<p>操作:<br>SELECT * FROM TABLE WHERE ID = 1 FOR UPDATE 给该行加上一个X锁.</p>
<p>SELECT * FROM TABLE WHERE id = 1 LOCK IN SHARE MODE 给该行加上一个S锁.</p>
<p>特别注意:加锁需要在事物之中,事物提交.锁释放.</p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;数据库锁,是为了支持对共享资源进行并发访问,保持数据一致性,完整性的一个特性.&lt;br&gt;与程序锁的概念类似.&lt;/p&gt;
&lt;h3 id=
    
    </summary>
    
      <category term="mysql lock" scheme="https://lmxy1990.github.io/categories/mysql-lock/"/>
    
    
      <category term="数据库锁" scheme="https://lmxy1990.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>SQL Group By Order By </title>
    <link href="https://lmxy1990.github.io/2017/08/25/SQL-Group-By-Order-By/"/>
    <id>https://lmxy1990.github.io/2017/08/25/SQL-Group-By-Order-By/</id>
    <published>2017-08-25T10:31:49.000Z</published>
    <updated>2017-09-12T07:37:35.834Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mysql-Group-By-灵活应用"><a href="#Mysql-Group-By-灵活应用" class="headerlink" title="Mysql Group  By 灵活应用"></a>Mysql Group  By 灵活应用</h3><ol>
<li>场景<br>有赛事球员表 记为race_player<br>赛事表 race<br>球员表 player<br>现在需要查询 ,每个球员未开赛,最近一场的赛事球员数据.</li>
</ol>
<hr>
<ol>
<li>分析<br>条件 :未开赛<br>聚合纬度 :球员<br>聚合选取条件:未开赛且比赛时间最小</li>
</ol>
<hr>
<ol>
<li>探究<br>确定 赛事球员的幂等是赛事id,球员id.<br>那么,在选取赛事球员对象的时候,就需要构造成这样的参数对.<br>那么,首先应该先查出这样的参数对.<br>代码:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select min(r2.match_time) t,player_id from race_player r1 </span><br><span class="line">        left join race r2 on r1.race_id = r2.id </span><br><span class="line">        where r2.race_status = 1</span><br><span class="line">        group by r1.player_id</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这里查出球员id,对应的最小比赛时间. 也就是相当于赛事id(在做一层关联).<br>这里使用赛事球员关联赛事,聚合球员.取得球员对应的最小值.因为这里只需要走一层关联.<br>如果采用赛事 -&gt; 球队 -&gt; 球员 去查这个幂等对.会多走一层关联.<br>选取好这个幂等对,首先需要转化为赛事id.所以这里还需要在关联赛事,用于获取赛事id.<br>代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT rp.* FROM race_player rp</span><br><span class="line">LEFT JOIN player tp ON rp.player_id = tp.id</span><br><span class="line">LEFT JOIN race r ON rp.race_id = r.id</span><br><span class="line">LEFT JOIN (</span><br><span class="line">    select min(r2.match_time) t,player_id from race_player r1 </span><br><span class="line">    left join race r2 on r1.race_id = r2.id </span><br><span class="line">    where r2.race_status = 1 //赛事条件</span><br><span class="line">    group by r1.player_id </span><br><span class="line">) r3 on r3.t = r.match_time and r3.player_id = rp.player_id</span><br><span class="line">WHERE  </span><br><span class="line">//其他条件</span><br><span class="line">ISNULL(rp.id) = FALSE</span><br><span class="line">AND ISNULL(tp.id) = FALSE</span><br><span class="line">AND ISNULL(r.id) = FALSE ;</span><br></pre></td></tr></table></figure></p>
<p>这样,有序列的group by 就完成了.</p>
<p>group by 大多数情况下.希望以后这个函数会优化成group by可以先order by<br>再group by选取指定行.而不是只能采用聚合函数.那面对这样的问题,就很简单了.</p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Mysql-Group-By-灵活应用&quot;&gt;&lt;a href=&quot;#Mysql-Group-By-灵活应用&quot; class=&quot;headerlink&quot; title=&quot;Mysql Group  By 灵活应用&quot;&gt;&lt;/a&gt;Mysql Group  By 灵活应用&lt;/h3&gt;&lt;ol
    
    </summary>
    
      <category term="Mysql SQL GroupBy" scheme="https://lmxy1990.github.io/categories/Mysql-SQL-GroupBy/"/>
    
    
  </entry>
  
  <entry>
    <title>QuartZ Cron表达式</title>
    <link href="https://lmxy1990.github.io/2017/08/14/%20QuartZ%20Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://lmxy1990.github.io/2017/08/14/ QuartZ Cron表达式/</id>
    <published>2017-08-14T07:56:54.000Z</published>
    <updated>2017-08-14T09:33:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*/5 * * * * ?  每隔5秒执行一次</span><br><span class="line">0 */1 * * * ?  每隔1分钟执行一次</span><br><span class="line">0 0 23 * * ?  每天23点执行一次</span><br><span class="line">0 0 1 * * ?  每天凌晨1点执行一次：</span><br><span class="line">0 0 1 1 * ?  每月1号凌晨1点执行一次</span><br><span class="line">0 0 23 L * ?  每月最后一天23点执行一次</span><br><span class="line">0 0 1 ? * L  每周星期天凌晨1点实行一次</span><br><span class="line">0 26,29,33 * * * ?  在26分、29分、33分执行一次</span><br><span class="line">0 0 0,13,18,21 * * ? 每天的0点、13点、18点、21点都执行一次</span><br><span class="line"></span><br><span class="line">作者：阳春是你</span><br><span class="line">链接：http://www.jianshu.com/p/f03b1497122a</span><br><span class="line">來源：简书</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 对象判断工具类</title>
    <link href="https://lmxy1990.github.io/2017/08/09/Java-%E5%AF%B9%E8%B1%A1%E5%88%A4%E6%96%AD%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>https://lmxy1990.github.io/2017/08/09/Java-对象判断工具类/</id>
    <published>2017-08-09T05:03:11.000Z</published>
    <updated>2017-08-14T09:35:35.966Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用于判断对象是否相等-支持Java基本类型-包装类"><a href="#用于判断对象是否相等-支持Java基本类型-包装类" class="headerlink" title="用于判断对象是否相等,支持Java基本类型,包装类."></a>用于判断对象是否相等,支持Java基本类型,包装类.</h3><p>需要引用的jar包.谷歌工具类,apache工具类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**</span><br><span class="line"> * 对象比较工具类</span><br><span class="line"> * 基本类型/Java自带类型使用Apache的比较工具类.</span><br><span class="line"> * 自定义对象采用反射递归比较.集合类采用循环递归比较</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * </span><br><span class="line"> * Date: 2017/8/9</span><br><span class="line"> */</span><br><span class="line">public class EqualObjectUtils implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 602163719206844077L;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 对象比较工具类</span><br><span class="line">     *</span><br><span class="line">     * @param ob1               比较对象1</span><br><span class="line">     * @param ob2               比较对象2</span><br><span class="line">     * @param ignoreProperNames 忽略属性名List</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean deepEquals(Object ob1, Object ob2, List&lt;String&gt; ignoreProperNames) &#123;</span><br><span class="line">        //对象空值判断</span><br><span class="line">        if (ob1 == ob2) return true;</span><br><span class="line">        if (ob1 == null || ob2 == null) return false;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Boolean&gt; jugMap = new HashMap&lt;&gt;();</span><br><span class="line">        if (CollectionUtils.isNotEmpty(ignoreProperNames)) &#123;</span><br><span class="line">            ignoreProperNames.stream().filter(StringUtils::isNotBlank).forEach(v -&gt; jugMap.put(v, true));</span><br><span class="line">        &#125;</span><br><span class="line">        return deepEquals(ob1, ob2, jugMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 比较</span><br><span class="line">     *</span><br><span class="line">     * @param ob1</span><br><span class="line">     * @param ob2</span><br><span class="line">     * @param jugMap</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static boolean deepEquals(Object ob1, Object ob2, final Map&lt;String, Boolean&gt; jugMap) &#123;</span><br><span class="line">        //对象空值判断</span><br><span class="line">        if (ob1 == ob2) return true;</span><br><span class="line">        if (ob1 == null || ob2 == null) return false;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = ob1.getClass();</span><br><span class="line">        Class&lt;?&gt; bClass = ob2.getClass();</span><br><span class="line">        //类型是否一致</span><br><span class="line">        if (!Objects.equals(ob1.getClass(), ob2.getClass())) return false;</span><br><span class="line">        //是否是集合类</span><br><span class="line">        if (isCollection(ob1) || isCollection(ob2)) &#123;</span><br><span class="line">            Collection&lt;Object&gt; co1 = (Collection&lt;Object&gt;) ob1;</span><br><span class="line">            Collection&lt;Object&gt; co2 = (Collection&lt;Object&gt;) ob2;</span><br><span class="line">            boolean rs = deepCollectionsEquals(co1, co2, jugMap);</span><br><span class="line">            if (!rs) return false;</span><br><span class="line">        &#125; else if (isJavaClass(aClass) || isJavaClass(bClass)) &#123;//Java自带对象处理(目前包名已Java开头的采用此方法.)</span><br><span class="line">            return EqualsBuilder.reflectionEquals(ob1, ob2, new ArrayList&lt;&gt;(jugMap.keySet()));</span><br><span class="line">        &#125; else &#123;//自定义对象处理</span><br><span class="line">            //自定义对象</span><br><span class="line">            Field[] fields1 = aClass.getDeclaredFields();</span><br><span class="line">            Field[] fields2 = bClass.getDeclaredFields();</span><br><span class="line">            if (fields1 == fields2) return true;</span><br><span class="line">            if (fields1 == null || fields2 == null) return false;</span><br><span class="line">            if (fields1.length != fields2.length) return false;</span><br><span class="line">            Map&lt;String, Field&gt; fieldMap1 = new HashMap&lt;&gt;();</span><br><span class="line">            Map&lt;String, Field&gt; fieldMap2 = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; fields1.length; i++) &#123;</span><br><span class="line">                Field field1 = fields1[i];</span><br><span class="line">                Field field2 = fields2[i];</span><br><span class="line">                //过滤指定属性</span><br><span class="line">                Boolean aBoolean = jugMap.get(field1.getName());</span><br><span class="line">                if (aBoolean != null &amp;&amp; aBoolean) continue;</span><br><span class="line">                if (&quot;serialVersionUID&quot;.equals(field1.getName())) continue;//序列化忽略</span><br><span class="line"></span><br><span class="line">                field1.setAccessible(true);</span><br><span class="line">                field2.setAccessible(true);</span><br><span class="line">                fieldMap1.put(field1.getName(), field1);</span><br><span class="line">                fieldMap2.put(field2.getName(), field1);</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;Map.Entry&lt;String, Field&gt;&gt; entrySet = fieldMap1.entrySet();</span><br><span class="line">            for (Iterator&lt;Map.Entry&lt;String, Field&gt;&gt; iterator = entrySet.iterator(); iterator.hasNext(); ) &#123;//每个子属性判断</span><br><span class="line">                Map.Entry&lt;String, Field&gt; next = iterator.next();</span><br><span class="line">                String key = next.getKey();</span><br><span class="line">                Field field1 = next.getValue();</span><br><span class="line">                Field field2 = fieldMap2.get(key);</span><br><span class="line">                Class&lt;?&gt; type1 = field1.getType();</span><br><span class="line">                Class&lt;?&gt; type2 = field2.getType();</span><br><span class="line">                //类型是否一致</span><br><span class="line">                if (!Objects.equals(type1, type2)) return false;</span><br><span class="line">                Object o1 = null;</span><br><span class="line">                Object o2 = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    o1 = field1.get(ob1);</span><br><span class="line">                    o2 = field2.get(ob2);</span><br><span class="line">                &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                //对象空值判断</span><br><span class="line">                if (o1 == o2) continue;</span><br><span class="line">                if (o1 == null || o2 == null) return false;</span><br><span class="line">                //是否是集合类</span><br><span class="line">                if (isCollection(o1) || isCollection(o2)) &#123;</span><br><span class="line">                    Collection&lt;Object&gt; co1 = (Collection&lt;Object&gt;) o1;</span><br><span class="line">                    Collection&lt;Object&gt; co2 = (Collection&lt;Object&gt;) o2;</span><br><span class="line">                    boolean rs = deepCollectionsEquals(co1, co2, jugMap);</span><br><span class="line">                    if (!rs) return false;</span><br><span class="line">                &#125; else if (isJavaClass(field1.getType()) || isJavaClass(field1.getType())) &#123;</span><br><span class="line">                    boolean equals = EqualsBuilder.reflectionEquals(o1, o2, new ArrayList&lt;&gt;(jugMap.keySet()));</span><br><span class="line">                    if (!equals) return false;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    boolean equals = deepEquals(o1, o2, jugMap);</span><br><span class="line">                    if (!equals) return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否是Java提供的数据类型.可以适当扩展其他类型.只要支持Equal方法的类型都可以添加进来.对工具类没影响</span><br><span class="line">     *</span><br><span class="line">     * @param _class</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static boolean isJavaClass(Class _class) &#123;</span><br><span class="line">        //基本类型</span><br><span class="line">        if (_class.isPrimitive()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //包装类型</span><br><span class="line">        if (_class.getPackage().getName().startsWith(&quot;java.&quot;)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        //自定义类型</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 是否是集合类</span><br><span class="line">     *</span><br><span class="line">     * @param o</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static boolean isCollection(Object o) &#123;</span><br><span class="line">        if (o instanceof Collection) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 集合类比较</span><br><span class="line">     *</span><br><span class="line">     * @param collection1</span><br><span class="line">     * @param collection2</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static boolean deepCollectionsEquals(Collection&lt;Object&gt; collection1, Collection&lt;Object&gt; collection2, final Map&lt;String, Boolean&gt; jugMap) &#123;</span><br><span class="line">        if (collection1 == collection2) return true;</span><br><span class="line">        if (collection1 == null || collection2 == null) return false;</span><br><span class="line">        if (collection1.size() != collection2.size()) return false;</span><br><span class="line">        for (Object o1 : collection1) &#123;</span><br><span class="line">            boolean rs = false;</span><br><span class="line">            for (Object o2 : collection2) &#123;</span><br><span class="line">                rs = deepEquals(o1, o2, jugMap);</span><br><span class="line">                if (rs) &#123;</span><br><span class="line">                    rs = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!rs) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GameRoomDTO room1 = new GameRoomDTO();</span><br><span class="line">        GameRoomDTO room2 = new GameRoomDTO();</span><br><span class="line"></span><br><span class="line">        room1.setGameRoomId(1L);</span><br><span class="line">        room2.setGameRoomId(1L);</span><br><span class="line"></span><br><span class="line">        room1.setRoomName(&quot;房间1&quot;);</span><br><span class="line">        room2.setRoomName(&quot;房间1&quot;);</span><br><span class="line"></span><br><span class="line">        Member member1 = new Member();</span><br><span class="line">        Member member2 = new Member();</span><br><span class="line"></span><br><span class="line">        member1.setNickName(&quot;小王&quot;);</span><br><span class="line">        member2.setNickName(&quot;小李&quot;);</span><br><span class="line"></span><br><span class="line">        room1.setMemberList(Lists.newArrayList(member2,member1));</span><br><span class="line">        room2.setMemberList(Lists.newArrayList(member1,member2));</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ignoreProps = Lists.newArrayList(&quot;nickName&quot;, &quot;createTime&quot;, &quot;updateTime&quot;, &quot;lastLoginTime&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(deepEquals(room1,room2,ignoreProps));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;用于判断对象是否相等-支持Java基本类型-包装类&quot;&gt;&lt;a href=&quot;#用于判断对象是否相等-支持Java基本类型-包装类&quot; class=&quot;headerlink&quot; title=&quot;用于判断对象是否相等,支持Java基本类型,包装类.&quot;&gt;&lt;/a&gt;用于判断对象是否相等
    
    </summary>
    
    
      <category term="工具类" scheme="https://lmxy1990.github.io/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java 编程规范</title>
    <link href="https://lmxy1990.github.io/2017/07/04/Java-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <id>https://lmxy1990.github.io/2017/07/04/Java-编程规范/</id>
    <published>2017-07-04T06:36:39.000Z</published>
    <updated>2017-08-07T12:12:56.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h3><hr>
<ol>
<li><p>代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</p>
</li>
<li><p>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚.</p>
</li>
<li><p>POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。</p>
</li>
<li><p>接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁.</p>
</li>
<li><p>不允许任何魔法值（即未经定义的常量）直接出现在代码中。</p>
</li>
<li><p>所有的覆写方法，必须加@Override 注解。 </p>
</li>
<li><p>构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。 </p>
</li>
<li><p>setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在 getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。</p>
</li>
<li><p>循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。</p>
</li>
<li><p>对于Map,只要重写 equals，就必须重写 hashCode。 </p>
</li>
<li><p>如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。</p>
</li>
<li><p>ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常.</p>
</li>
<li><p>使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全 一样的数组，大小就是 list.size()。</p>
</li>
<li><p>使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方 法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。</p>
</li>
<li><p>泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方 法，而&lt;? super T&gt;不能使用 get 方法，做为接口调用赋值时易出错。</p>
</li>
</ol>
<ul>
<li>说明：扩展说一下 PECS(Producer Extends Consumer Super)原则：1）频繁往外读取内容 的，适合用上界 Extends。2）经常往里插入的，适合用下界 Super。</li>
</ul>
<ol>
<li><p>不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。 </p>
</li>
<li><p>集合初始化时，指定集合初始值大小。</p>
</li>
<li><p>使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。</p>
</li>
<li><p>获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</p>
</li>
<li><p>SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。</p>
</li>
<li><p>高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能 锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</p>
</li>
<li><p>并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加 锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。 说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次 数不得小于 3 次。</p>
</li>
<li><p>子线程抛出异常堆栈，不能在主线程 try-catch 到。</p>
</li>
<li><p>避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一<br>seed 导致的性能下降。</p>
</li>
<li><p>volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题， 但是如果多写，同样无法解决线程安全问题。</p>
</li>
<li><p>HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在<br>开发过程中可以使用其它数据结构或加锁来规避此风险。</p>
</li>
<li><p>表达异常的分支时，少用 if-else 方式，这种方式可以改写成：if return ;</p>
</li>
<li><p>在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。不要在方法体内定义：Pattern pattern = Pattern.compile(规则); </p>
</li>
<li><p>后台输送给页面的变量必须加$!{var}.如果 var=null 或者不存在，那么${var}会直接显示在页面上。</p>
</li>
</ol>
<p>29.注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够 取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后 取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</p>
<ol>
<li><p>获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime(); </p>
</li>
<li><p>异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。</p>
</li>
<li><p>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请 将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的 内容。 </p>
</li>
<li><p>不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。</p>
</li>
<li><p>应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架<br>SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p>
</li>
<li><p>异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过 关键字 throws 往上抛出。</p>
</li>
</ol>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><hr>
<ol>
<li><p>任何字段如果为非负数，必须是 unsigned。</p>
</li>
<li><p>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只 出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p>
</li>
<li><p>表名不使用复数名词。</p>
</li>
<li><p>禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p>
</li>
<li><p>主键索引名为 pk<em>字段名；唯一索引名为 uk</em>字段名；普通索引名则为 idx_字段名。</p>
</li>
<li><p>小数类型为 decimal，禁止使用 float 和 double。 </p>
</li>
<li><p>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。</p>
</li>
<li><p>表的命名最好是加上“业务名称_表的作用”。</p>
</li>
<li><p>业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</p>
</li>
<li><p>超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询 时，保证被关联的字段需要有索引。</p>
</li>
<li><p>页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p>
</li>
<li><p>如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合 索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort的情况，影响查询性能。</p>
</li>
<li><p>建组合索引的时候，区分度最高的在最左边。 </p>
</li>
<li><p>防止因字段类型不同造成的隐式转换，导致索引失效。</p>
</li>
<li><p>不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的 标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</p>
</li>
<li><p>count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</p>
</li>
<li><p>当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。</p>
</li>
<li><p>禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 </p>
</li>
<li><p>in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控 制在 1000 个之内。</p>
</li>
<li><p>POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行 字段与属性之间的映射。</p>
</li>
<li><p>sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</p>
</li>
<li><p>@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需 要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p>
</li>
</ol>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;编程规约&quot;&gt;&lt;a href=&quot;#编程规约&quot; class=&quot;headerlink&quot; title=&quot;编程规约&quot;&gt;&lt;/a&gt;编程规约&lt;/h3&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。&lt;/p&gt;
&lt;/li&gt;
&lt;
    
    </summary>
    
      <category term="Java 编程规范" scheme="https://lmxy1990.github.io/categories/Java-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 自定义线程池</title>
    <link href="https://lmxy1990.github.io/2017/06/28/Java-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://lmxy1990.github.io/2017/06/28/Java-自定义线程池/</id>
    <published>2017-06-28T07:49:21.000Z</published>
    <updated>2017-06-28T08:00:27.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义线程池的逻辑"><a href="#自定义线程池的逻辑" class="headerlink" title="自定义线程池的逻辑:"></a>自定义线程池的逻辑:</h2><p>指定核心线程数,最大线程数,线程执行的最长时间,线程指定最长时间的单位,线程执行任务的缓存队列,线程工厂.<br>代码:</p>
<p>自定义线程工厂:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MyThreadFactory implements ThreadFactory &#123;</span><br><span class="line"></span><br><span class="line">    //线程优先级</span><br><span class="line">    private int priority = 5;</span><br><span class="line">    //是否是守护线程</span><br><span class="line">    private boolean daemon = false;</span><br><span class="line">    private String name = &quot;自定义线程&quot;;</span><br><span class="line">    private ClassLoader classLoader;</span><br><span class="line">    private UncaughtExceptionHandler uncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        Thread thread = new Thread(r);</span><br><span class="line">        thread.setName(this.name);</span><br><span class="line">        thread.setPriority(this.priority);</span><br><span class="line">        thread.setDaemon(this.daemon);</span><br><span class="line">        thread.setContextClassLoader(this.classLoader);</span><br><span class="line">        thread.setUncaughtExceptionHandler(this.uncaughtExceptionHandler);</span><br><span class="line">        System.out.println(&quot;通过线程工厂开始执行线程:&quot;+this.name);</span><br><span class="line">        return thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自定义线程池:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadPool &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //自定义缓冲队列</span><br><span class="line">        LinkedBlockingQueue&lt;Runnable&gt; linkedBlockingDeque = new LinkedBlockingQueue&lt;&gt;() ;</span><br><span class="line"></span><br><span class="line">        //自定义线程工厂</span><br><span class="line">        ThreadFactory threadFactory = new MyThreadFactory() ;</span><br><span class="line"></span><br><span class="line">        //自定义线程池</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5,10,10, TimeUnit.MINUTES,linkedBlockingDeque,threadFactory) ;</span><br><span class="line"></span><br><span class="line">        //通过程工厂执行任务</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j &lt;100000000; j++) &#123;</span><br><span class="line">                    int div = Math.floorDiv(++j, j * j);</span><br><span class="line">//                    System.out.println(div);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;线程启动&quot;) ;</span><br><span class="line">            &#125;);</span><br><span class="line">            int activeCount = threadPoolExecutor.getActiveCount();</span><br><span class="line">            System.out.println(&quot;当前进行中的线程数:&quot; +activeCount);</span><br><span class="line">            System.out.println(&quot;当前队列中的缓存数:&quot; +linkedBlockingDeque.size());</span><br><span class="line">        &#125;</span><br><span class="line">        //关闭线程池</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行输出结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">通过线程工厂开始执行线程:自定义线程</span><br><span class="line">线程名:自定义线程</span><br><span class="line">当前进行中的线程数:1</span><br><span class="line">当前队列中的缓存数:0</span><br><span class="line">通过线程工厂开始执行线程:自定义线程</span><br><span class="line">线程名:自定义线程</span><br><span class="line">当前进行中的线程数:2</span><br><span class="line">当前队列中的缓存数:0</span><br><span class="line">通过线程工厂开始执行线程:自定义线程</span><br><span class="line">线程名:自定义线程</span><br><span class="line">当前进行中的线程数:3</span><br><span class="line">当前队列中的缓存数:0</span><br><span class="line">通过线程工厂开始执行线程:自定义线程</span><br><span class="line">线程名:自定义线程</span><br><span class="line">当前进行中的线程数:4</span><br><span class="line">当前队列中的缓存数:0</span><br><span class="line">通过线程工厂开始执行线程:自定义线程</span><br><span class="line">线程名:自定义线程</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:0</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:1</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:2</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:3</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:4</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:5</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:6</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:7</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:8</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:9</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:10</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:11</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:12</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:13</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:14</span><br><span class="line">当前进行中的线程数:5</span><br><span class="line">当前队列中的缓存数:15</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br><span class="line">线程启动</span><br></pre></td></tr></table></figure></p>
<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析:"></a>结果分析:</h2><ol>
<li><p>任务启动  -&gt; 线程工厂创建该线程  -&gt; 线程池判断当前线程执行数量  -&gt; 线程等待 -&gt; 加入缓冲队列.</p>
</li>
<li><p>任务启动  -&gt; 线程工厂创建该线程  -&gt; 线程池判断当前线程执行数量  -&gt; 线程执行 </p>
</li>
<li><p>线程池当前执行任务数少于最大任务数  -&gt; 缓冲队列FIFO 获取任务.</p>
</li>
</ol>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;自定义线程池的逻辑&quot;&gt;&lt;a href=&quot;#自定义线程池的逻辑&quot; class=&quot;headerlink&quot; title=&quot;自定义线程池的逻辑:&quot;&gt;&lt;/a&gt;自定义线程池的逻辑:&lt;/h2&gt;&lt;p&gt;指定核心线程数,最大线程数,线程执行的最长时间,线程指定最长时间的单位,线程执行
    
    </summary>
    
      <category term="线程池 Java" scheme="https://lmxy1990.github.io/categories/%E7%BA%BF%E7%A8%8B%E6%B1%A0-Java/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql 存储过程</title>
    <link href="https://lmxy1990.github.io/2017/06/28/MySql-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://lmxy1990.github.io/2017/06/28/MySql-存储过程/</id>
    <published>2017-06-28T06:25:03.000Z</published>
    <updated>2017-06-28T06:28:34.078Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;End&quot;&gt;&lt;a href=&quot;#End&quot; class=&quot;headerlink&quot; title=&quot;End&quot;&gt;&lt;/a&gt;&lt;center&gt;End&lt;/center&gt;&lt;/h2&gt;
    
    </summary>
    
      <category term="数据库 Mysql" scheme="https://lmxy1990.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql/"/>
    
    
      <category term="DB" scheme="https://lmxy1990.github.io/tags/DB/"/>
    
  </entry>
  
</feed>
