<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lmxy1990 &#39; Blog</title>
  <subtitle>love code, enjoy life .</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="https://lmxy1990.github.io/"/>
  <updated>2017-01-02T03:52:37.659Z</updated>
  <id>https://lmxy1990.github.io/</id>
  
  <author>
    <name>lmxy1990</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>去百度右侧推广方法</title>
    <link href="https://lmxy1990.github.io/2017/01/02/%E5%8E%BB%E7%99%BE%E5%BA%A6%E5%8F%B3%E4%BE%A7%E6%8E%A8%E5%B9%BF%E6%96%B9%E6%B3%95/"/>
    <id>https://lmxy1990.github.io/2017/01/02/去百度右侧推广方法/</id>
    <published>2017-01-02T03:19:12.000Z</published>
    <updated>2017-01-02T03:52:37.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="百度越来越恶心了…"><a href="#百度越来越恶心了…" class="headerlink" title="百度越来越恶心了…"></a>百度越来越恶心了…</h2><hr>
<h3 id="下面介绍一种简单的去百度推广方法-采用的是chrome浏览器"><a href="#下面介绍一种简单的去百度推广方法-采用的是chrome浏览器" class="headerlink" title="下面介绍一种简单的去百度推广方法,采用的是chrome浏览器."></a>下面介绍一种简单的去百度推广方法,采用的是chrome浏览器.</h3><hr>
<ol>
<li>安装adb去广告插件.<br><img src="/img/suggest/adb_plus.jpg" alt="添加adb_plus插件"></li>
<li>添加自定义规则.<br><img src="/img/suggest/add_rude.jpg" alt="添加自定义规则"></li>
<li>右侧推广去掉的结果<br><img src="/img/suggest/remove_result.jpg" alt="结果1"></li>
<li>但是还有搜索的推广<br><img src="/img/suggest/bad_ad.jpg" alt="左侧推广"></li>
<li>添加清除左侧推广规则<br><img src="/img/suggest/remove_result.jpg" alt="清除左侧推广"></li>
<li>全部结果<br><img src="/img/suggest/all_result.jpg" alt="结果"><br>7.规则:<ul>
<li><code>##div.opr-recommends-merge-panel</code></li>
<li><code>##div#con-ar</code></li>
<li><code>##div[style=&quot;display:block !important;visibility:visible !important&quot;]</code></li>
</ul>
</li>
</ol>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;百度越来越恶心了…&quot;&gt;&lt;a href=&quot;#百度越来越恶心了…&quot; class=&quot;headerlink&quot; title=&quot;百度越来越恶心了…&quot;&gt;&lt;/a&gt;百度越来越恶心了…&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;下面介绍一种简单的去百度推广方法-采用的是chrome浏览器&quot;&gt;
    
    </summary>
    
      <category term="小技巧" scheme="https://lmxy1990.github.io/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之观察者模式</title>
    <link href="https://lmxy1990.github.io/2016/12/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lmxy1990.github.io/2016/12/30/设计模式之观察者模式/</id>
    <published>2016-12-30T04:30:42.000Z</published>
    <updated>2016-12-30T05:33:12.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><hr>
<ul>
<li>观察者模式一般使用在订阅/推送功能下,数据提供方推送数据–&gt;数据接收方.其实在开发中该模式使用应该是很普遍的.例如站内信/信息中心/订阅都是用的是该设计模式.<br><br><ul>
<li>方式1:数据推送方—&gt;查询订购对象—&gt;推送给订购对象.</li>
<li>方式2:订购的对象 —&gt;查询订阅的数据—&gt;拉取需要的数据.<br><br></li>
</ul>
</li>
<li>本质上其实就是发送方与接收方的依赖隔离,也就是说数据发送方发送数据,<br>不是直接发送给订购的对象,而是先查询哪些订购了.然后统一发送出<br><br></li>
</ul>
<hr>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a><center>End</center></h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;观察者模式&quot;&gt;&lt;a href=&quot;#观察者模式&quot; class=&quot;headerlink&quot; title=&quot;观察者模式&quot;&gt;&lt;/a&gt;观察者模式&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;观察者模式一般使用在订阅/推送功能下,数据提供方推送数据–&amp;gt;数据接收方.其实在开发中该模
    
    </summary>
    
      <category term="设计模式" scheme="https://lmxy1990.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>java volatile 关键字</title>
    <link href="https://lmxy1990.github.io/2016/12/29/java-volatile-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://lmxy1990.github.io/2016/12/29/java-volatile-关键字/</id>
    <published>2016-12-29T12:56:42.000Z</published>
    <updated>2016-12-29T13:18:21.121Z</updated>
    
    <content type="html"><![CDATA[<p><br></p>
<h2 id="volatile关键字的使用"><a href="#volatile关键字的使用" class="headerlink" title="volatile关键字的使用"></a>volatile关键字的使用</h2><hr>
<ul>
<li>volatile关键字的作用是告诉编译器,该变量是易变的.不要将该变量的值存储在寄存器中,而是放在内存中(一般指的是静态也就是栈).</li>
<li>某些静态变量,如果使用频繁.可能会直接存放于寄存器中,以便加快计算的速度.但是,如果我们期望该值不应   该存在多个不一样的值时候,除了使用final定义为常量.还可以使用该关键字.</li>
<li>该关键字既可以避免一个变量出现多个值的可能,也可以避免常量的不可改变性.</li>
</ul>
<hr>
<p><br></p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点:"></a>注意点:</h3><ul>
<li>使用场景应该如下:<ul>
<li>多个线程中,该变量只能拥有一个对象.</li>
<li>该变量可能需要变化.即该变量需要动态创建/销毁.</li>
<li>它本身无法保证运行中只存在一个对象.它只是告诉jvm,<br>它的值需要从内存中去读取,而不是在寄存器(1级缓存/2级缓存/3级缓存)中获取该值.</li>
</ul>
</li>
<li>如果只是需要一个对象,使用final关键字即可.如果该对象使用不频繁,减少内存开销.可以使用该关键字,配合多线程的同步锁,可以实现单例.</li>
</ul>
<hr>
<center>End</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;h2 id=&quot;volatile关键字的使用&quot;&gt;&lt;a href=&quot;#volatile关键字的使用&quot; class=&quot;headerlink&quot; title=&quot;volatile关键字的使用&quot;&gt;&lt;/a&gt;volatile关键字的使用&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li
    
    </summary>
    
      <category term="java" scheme="https://lmxy1990.github.io/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式之策略模式</title>
    <link href="https://lmxy1990.github.io/2016/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://lmxy1990.github.io/2016/12/28/设计模式之策略模式/</id>
    <published>2016-12-28T12:31:12.000Z</published>
    <updated>2016-12-29T14:18:46.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><br></p>
<hr>
<ul>
<li>策略模式是用于解决面向对象中的抽象类与接口的局限性.即一般的对类别进行抽象,对行为进行抽象为接口.这种方式在代码复用上有一定的局限性.而策略模式可以提高代码的复用.</li>
<li><p>eg:<br><pre><br>//定义一个接口,用于在抽象类都能调用到.(里氏替换原则)<br>interface Speak{</pre></p>
<p>void doSpeak() ;<br>}<br>// 实现接口1,其他类只要功能一样都可以采用它.<br>class SpeakCn implements Speak{<br>@Override<br>public void doSpeak() {</p>
<pre><code>System.out.println(&quot;中文&quot;);
</code></pre><p>}<br>}<br>//实现接口2,其他类只要功能一样都可以采用它.<br>class SpeakEn implements Speak{<br>@Override<br>public void doSpeak() {</p>
<pre><code>System.out.println(&quot;English&quot;);
</code></pre><p>}<br>}<br>//抽象类 使用接口来实现.将具体实现放到子类来实现接口.<br>abstract class man{<br>Speak speak ;<br>void speak(){</p>
<pre><code>speak.doSpeak();
</code></pre><p>}<br>}<br>class CnMan extends man{<br>//初始化赋值父类接口的实现,也可以采用Spring的初始化加载实现.<br>public  CnMan() {</p>
<pre><code>speak = new SpeakCn() ;
</code></pre><p>}<br>}<br>//使用<br>class test{<br>public void main(String[] args) {</p>
<pre><code>new CnMan().speak();
</code></pre><p>}<br>}<br></p>
<center>End</center></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h2&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;策略模式是用于解决面向对象中的抽象类与接口的局限性.即一般的对类别进行抽象,对
    
    </summary>
    
      <category term="设计模式" scheme="https://lmxy1990.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdown 基础语法</title>
    <link href="https://lmxy1990.github.io/2016/12/28/Markdown-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://lmxy1990.github.io/2016/12/28/Markdown-基础语法/</id>
    <published>2016-12-28T08:06:14.000Z</published>
    <updated>2016-12-29T14:11:07.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="markdown基本语法"><a href="#markdown基本语法" class="headerlink" title="markdown基本语法."></a>markdown基本语法.</h2><h3 id="文字类"><a href="#文字类" class="headerlink" title="文字类"></a>文字类</h3><hr>
<ul>
<li>标题大小用<code>#</code>来标记,等同于html的<code>&lt;h1&gt;&lt;/h1&gt;</code>标签.</li>
<li>内容的强调使用<code>*</code>或<code>_</code> 来标记.</li>
</ul>
<ul>
<li>有序列表使用<code>数字.</code>来标记.</li>
</ul>
<ul>
<li>无序列表使用<code>* 或- 或+</code>来标记.</li>
</ul>
<ul>
<li>小代码使用2个`来标记.代码块使用6个`来标记.</li>
<li>如果需要显示单个代码,也可以使用\来标记该字符不被解析.</li>
<li>代码块一种更简便的方式是在开头使用一个tab+4个空格.</li>
</ul>
<ul>
<li>列表的嵌套使用tab+列表标记.</li>
</ul>
<ul>
<li>空行直接使用html的标记<code>&lt;br/&gt;</code><br><br></li>
</ul>
<h3 id="连接类"><a href="#连接类" class="headerlink" title="连接类"></a>连接类</h3><hr>
<ul>
<li>页面内的跳转.<ol>
<li>使用<code>&lt;span id =&quot;bijiao&quot;&gt;&lt;/span&gt;</code> 定义一个要跳转的地方.</li>
<li>使用<code>&lt;a href=&quot;#biaoqian&quot;&gt;跳&lt;/a&gt;</code>或者<code>[跳](#biaoqian)</code>来实现跳转.</li>
</ol>
</li>
<li>其他跳转.使用<code>&lt;a href=&quot;地址&quot;&gt;跳&lt;/a&gt;</code>或者<code>[跳](地址)</code>来实现跳转.</li>
</ul>
<h3 id="图片类"><a href="#图片类" class="headerlink" title="图片类"></a>图片类</h3><hr>
<ol>
<li>使用<code>&lt;img src=&quot;地址&quot;&gt;名称&lt;/img&gt;</code>或者<code>![名称](地址)</code>来实现.</li>
</ol>
<h3 id="音视频"><a href="#音视频" class="headerlink" title="音视频"></a>音视频</h3><hr>
<ol>
<li>声音:使用<code>&lt;audio src=&quot;地址&quot; autoplay=&quot;true&quot;&gt;声音&lt;/audio&gt;</code>来实现</li>
<li>视频:使用<code>&lt;video src=&quot;地址&quot; autoplay=&quot;true&quot;&gt;视频&lt;/video&gt;</code>来实现<br><br><br><br><h4 id="总结来说-mardown完全可以使用html标签来写-不过-html写起来麻烦-但是一些功能目前来说-markdown还不支持-所以只能采用html的标签来实现-来外-颜色样式的定义-好像也不可以-也只能用html-个人理解markdown只是html的一个框架-对html的一个封装"><a href="#总结来说-mardown完全可以使用html标签来写-不过-html写起来麻烦-但是一些功能目前来说-markdown还不支持-所以只能采用html的标签来实现-来外-颜色样式的定义-好像也不可以-也只能用html-个人理解markdown只是html的一个框架-对html的一个封装" class="headerlink" title="总结来说,mardown完全可以使用html标签来写.不过,html写起来麻烦.但是一些功能目前来说,markdown还不支持,所以只能采用html的标签来实现.来外,颜色样式的定义.好像也不可以.也只能用html.个人理解markdown只是html的一个框架.对html的一个封装."></a>总结来说,mardown完全可以使用html标签来写.不过,html写起来麻烦.但是一些功能目前来说,markdown还不支持,所以只能采用html的标签来实现.来外,颜色样式的定义.好像也不可以.也只能用html.个人理解markdown只是html的一个框架.对html的一个封装.</h4></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;markdown基本语法&quot;&gt;&lt;a href=&quot;#markdown基本语法&quot; class=&quot;headerlink&quot; title=&quot;markdown基本语法.&quot;&gt;&lt;/a&gt;markdown基本语法.&lt;/h2&gt;&lt;h3 id=&quot;文字类&quot;&gt;&lt;a href=&quot;#文字类&quot; cla
    
    </summary>
    
      <category term="markdown" scheme="https://lmxy1990.github.io/categories/markdown/"/>
    
    
      <category term="markdown" scheme="https://lmxy1990.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>git的使用</title>
    <link href="https://lmxy1990.github.io/2016/12/27/git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://lmxy1990.github.io/2016/12/27/git的使用/</id>
    <published>2016-12-27T06:58:27.000Z</published>
    <updated>2016-12-27T07:23:27.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git初次使用一般来说就5步"><a href="#Git初次使用一般来说就5步" class="headerlink" title="Git初次使用一般来说就5步."></a>Git初次使用一般来说就5步.</h2><ol>
<li><p>cd 你的目录  //进入你需要提交的目录.</p>
</li>
<li><p>git init //初始化.</p>
</li>
<li><p>git add * //添加需要提交的文件.</p>
</li>
<li><p>git commit -m “第一次提交”  //提交的说明.</p>
</li>
<li><p>git remote add origin <a href="https://github.com/lmxy1990/test.git" target="_blank" rel="external">https://github.com/lmxy1990/test.git</a> //添加远程仓库地址</p>
</li>
<li><p>git push -u origin master //提交 到主干</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Git初次使用一般来说就5步&quot;&gt;&lt;a href=&quot;#Git初次使用一般来说就5步&quot; class=&quot;headerlink&quot; title=&quot;Git初次使用一般来说就5步.&quot;&gt;&lt;/a&gt;Git初次使用一般来说就5步.&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;cd 你的目录  //
    
    </summary>
    
      <category term="Git初次使用" scheme="https://lmxy1990.github.io/categories/Git%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="git" scheme="https://lmxy1990.github.io/tags/git/"/>
    
  </entry>
  
</feed>
