<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[mysql日期处理函数]]></title>
      <url>%2F2017%2F01%2F23%2Fmysql%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[过滤指定日期 1.近1天123select * from table where to_days(column_time) = to_days(now());select * from table where date(column_time) = curdate(); 2.近7天1select * from table where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(column_time); 3.近一个月1select * from table where DATE_SUB(CURDATE(), INTERVAL 1 MONTH) &lt;= date(column_time); 筛选出需要的日期的值1.筛选出年月日1select DATA(column_time) from table ; 2.筛选出年月1select Extract(year_month FROM column_time) from table ; 3.筛选出年.1select Extract(year FROM column_time) from table ; 4.筛选出月1select Extract(month FROM column_time) from table ; 5.筛选出日1select Extract(day FROM column_time) from table ; 6.筛选出时分秒1select time(day FROM column_time) from table ; 比较日期1.间隔天数1SELECT match_date,create_time FROM table_name WHERE datediff(match_date,create_time) = 60 详见: 官方文档 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xshell故障]]></title>
      <url>%2F2017%2F01%2F23%2Fxshell%E6%95%85%E9%9A%9C%2F</url>
      <content type="text"><![CDATA[故障1,登录成功.会话断开. 这种原因google了很久,都没找到.后来才知道是因为窗口太大了.服务器那边可能不支持大屏显示吧.缩小窗口就可以了. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java内存模型]]></title>
      <url>%2F2017%2F01%2F22%2Fjava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[运行时的内存模型 java目前使用的虚拟机是HotSpot.运行时的内存模型可以简单分为:方法栈,堆,程序计数器,虚拟机栈,本地方法栈.其中堆与方法栈是所有线程共享的.虚拟机栈与本地方法栈,程序计数器是县城独享的.程序计数器,虚拟机栈的生命周期与线程的周期是一样的. 程序计数器 程序计数器可以见到那看作是当前线程的运行状态.进行指令分配的一小段内存块.它的功能是记录当前线程的一些状态,值.以便于线程的唤醒,启动.异常处理等线程功能都由它来完成. 虚拟机栈 虚拟机栈中保存的是局部变量,操作数栈,程序的出口信息.动态连接等.它的主要作用是存储线程执行的一些数据(线程内部数据). 本地方法栈 本地方法栈也是用来保存方法内的变量(局部变量),动态连接,出口数据等线程私有的数据.只是它对应的是本地方法(本地函数?),而虚拟机栈对应的是java的方法. 方法栈 方法栈是线程公有的.它主要保存所有类的信息,常量,静态变量.方法模型的基本信息.非静态成员变量也保存在此.所以成员变量需要考虑线程安全性的问题. 堆 java堆是内存中最大的一部分,几乎所有的对象实例都保存于此.GC回收最主要部分也是这里. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[windows下删除文件过深命令]]></title>
      <url>%2F2017%2F01%2F19%2Fwindows%E4%B8%8B%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E8%BF%87%E6%B7%B1%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[命令: robocopy windows的可靠文件复制.原理: 新建一个文件夹,然后使用可靠复制命令.将新建的正常文件夹覆盖需要删除的文件夹.示例: robocopy /MIR 正常文件夹 需要删除的文件夹. 查看命令所有参数:robocopy /? End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java多线程概念]]></title>
      <url>%2F2017%2F01%2F16%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[概述 多线程是线程切换,多线程中的线程安全指的是在统一资源中.多线程在读取与修改的时候.资源是否同步.对于属于线程的资源,则无需考虑多线程安全问题.因为该资源是该县城独占.不存在线程安全问题. 并发 并发与多线程是一个意思.并发描述侧重于业务.多线程描述侧重于编码机制. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[list,map,queue,dequeue区别]]></title>
      <url>%2F2017%2F01%2F16%2Flist-map-queue-dequeue%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[list list是最常用的集合类.这里需要注意的是arraylist是非线程同步的.如果资源共享时候,需要考虑同步的话可以使用vector类.也可以使用同步队列.arraylist是一局数组的动态扩充来实现的.如果超过长度,则会一次性扩充当前长度的1.5倍. map map也是集合中最为常用的集合类.hashMap,tableMap的区别是多线程时候,该资源是否同步.hashmap的底层实现是根据hashcode与next来进行判断.对于不同对象的相同hashcode,hashmap会在该节点产生一个链表.hashmap的put依托于重写equals方法.hashmap中的hashcode也是重新生成的.null可以作为key. hashcode的无符号右位移16位的次方((h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)).hashmap的的对象是Entry类型.所以equals时候,需比较hashcode与key对象的equals.来判断是否相等.然后执行是插入还哦是更新 队列 队列比较特殊,它是集合类.但是它比一般的集合类功能要多一点.对于非阻塞无界队列来说,它功能上与list来说是一样的.队列有一个特性是阻塞,它表示的意义是只容许插入指定的数据,如果是插满,则在put方法时候会一直处于等待插入状态,add方法会抛出异常.offer方法则会插入失败,但不会抛出异常.功能上来说,队列优于list,set. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[项目命令规范]]></title>
      <url>%2F2017%2F01%2F16%2F%E9%A1%B9%E7%9B%AE%E5%91%BD%E4%BB%A4%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[Alpha： Alpha是内部测试版,一般不向外部发布,会有很多Bug.除非你也是测试人员,否则不建议使用.是希腊字母的第一位,表示最初级的版本，alpha 就是α，beta 就是β ，alpha 版就是比beta还早的测试版，一般都是内部测试的版本。Beta: 该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一缺陷，需要经过多次测试来进一步消除。这个阶段的版本会一直加入新的功能。 RC：(Release Candidate) Candidate是候选人的意思，用在软件上就是候选版本。Release.Candidate.就是发行候选版本。和Beta版最大的差别在于Beta阶段会一直加入新的功能，但是到了RC版本，几乎就不会加入新的功能了，而主要着重于除错! RC版本是最终发放给用户的最接近正式版的版本，发行后改正bug就是正式版了，就是正式版之前的最后一个测试版。GA：（general availability） 比如：Apache Struts 2 GA这是Apache Struts 2首次发行稳定的版本，GA意味着GeneralAvailability，也就是官方开始推荐广泛使用了。Release: 该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(R)。数字 第一位表示主版本,一般是产品重大迭代.第二位表示小版本.一般表示小功能的增加.第三位表示修复版本.如果是4位数字的,那么最后一位代表bug修复/优化版本. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java编程的一些建议]]></title>
      <url>%2F2017%2F01%2F16%2Fjava%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[集合类 list方法的subList是返回视图上的子类.使用该方法之后,不能对其父类再进行一些操作.否则会有size的异常.subList还是不要使用的好,因为它没有产生新的对象. 排序的打乱是用自带的shuffle方法. 多线程对统一资源的操作时,使用vector或者hashtable.也可以使用同步队列. 集合对象可以采用谷歌的Guava包. 未完待续]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[altimu-designer常用快捷键]]></title>
      <url>%2F2017%2F01%2F11%2Faltimu-designer%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[原理图快捷键列表 p 放置器件 tab 在放置之前,设置器件的属性设置 space 器件90度旋转. x 器件X轴镜像 y 器件Y轴镜像 鼠标左键 放置器件 鼠标右键 取消放置 按住右键, 拖拽图纸 ctrl+滚轮 放大/缩小 ctrl+按住鼠标右键,滑动鼠标 以器件为中心缩放 ltium Designer14 PCB快捷键：旋转：Space；X轴镜像：X；Y轴镜像：Y；板层管理：L；栅格设置：G；单位进制切换：Q； 对齐-水平：A，D；对齐-垂直：A，I，I，Enter；对齐-顶部：A，T；对齐-底部：A，B；对齐-左侧：A，L；对齐-右侧：A，R； 设计-类设置：D，C;设计-板层管理：D，K；设计-规则：D，R；设计-规则向导：D，W；设计-拷贝ROOM格式：D，M，C；设计-放置ROOM：D，M，R；设计-根据选择对象定义板子形状：D，S，D；设计-编辑网络：D，N，N； 编辑-删除：E，D；编辑-切断轨迹：E，K；编辑-设定原点：E，O，S；编辑-复位原点：E，O，R； 移动-移动：M，M；移动-拖拽：M，D；移动-器件：M，C；移动-打断走线：M，B；移动-器件翻转板层：M，I； 网络-显示网络：N，S，N；网络-显示器件：N，S，O；网络-显示全部：N，S，A；网络-隐藏网络：N，H，N；网络-隐藏器件：N，H，O；网络-隐藏全部：N，H，A； 放置-坐标：P，O；放置-焊盘：P，P；放置-字符：P，S；放置-过孔：P，V；放置-多边形：P，R；放置-填充：P，F；放置-敷铜：P，G；放置-线性尺寸：P，D，L；放置-走线：P，T；放置-差分对布线：P，I；放置-多根布线：P，M，Enter； 选择-全选：S，A；选择-线选：S，L；选择-区域（内部）：S，I；选择-区域（外部）：S，O； 工具-交叉探测对象：T，C；( Ctrl:跳转到目标文件) 工具-泪滴选项：T，E；工具-设计规则检查：T，D；工具-复位错误标志：T，M；工具-从选择元素创建板剪切：T，V，B工具-网络等长调节：T，R； 取消布线-全部：U，A；取消布线-网络：U，N；取消布线-连接：U，C；取消布线-器件：U，O；取消布线-ROOM：U，R； 查看-合适区域：V，A；查看-翻转板子：V，B；查看-适合文件：V，D；查看-合适板子：V，F；查看-合适图纸：V，H； 测距：Ctrl M； 清除蒙板： Shift Ｃ；查找相似对象： Shift F;显示走线长度： Shift G；单层显示： Shift S；改变走线模式：Shift Space； 切换二维显示：2(主键盘)；切换三维显示：3(主键盘)；顶层底层切换：*(小键盘 )；板层切换： /-(小键盘)；智能走线：在放置走线状态， Ctrl； 移动多边形顶点：右键，Y，V；器件联合：右键，U； 增大弧度：长按 &gt;；减小弧度：长按 &lt;；减小多根交互式布线间距：长按Shift B；增加多根交互式布线间距：长按Shift B； 3D模式下：0°旋转：0（主键盘）；90°旋转：9（主键盘）； 布等长线状态下：增加蛇形线拐角弧度：1；减少蛇形线拐角弧度：2；增加蛇形线宽度：3；减少蛇形线宽度：4；增加蛇形线拐角振幅：。；减少蛇形线拐角振幅：，； Altium Designer14 SCH快捷键： 对齐-水平：A，D；对齐-垂直：A，I；对齐-顶部：A，T；对齐-底部：A，B；对齐-左侧：A，L；对齐-右侧：A，R； 打破线：E，W； 放置总线：P，B；放置总线入库：P，U；放置节点：P，J；放置网络标号：P，N；放置端口：P，R；放置字符串：P，T；放置走线：P，W；放置线：P，D，L；放置差分对标示：P，V，F；放置Blanket：P，V，L；放置网络类：P，V，C； 从原理图选择PCB器件： T，S；封装管理器：T，G；强制标注所有器件：T，N； 查看-合适区域：V，A；查看-适合文件：V，D；查看-合适板子：V，F； 清除蒙板： Shift Ｃ；改变走线模式：Shift Space End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的lambda表达式]]></title>
      <url>%2F2017%2F01%2F09%2Fjava%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[介绍lambda 表达式是1.8的特性.原预计是1.7的需求,但是因为竞争,收购,资金等等原因到1.8才出现.另外,java的lambda表达式与.net的有一定区别的.两者实现的方式不一样.java的lambda表达式是建立在匿名类(接口)之下延伸的.而.net是使用委托这一特性实现的.增加该特性的话,代码会简洁一些. 使用方式无论是java还是.net使用方式都差不多.就是() -&gt; “return data” .入参 -&gt; 回参. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java消息队列]]></title>
      <url>%2F2017%2F01%2F07%2Fjava%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%2F</url>
      <content type="text"><![CDATA[Queue队列的所有已知实现类: 该接口继承Iterable,Collection接口.除了继承的接口的方法外,它有自身操作队列的一些公有的方法:offer/poll/peek. 队列里面的插入:offer,取出顶层元素:poll,查询顶层元素:peek/element.不建议使用集合类的方法,add,remove,addAll.因为操作失败是报异常,需要去捕获异常然后调用线程等待之类的方法. 另外,队列的传入值一般不建议插入null.子接口: BlockingQueue 不容许插入null对象,如果取出顶层元素失败(执行poll),则返回null.可能是有边界的,这种情况下,该队列如果制定边界.那么超过边界的对象不再被接受.如果没指名边界,那么边界就是整行的最大值.不支持close/shutdown这样的方法,线程安全. 是BlockingDeque,Transfer的父接口.一般该实现类都有边界.因为是阻塞的.集合类方法:add/remove/addAll等,在操作失败抛出异常.队列方法:offer/poll/peek,在操作失败返回null或者false.队列方法put/take/操作失败一直重试.队列方法:put(e,time,unit),重试最大时间,如果还是失败就退出. Deque, 双端队列接口,继承自Queue.子接口BlockingDeque.该接口的实现类一般都是无边界的队列(大小自由).首端元素的添加/取出/查询:offerFrist/pollFrist/peekFrist.尾端为Last.也可以使用Queue接口的方法:poll,peek.操作首端元素.这里的offer方法操作的是尾端元素.从尾端添加.首端添加是Stack的push方法.或者offerFrist方法.使用Stack方法:push,pop,peek操作首端元素. BlockingDeque, 继承自BlockingQueue与Deque接口.具有二者的共性.双端阻塞队列,所以操作方法是addFrist/addLast,removeFrist/removeLast…这样的方法.操作失败特性与BrokingQueue一样. TransferQueue, 继承自BlockingQueue接口.使用场景:生产者–&gt;消费者.生产这产生对象,添加到转移队列,消费者从转移队列取出对象.一般该接口的实现类是有边界的.这种情况下,如果消费者一直没有去走元素,那么该生产这就不能在队列满的情况下继续添加.必须要等到队列空出位置.getWaitingConsumerCount()方法:查询消费者的数量.hasWaitConsumer() :是否有消费者正在等待消费.transfer(E e) :转移对象给消费者.如果没有消费者,则一直等待.tryTransfer(E e) :立即转移给消费者.没有返回false.tryTransfer(E e,long time,timeUnit unit) :尝试转移,等待最大时间之后就不再等待.其他方法与其父接口一致.子实现类: AbstractQueue, 抽象类,所有子队列的顶层.实现Queue的接口.所以Queue接口的方法都具有.下面的类都是该类的子类.下面不再重复说明. ArrayBlockingQueue, 基于数组实现的阻塞队列.拥有边界.实现BlockingQueue接口与序列化接口. ArrayDeque, 基于数组的双端队列.无界,初始化未指定大小,默认为16容量.实现Deque接口,克隆接口,序列化接口.关于克隆接口:Cloneable ConcurrentLinkedDeque, 基于链表实现的没有边界的同步双端队列.适用线程安全的多线程并发插入/移除/访问等操作.因为是双端操作,所以集合类的方法遍历可能结果不准确.不容许插入null值. ConcurrentLinkedQueue, 基于链表实现的没边界的同步队列.与之前的一样,也是线程安全的.同样不容许插入null.这一条之后不再重复.一般队列都不容许插入null. DelayQueue, 无界延迟队列.只有到达时间的对象才能被消费.实现BlockingQueue接口.传入参数必须是实现Delayed接口的对象方法多了个size/take.. LinkedBlockingDeque, 基于链表的双端队列.有界,如果初始化未指定容量大小,则默认为整型最大值.实现BlcokingDeque与序列化接口.方法定义与BlockingQueue一致性. LinkedBlockingQueue, 基于链表的阻塞队列,如果初始化时候没有制定大小.默认为整型最大值.遵循FIFO,连接的节点在插入新的对象时候动态创建,知道超出容量限制. LinkedList, 实现List, Deque, Cloneable, Serializable,接口.实现模式是双端队列,使用两条链表操作.该队列是非同步的.官方给出同步的处理方式:Collections.synchronizedList(new LinkedList(…) LinkedTransferQueue, 基于链表实现的传输队列.无界实现TransferQueue与序列化接口.跟大部分非同步队列一样,由于多线程异步的原因,size方法取到的值不能作为准确的判断队列的数量.建议使用队列的方法取出. PriorityQueue, 指定顺序的队列(优先级),无界.继承自AbstractQueue抽象类.传入对象需要实现排序接口 Comparator 来排序.初始化未指定参数,默认容量为11,排序方式为自然排序: natural ordering. PriorityBlockingQueue, 优先阻塞队列,无界.实现阻塞接口与序列化接口.与阻塞队列相比,它多了一个排序的功能. SynchronousQueue 同步队列,无界.实现BlockingQueue接口与序列化接口.可以指定是否FIFO,初始化默认是非公平队列.即不保证先插入的元素一定最先取出.了解队列特性,建议先了解接口特性.例外的就只有同步队列/排序队列(姑且这么翻译)不是实现接口而产生的功能,其他大体都是接口定义的特性. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[idea快捷键]]></title>
      <url>%2F2017%2F01%2F07%2Fidea%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[最重要的两个快捷键 ctrl+shfit+a 查询所有命令快捷键ctrl+j 查询所有语句快捷键(eg:sout等于输出语句) 编辑快捷键 Alt+Insert get/set/constructor/overrider..Alt+Enter 编译器建议.代码提示建议修改为Alt+/Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）Shift+F6，重构 - 重命名Ctrl+O，覆写父类方法OverriderAlt+Insert 自动生成Get/Set方法.Ctrl+Alt+T 自动生成try/catch方法.Ctrl+Shift+Up/Down，向上/下移动语句Ctrl+D 复制当前行Ctrl+Y 删除当前行Ctrl+X，剪切行Ctrl+V 粘贴Ctrl+Alt+L 自动格式化代码块.Ctrl+Alt+I 自动缩进排版Ctrl+Alt+O 删除多余的导入类.Ctrl+Enter 自动导入需要的Jar包.Ctrl+”+/-“，当前方法展开、折叠Ctrl+Shift+”+/-“，全部展开、折叠Ctrl+Shift+U，大小写转化 查找定位快捷键 Ctrl+W/Ctrl+Shift+W 智能选择对应代码块.F2 或 Shift+F2，错误快速定位Ctrl+U，转到父类Ctrl+Alt+B 跳到实现类/实现方法Ctrl+B 跳到定义Ctrl+Q 查看注释Ctrl+H，显示类结构图Ctrl+F12 列出当前类的所有方法,变量.Ctrl+F 查找文本Ctrl+Shift+F，全局查找Ctrl+R 替换文本Ctrl+G，定位行Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择Alt+F7，查找整个工程中使用的某一个类、方法或者变量的位置Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失Ctrl+N 根据类名查找类Ctrl+Shift+N 根据文件名查找文件(包括类)Ctrl+Shift+Alt+N，查找所有类中的方法或变量Ctrl+Shift+S，高级搜索Alt+F3，逐个往下查找相同文本，并高亮显示Alt+F8，计算变量值Ctrl+Alt+left/right，返回至上次浏览的位置Ctrl+Alt+F7，显示用法Ctrl+Shift+A 查看所有快捷键Ctrl+Tab 工作界面切换. Debug快捷键 Alt+Shift+F9，选择 DebugAlt+Shift+F10，选择 RunF7，步入F8，步过Shift+F8 跳出方法F9，恢复程序Alt+F9 跳到鼠标指定的位置/断点/直接跳出Alt+F10，查看当前断点Ctrl+Shift+F8 查看全部断点Shift+F7，智能步入Shift+F8，智能步出Alt+Shift+F7，强制步入Alt+Shift+F8，强制步过 CVS快捷键 Alt+~，VCS 操作菜单Ctrl+K，提交更改Ctrl+T，更新项目Ctrl+Alt+Shift+D，显示变化【常规】 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之命令模式]]></title>
      <url>%2F2017%2F01%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[概念 命令模式是对调用者与执行者的解耦.解耦之后,调用者需要添加新的功能或者执行者添加新的功能时,很容易实现.命令模式与代理模式有一定共性.但也有一定区别.都是对源对象的解耦.增加对需求变化的应变能力. 命令模式调用者–&gt;发出命令–&gt;命令接收对象–&gt;具体执行者执行.需要对命令的跟踪,以方便对其暂停/结束之类的操作.代理模式无需保存具体执行的一些信息.只是作为中间件来调用具体的对象.进行一些处理. 成员 命令接口 命令接口的实现类 命令接收接口 命令接收的实现类 命令执行接口 命令执行实现类 类图End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用反射将Object转换为HashMap]]></title>
      <url>%2F2017%2F01%2F06%2F%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%B0%86Object%E8%BD%AC%E6%8D%A2%E4%B8%BAHashMap%2F</url>
      <content type="text"><![CDATA[代码123456789101112131415161718192021222324252627282930313233public class MapUtils &#123; /** * 使用反射获取对象的成员名作为key,值作为value * * @param o * @return */ public static Map&lt;String, String&gt; objectField2Map(Object o) &#123; Map&lt;String, String&gt; result = new HashMap&lt;&gt;(); if (o == null) return result; Class oClass = o.getClass(); Field[] fields = oClass.getDeclaredFields() ; String key; String value; if (fields != null &amp;&amp; fields.length != 0) &#123; for (Field field : fields) &#123; try &#123; key = field.getName(); if (&quot;serialVersionUID&quot;.equalsIgnoreCase(key)) continue; field.setAccessible(true); Object o1 = field.get(o) ; value = o1.toString(); result.put(key, value); &#125; catch (IllegalAccessException e) &#123; continue; &#125; &#125; &#125; return result; &#125;&#125; End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[apache httpclient工具类]]></title>
      <url>%2F2017%2F01%2F06%2Fapache-httpclient%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[httpclient的简单封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158public class IntelliHttpClientUtils &#123; private static final Logger logger = LoggerFactory.getLogger(IntelliHttpClientUtils.class); //HttpClient private volatile static CloseableHttpClient httpClient; //设置请求和传输超时时间 1000*6 秒 private static final RequestConfig requestConfig = RequestConfig.custom().setSocketTimeout(0b1011101110000).setConnectTimeout(0b1011101110000).build(); /** * HTTP GET * * @param url * @param encode * @return */ public static String httpGet(String url, String encode) &#123; if (encode == null) encode = &quot;utf-8&quot;; String resultStr = null; CloseableHttpClient closeableHttpClient = getHttpClient(); HttpGet httpGet = new HttpGet(url); httpGet.setConfig(requestConfig); CloseableHttpResponse httpResponse = null; try &#123; httpResponse = closeableHttpClient.execute(httpGet); if (httpResponse.getStatusLine().getStatusCode() &lt; HttpStatus.SC_BAD_REQUEST) &#123; HttpEntity entity = httpResponse.getEntity(); resultStr = EntityUtils.toString(entity, encode); &#125; //请求失败 直接返回null &#125; catch (Exception e) &#123; logger.info(&quot;Intelli.IntelliHttpClientUtils.httpGet 产生异常:&#123;&#125;&quot;, e.getMessage()); &#125; finally &#123; HttpClientUtils.closeQuietly(httpResponse); &#125; return resultStr; &#125; /** * HTTP POST 请求 * * @param url * @param encode * @return */ public static String httpPost(String url, Map&lt;String, String&gt; params, String encode) &#123; if (encode == null) &#123; encode = &quot;utf-8&quot;; &#125; CloseableHttpClient closeableHttpClient = getHttpClient(); HttpPost httpPost = new HttpPost(url); httpPost.setConfig(requestConfig); //组织请求参数 List&lt;NameValuePair&gt; paramList = new ArrayList&lt;NameValuePair&gt;(); Set&lt;String&gt; keySet = params.keySet(); for (String key : keySet) &#123; paramList.add(new BasicNameValuePair(key, params.get(key))); &#125; try &#123; httpPost.setEntity(new UrlEncodedFormEntity(paramList, encode)); &#125; catch (UnsupportedEncodingException e1) &#123; logger.info(&quot;Intelli.IntelliHttpClientUtils.httpPost (Map请求添加参数时)产生异常:&#123;&#125;&quot;, e1.getMessage()); return null; &#125; String resultStr = getResponse2Str(encode, closeableHttpClient, httpPost); return resultStr; &#125; /** * Http Post 请求 * * @param url * @param jsonStr * @param encode * @return */ public static String httpPost(String url, String jsonStr, String encode) &#123; if (encode == null) &#123; encode = &quot;utf-8&quot;; &#125; CloseableHttpClient closeableHttpClient = HttpClients.createDefault(); HttpPost httpPost = new HttpPost(url); httpPost.setConfig(requestConfig); httpPost.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;); //组织请求参数 StringEntity stringEntity = new StringEntity(jsonStr, encode); httpPost.setEntity(stringEntity); String resultStr = getResponse2Str(encode, closeableHttpClient, httpPost); return resultStr; &#125; /** * 获取 CloseableHttpClient * * @return */ private static CloseableHttpClient getHttpClient() &#123; if (httpClient == null) &#123; synchronized (IntelliHttpClientUtils.class) &#123; if (httpClient == null) &#123; HttpClientBuilder httpClientBuilder = HttpClientBuilder.create(); httpClientBuilder.setConnectionManager(new BasicHttpClientConnectionManager()); httpClient = httpClientBuilder.build(); &#125; &#125; &#125; return httpClient; &#125; /** * 关闭httpClient */ private void closeHttpClient() &#123; if (IntelliHttpClientUtils.httpClient == null) return; HttpClientUtils.closeQuietly(IntelliHttpClientUtils.httpClient); &#125; /*** * 关闭httpClient */ @Override protected void finalize() throws Throwable &#123; this.closeHttpClient(); super.finalize(); &#125; /** * 执行 POST 请求 * * @param encode * @param closeableHttpClient * @param httpPost * @return */ private static String getResponse2Str(String encode, CloseableHttpClient closeableHttpClient, HttpPost httpPost) &#123; CloseableHttpResponse httpResponse = null; String resultStr = null; try &#123; httpResponse = closeableHttpClient.execute(httpPost); if (httpResponse.getStatusLine().getStatusCode() &lt; HttpStatus.SC_BAD_REQUEST) &#123; HttpEntity entity = httpResponse.getEntity(); resultStr = EntityUtils.toString(entity, encode); &#125; &#125; catch (Exception e) &#123; logger.info(&quot;Intelli.IntelliHttpClientUtils.getResponse2Str 产生异常:&#123;&#125;&quot;, e.getMessage()); &#125; finally &#123; HttpClientUtils.closeQuietly(httpResponse); &#125; return resultStr; &#125;&#125; End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[http协议状态码]]></title>
      <url>%2F2017%2F01%2F05%2Fhttp%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
      <content type="text"><![CDATA[代码列表 概述 200 服务器成功返回网页 404 – 请求的网页不存在 503 – 服务不可用1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。代码 说明100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx (成功)表示成功处理了请求的状态代码。 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。201 （已创建） 请求成功并且服务器创建了新的资源。202 （已接受） 服务器已接受请求，但尚未处理。203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204 （无内容） 服务器成功处理了请求，但没有返回任何内容。205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。206 （部分内容） 服务器成功处理了部分 GET 请求。 3xx （重定向） 表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。 400 （错误请求） 服务器不理解请求的语法。401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403 （禁止） 服务器拒绝请求。404 （未找到） 服务器找不到请求的网页。405 （方法禁用） 禁用请求中指定的方法。406 （不接受） 无法使用请求的内容特性响应请求的网页。407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。408 （请求超时） 服务器等候请求时发生超时。409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415 （不支持的媒体类型） 请求的格式不受请求页面的支持。416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 500 （服务器内部错误） 服务器遇到错误，无法完成请求。501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 新 RFC 6585 最近刚刚发布，该文档描述了 4 个新的 HTTP 状态码。 HTTP 协议还在变化？是的，HTTP 协议一直在演变，新的状态码对于开发 REST 服务或者说是基于 HTTP 的服务非常有用，下面我们为你详细介绍这四个新的状态码以及是否应该使用。 428 Precondition Required (要求先决条件) 先决条件是客户端发送 HTTP 请求时，如果想要请求能成功必须满足一些预设的条件。 一个好的例子就是 If-None-Match 头，经常在 GET 请求中使用，如果指定了 If-None-Match ，那么客户端只在响应中的 ETag 改变后才会重新接收回应。 先决条件的另外一个例子就是 If-Match 头，这个一般用在 PUT 请求上用于指示只更新没被改变的资源，这在多个客户端使用 HTTP 服务时用来防止彼此间不会覆盖相同内容。 当服务器端使用 428 Precondition Required 状态码时，表示客户端必须发送上述的请求头才能执行请求，这个方法为服务器提供一种有效的方法来阻止 ‘lost update’ 问题。 429 Too Many Requests (太多请求) 当你需要限制客户端请求某个服务数量时，该状态码就很有用，也就是请求速度限制。 在此之前，有一些类似的状态码，例如 ‘509 Bandwidth Limit Exceeded’. Twitter 使用 420 （这不是HTTP定义的状态码） 如果你希望限制客户端对服务的请求数，可使用 429 状态码，同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务。 431 Request Header Fields Too Large (请求头字段太大) 某些情况下，客户端发送 HTTP 请求头会变得很大，那么服务器可发送 431 Request Header Fields Too Large 来指明该问题。 我不太清楚为什么没有 430 状态码，而是直接从 429 跳到 431，我尝试搜索但没有结果。唯一的猜测是 430 Forbidden 跟 403 Forbidden 太像了，为了避免混淆才这么做的，天知道！ 511 Network Authentication Required (要求网络认证) 对我来说这个状态码很有趣，如果你在开发一个 HTTP 服务器，你不一定需要处理该状态码，但如果你在编写 HTTP 客户端，那这个状态码就非常重要。 如果你频繁使用笔记本和智能手机，你可能会注意到大量的公用 WIFI 服务要求你必须接受一些协议或者必须登录后才能使用。 这是通过拦截HTTP流量，当用户试图访问网络返回一个重定向和登录，这很讨厌，但是实际情况就是这样的。 使用这些“拦截”客户端，会有一些讨厌的副作用。在 RFC 中有提到这两个的例子： 如果你在登录WIFI前访问某个网站，网络设备将会拦截首个请求，这些设备往往也有自己的网站图标 ‘favicon.ico’。登录后您会发现，有一段时间内你访问的网站图标一直是WIFI登录网站的图标。如果客户端使用HTTP请求来查找文档（可能是JSON），网络将会响应一个登录页，这样你的客户端就会解析错误并导致客户端运行异常，在现实中这种问题非常常见。因此 511 状态码的提出就是为了解决这个问题。 如果你正在编写 HTTP 的客户端，你最好还是检查 511 状态码以确认是否需要认证后才能访问。End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之装饰者模式]]></title>
      <url>%2F2017%2F01%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[装饰者模式简述 装饰者模式可以形象的比喻一所大房子,外面只有一个门.打开门里面还有门.打开门获取一点金钱.你可以无限的进门.. Component（被装饰对象的基类） ConcreteComponent（具体被装饰对象） Decorator（装饰者抽象类） ConcreteDecorator（具体装饰者） 类图 代码 定义一个抽象类(非必须) 1234567891011121314151617181920package com.pan.component;/** * 抽象类 * * @author xinyi.pan * */public abstract class Animal &#123; private String name; public Animal(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 定义一个被装饰的接口(定义公共的方法). 12345678package com.pan.component;public interface Fight &#123; //公共方法(门) public String fightPower() ; &#125; 单独类cat 12345678910111213package com.pan.component;public class Cat extends Animal implements Fight &#123; public Cat(String name) &#123; super(name); &#125; //基类的门,里面不再有门.. public String fightPower() &#123; return super.getName() +&quot; fighting&quot; ; &#125; &#125; 单独类cattle 123456789101112package com.pan.component;public class Cattle extends Animal implements Fight &#123; public Cattle(String name) &#123; super(name); &#125; public String fightPower() &#123; return super.getName() + &quot; sleep&quot;; &#125;&#125; 定义抽象装饰类 123456789101112131415161718192021222324package com.pan.decorator;import com.pan.component.Fight;public abstract class AnimalDecorator implements Fight &#123; private Fight fight; // 构造函数添加被装饰着对象 public AnimalDecorator(Fight fight) &#123; this.fight = fight; &#125; //拆包装饰者 public String fightPower() &#123; //调用装饰者公共方法 doDecoratorFight(); //打开下一个门 return fight.fightPower(); &#125; //装饰者的公共方法. public abstract void doDecoratorFight() ;&#125; cattle装饰类 123456789101112131415161718192021package com.pan.decorator;import com.pan.component.Fight;public class CattleDecorator extends AnimalDecorator &#123; public CattleDecorator(Fight fight) &#123; super(fight); &#125; @Override public String fightPower() &#123; return super.fightPower(); &#125; @Override public void doDecoratorFight() &#123; System.out.println(&quot;cattle 打豆豆&quot;); &#125; &#125; 测试方法 123456789101112131415161718192021package com.pan.test;import com.pan.component.Cat;import com.pan.decorator.CatDecorator;import com.pan.decorator.CattleDecorator;public class CalTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;==================未装饰cat==================&quot;); System.out.println(new Cat(&quot;cat&quot;).fightPower()); System.out.println(&quot;===================装饰cat======================&quot;); CatDecorator catDecorator = new CatDecorator(new Cat(&quot;cat&quot;)) ; System.out.println(catDecorator.fightPower()); CattleDecorator cattleDecorator = new CattleDecorator(catDecorator) ; System.out.println(&quot;====================cattle装饰cat装饰=====================&quot;); System.out.println(cattleDecorator.fightPower()); &#125;&#125; 结果 123456789==================未装饰cat==================cat fighting===================装饰cat======================cat 打豆豆cat fighting====================cattle装饰cat装饰=====================cattle 打豆豆cat 打豆豆cat fighting End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[去百度右侧推广方法]]></title>
      <url>%2F2017%2F01%2F02%2F%E5%8E%BB%E7%99%BE%E5%BA%A6%E6%8E%A8%E5%B9%BF%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[百度越来越恶心了… 下面介绍一种简单的去百度推广方法,采用的是chrome浏览器. 安装adb去广告插件. 添加自定义规则. 右侧推广去掉的结果 但是还有搜索的推广 添加清除左侧推广规则 全部结果7.规则: ##div[class*=&quot;cr-content&quot;] ##div[class*=&quot;opr-recommends-merge-panel&quot;] ##div[id*=&quot;con-ar&quot;] ##div[style*=&quot;!important&quot;] End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之观察者模式]]></title>
      <url>%2F2016%2F12%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[观察者模式 观察者模式一般使用在订阅/推送功能下,数据提供方推送数据–&gt;数据接收方.其实在开发中该模式使用应该是很普遍的.例如站内信/信息中心/订阅都是用的是该设计模式. 方式1:数据推送方—&gt;查询订购对象—&gt;推送给订购对象. 方式2:订购的对象 —&gt;查询订阅的数据—&gt;拉取需要的数据. 本质上其实就是发送方与接收方的依赖隔离,也就是说数据发送方发送数据,不是直接发送给订购的对象,而是先查询哪些订购了.然后统一发送出 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java volatile 关键字]]></title>
      <url>%2F2016%2F12%2F29%2Fjava-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
      <content type="text"><![CDATA[volatile关键字的使用 volatile关键字的作用是告诉编译器,该变量是易变的.不要将该变量的值存储在寄存器中,而是放在内存中(一般指的是静态也就是栈). 某些静态变量,如果使用频繁.可能会直接存放于寄存器中,以便加快计算的速度.但是,如果我们期望该值不应 该存在多个不一样的值时候,除了使用final定义为常量.还可以使用该关键字. 该关键字既可以避免一个变量出现多个值的可能,也可以避免常量的不可改变性. 注意点: 使用场景应该如下: 多个线程中,该变量只能拥有一个对象. 该变量可能需要变化.即该变量需要动态创建/销毁. 它本身无法保证运行中只存在一个对象.它只是告诉jvm,它的值需要从内存中去读取,而不是在寄存器(1级缓存/2级缓存/3级缓存)中获取该值. 如果只是需要一个对象,使用final关键字即可.如果该对象使用不频繁,减少内存开销.可以使用该关键字,配合多线程的同步锁,可以实现单例. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之策略模式]]></title>
      <url>%2F2016%2F12%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[策略模式 策略模式是用于解决面向对象中的抽象类与接口的局限性.即一般的对类别进行抽象,对行为进行抽象为接口.这种方式在代码复用上有一定的局限性.而策略模式可以提高代码的复用. eg://定义一个接口,用于在抽象类都能调用到.(里氏替换原则)interface Speak{ void doSpeak() ;}// 实现接口1,其他类只要功能一样都可以采用它.class SpeakCn implements Speak{@Overridepublic void doSpeak() { System.out.println(&quot;中文&quot;); }}//实现接口2,其他类只要功能一样都可以采用它.class SpeakEn implements Speak{@Overridepublic void doSpeak() { System.out.println(&quot;English&quot;); }}//抽象类 使用接口来实现.将具体实现放到子类来实现接口.abstract class man{Speak speak ;void speak(){ speak.doSpeak(); }}class CnMan extends man{//初始化赋值父类接口的实现,也可以采用Spring的初始化加载实现.public CnMan() { speak = new SpeakCn() ; }}//使用class test{public void main(String[] args) { new CnMan().speak(); }} End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 基础语法]]></title>
      <url>%2F2016%2F12%2F28%2FMarkdown-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[markdown基本语法.文字类 标题大小用#来标记,等同于html的&lt;h1&gt;&lt;/h1&gt;标签. 内容的强调使用*或_ 来标记. 有序列表使用数字.来标记. 无序列表使用* 或- 或+来标记. 小代码使用2个`来标记.代码块使用6个`来标记. 如果需要显示单个代码,也可以使用\来标记该字符不被解析. 代码块一种更简便的方式是在开头使用一个tab+4个空格. 列表的嵌套使用tab+列表标记. 空行直接使用html的标记&lt;br/&gt; 连接类 页面内的跳转. 使用&lt;span id =&quot;bijiao&quot;&gt;&lt;/span&gt; 定义一个要跳转的地方. 使用&lt;a href=&quot;#biaoqian&quot;&gt;跳&lt;/a&gt;或者[跳](#biaoqian)来实现跳转. 其他跳转.使用&lt;a href=&quot;地址&quot;&gt;跳&lt;/a&gt;或者[跳](地址)来实现跳转. 图片类 使用&lt;img src=&quot;地址&quot;&gt;名称&lt;/img&gt;或者![名称](地址)来实现. 音视频 声音:使用&lt;audio src=&quot;地址&quot; autoplay=&quot;true&quot;&gt;声音&lt;/audio&gt;来实现 视频:使用&lt;video src=&quot;地址&quot; autoplay=&quot;true&quot;&gt;视频&lt;/video&gt;来实现总结来说,mardown完全可以使用html标签来写.不过,html写起来麻烦.但是一些功能目前来说,markdown还不支持,所以只能采用html的标签来实现.来外,颜色样式的定义.好像也不可以.也只能用html.个人理解markdown只是html的一个框架.对html的一个封装.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git的使用]]></title>
      <url>%2F2016%2F12%2F27%2Fgit%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Git初次使用一般来说就5步. cd 你的目录 //进入你需要提交的目录. git init //初始化. git add * //添加需要提交的文件. git commit -m “第一次提交” //提交的说明. git remote add origin https://github.com/lmxy1990/test.git //添加远程仓库地址 git push -u origin master //提交 到主干]]></content>
    </entry>

    
  
  
</search>
