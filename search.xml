<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[SQL Group By Order By]]></title>
      <url>%2F2017%2F08%2F25%2FSQL-Group-By-Order-By%2F</url>
      <content type="text"><![CDATA[Mysql Group By 灵活应用 场景有赛事球员表 记为race_player赛事表 race球员表 player现在需要查询 ,每个球员未开赛,最近一场的赛事球员数据. 分析条件 :未开赛聚合纬度 :球员聚合选取条件:未开赛且比赛时间最小 探究确定 赛事球员的幂等是赛事id,球员id.那么,在选取赛事球员对象的时候,就需要构造成这样的参数对.那么,首先应该先查出这样的参数对.代码:1234select min(r2.match_time) t,player_id from race_player r1 left join race r2 on r1.race_id = r2.id where r2.race_status = 1 group by r1.player_id 这里查出球员id,对应的最小比赛时间. 也就是相当于赛事id(在做一层关联).这里使用赛事球员关联赛事,聚合球员.取得球员对应的最小值.因为这里只需要走一层关联.如果采用赛事 -&gt; 球队 -&gt; 球员 去查这个幂等对.会多走一层关联.选取好这个幂等对,首先需要转化为赛事id.所以这里还需要在关联赛事,用于获取赛事id.代码:1234567891011121314SELECT rp.* FROM race_player rpLEFT JOIN player tp ON rp.player_id = tp.idLEFT JOIN race r ON rp.race_id = r.idLEFT JOIN ( select min(r2.match_time) t,player_id from race_player r1 left join race r2 on r1.race_id = r2.id where r2.race_status = 1 //赛事条件 group by r1.player_id ) r3 on r3.t = r.match_time and r3.player_id = rp.player_idWHERE //其他条件ISNULL(rp.id) = FALSEAND ISNULL(tp.id) = FALSEAND ISNULL(r.id) = FALSE ; 这样,有序列的group by 就完成了. group by 大多数情况下.希望以后这个函数会优化成group by 参数 desc 选取指定行.而不是只能采用聚合函数.那面对这样的问题,就很简单了. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QuartZ Cron表达式]]></title>
      <url>%2F2017%2F08%2F14%2F%20QuartZ%20Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[示例1234567891011121314*/5 * * * * ? 每隔5秒执行一次0 */1 * * * ? 每隔1分钟执行一次0 0 23 * * ? 每天23点执行一次0 0 1 * * ? 每天凌晨1点执行一次：0 0 1 1 * ? 每月1号凌晨1点执行一次0 0 23 L * ? 每月最后一天23点执行一次0 0 1 ? * L 每周星期天凌晨1点实行一次0 26,29,33 * * * ? 在26分、29分、33分执行一次0 0 0,13,18,21 * * ? 每天的0点、13点、18点、21点都执行一次作者：阳春是你链接：http://www.jianshu.com/p/f03b1497122a來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 对象判断工具类]]></title>
      <url>%2F2017%2F08%2F09%2FJava-%E5%AF%B9%E8%B1%A1%E5%88%A4%E6%96%AD%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[用于判断对象是否相等,支持Java基本类型,包装类.需要引用的jar包.谷歌工具类,apache工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205** * 对象比较工具类 * 基本类型/Java自带类型使用Apache的比较工具类. * 自定义对象采用反射递归比较.集合类采用循环递归比较 * &lt;p&gt; * * Date: 2017/8/9 */public class EqualObjectUtils implements Serializable &#123; private static final long serialVersionUID = 602163719206844077L; /** * 对象比较工具类 * * @param ob1 比较对象1 * @param ob2 比较对象2 * @param ignoreProperNames 忽略属性名List * @return */ public static boolean deepEquals(Object ob1, Object ob2, List&lt;String&gt; ignoreProperNames) &#123; //对象空值判断 if (ob1 == ob2) return true; if (ob1 == null || ob2 == null) return false; Map&lt;String, Boolean&gt; jugMap = new HashMap&lt;&gt;(); if (CollectionUtils.isNotEmpty(ignoreProperNames)) &#123; ignoreProperNames.stream().filter(StringUtils::isNotBlank).forEach(v -&gt; jugMap.put(v, true)); &#125; return deepEquals(ob1, ob2, jugMap); &#125; /** * 比较 * * @param ob1 * @param ob2 * @param jugMap * @return */ private static boolean deepEquals(Object ob1, Object ob2, final Map&lt;String, Boolean&gt; jugMap) &#123; //对象空值判断 if (ob1 == ob2) return true; if (ob1 == null || ob2 == null) return false; Class&lt;?&gt; aClass = ob1.getClass(); Class&lt;?&gt; bClass = ob2.getClass(); //类型是否一致 if (!Objects.equals(ob1.getClass(), ob2.getClass())) return false; //是否是集合类 if (isCollection(ob1) || isCollection(ob2)) &#123; Collection&lt;Object&gt; co1 = (Collection&lt;Object&gt;) ob1; Collection&lt;Object&gt; co2 = (Collection&lt;Object&gt;) ob2; boolean rs = deepCollectionsEquals(co1, co2, jugMap); if (!rs) return false; &#125; else if (isJavaClass(aClass) || isJavaClass(bClass)) &#123;//Java自带对象处理(目前包名已Java开头的采用此方法.) return EqualsBuilder.reflectionEquals(ob1, ob2, new ArrayList&lt;&gt;(jugMap.keySet())); &#125; else &#123;//自定义对象处理 //自定义对象 Field[] fields1 = aClass.getDeclaredFields(); Field[] fields2 = bClass.getDeclaredFields(); if (fields1 == fields2) return true; if (fields1 == null || fields2 == null) return false; if (fields1.length != fields2.length) return false; Map&lt;String, Field&gt; fieldMap1 = new HashMap&lt;&gt;(); Map&lt;String, Field&gt; fieldMap2 = new HashMap&lt;&gt;(); for (int i = 0; i &lt; fields1.length; i++) &#123; Field field1 = fields1[i]; Field field2 = fields2[i]; //过滤指定属性 Boolean aBoolean = jugMap.get(field1.getName()); if (aBoolean != null &amp;&amp; aBoolean) continue; if (&quot;serialVersionUID&quot;.equals(field1.getName())) continue;//序列化忽略 field1.setAccessible(true); field2.setAccessible(true); fieldMap1.put(field1.getName(), field1); fieldMap2.put(field2.getName(), field1); &#125; Set&lt;Map.Entry&lt;String, Field&gt;&gt; entrySet = fieldMap1.entrySet(); for (Iterator&lt;Map.Entry&lt;String, Field&gt;&gt; iterator = entrySet.iterator(); iterator.hasNext(); ) &#123;//每个子属性判断 Map.Entry&lt;String, Field&gt; next = iterator.next(); String key = next.getKey(); Field field1 = next.getValue(); Field field2 = fieldMap2.get(key); Class&lt;?&gt; type1 = field1.getType(); Class&lt;?&gt; type2 = field2.getType(); //类型是否一致 if (!Objects.equals(type1, type2)) return false; Object o1 = null; Object o2 = null; try &#123; o1 = field1.get(ob1); o2 = field2.get(ob2); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; //对象空值判断 if (o1 == o2) continue; if (o1 == null || o2 == null) return false; //是否是集合类 if (isCollection(o1) || isCollection(o2)) &#123; Collection&lt;Object&gt; co1 = (Collection&lt;Object&gt;) o1; Collection&lt;Object&gt; co2 = (Collection&lt;Object&gt;) o2; boolean rs = deepCollectionsEquals(co1, co2, jugMap); if (!rs) return false; &#125; else if (isJavaClass(field1.getType()) || isJavaClass(field1.getType())) &#123; boolean equals = EqualsBuilder.reflectionEquals(o1, o2, new ArrayList&lt;&gt;(jugMap.keySet())); if (!equals) return false; &#125; else &#123; boolean equals = deepEquals(o1, o2, jugMap); if (!equals) return false; &#125; &#125; &#125; return true; &#125; /** * 是否是Java提供的数据类型.可以适当扩展其他类型.只要支持Equal方法的类型都可以添加进来.对工具类没影响 * * @param _class * @return */ private static boolean isJavaClass(Class _class) &#123; //基本类型 if (_class.isPrimitive()) &#123; return true; &#125; //包装类型 if (_class.getPackage().getName().startsWith(&quot;java.&quot;)) &#123; return true; &#125; //自定义类型 return false; &#125; /** * 是否是集合类 * * @param o * @return */ private static boolean isCollection(Object o) &#123; if (o instanceof Collection) &#123; return true; &#125; return false; &#125; /** * 集合类比较 * * @param collection1 * @param collection2 * @return */ private static boolean deepCollectionsEquals(Collection&lt;Object&gt; collection1, Collection&lt;Object&gt; collection2, final Map&lt;String, Boolean&gt; jugMap) &#123; if (collection1 == collection2) return true; if (collection1 == null || collection2 == null) return false; if (collection1.size() != collection2.size()) return false; for (Object o1 : collection1) &#123; boolean rs = false; for (Object o2 : collection2) &#123; rs = deepEquals(o1, o2, jugMap); if (rs) &#123; rs = true; &#125; &#125; if (!rs) return false; &#125; return true; &#125; public static void main(String[] args) &#123; GameRoomDTO room1 = new GameRoomDTO(); GameRoomDTO room2 = new GameRoomDTO(); room1.setGameRoomId(1L); room2.setGameRoomId(1L); room1.setRoomName(&quot;房间1&quot;); room2.setRoomName(&quot;房间1&quot;); Member member1 = new Member(); Member member2 = new Member(); member1.setNickName(&quot;小王&quot;); member2.setNickName(&quot;小李&quot;); room1.setMemberList(Lists.newArrayList(member2,member1)); room2.setMemberList(Lists.newArrayList(member1,member2)); List&lt;String&gt; ignoreProps = Lists.newArrayList(&quot;nickName&quot;, &quot;createTime&quot;, &quot;updateTime&quot;, &quot;lastLoginTime&quot;); System.out.println(deepEquals(room1,room2,ignoreProps)); &#125;&#125; End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 编程规范]]></title>
      <url>%2F2017%2F07%2F04%2FJava-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[编程规约 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚. POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。 接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁. 不允许任何魔法值（即未经定义的常量）直接出现在代码中。 所有的覆写方法，必须加@Override 注解。 构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。 setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在 getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。 循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。 对于Map,只要重写 equals，就必须重写 hashCode。 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。 ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常. 使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全 一样的数组，大小就是 list.size()。 使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方 法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。 泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用 add 方 法，而&lt;? super T&gt;不能使用 get 方法，做为接口调用赋值时易出错。 说明：扩展说一下 PECS(Producer Extends Consumer Super)原则：1）频繁往外读取内容 的，适合用上界 Extends。2）经常往里插入的，适合用下界 Super。 不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。 集合初始化时，指定集合初始值大小。 使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。 获取单例对象需要保证线程安全，其中的方法也要保证线程安全。 SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能 锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。 并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加 锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。 说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次 数不得小于 3 次。 子线程抛出异常堆栈，不能在主线程 try-catch 到。 避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。 volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题， 但是如果多写，同样无法解决线程安全问题。 HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。 表达异常的分支时，少用 if-else 方式，这种方式可以改写成：if return ; 在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。不要在方法体内定义：Pattern pattern = Pattern.compile(规则); 后台输送给页面的变量必须加$!{var}.如果 var=null 或者不存在，那么${var}会直接显示在页面上。 29.注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够 取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后 取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。 获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime(); 异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请 将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的 内容。 不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。 应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过 关键字 throws 往上抛出。 数据库 任何字段如果为非负数，必须是 unsigned。 表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只 出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 表名不使用复数名词。 禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。 主键索引名为 pk字段名；唯一索引名为 uk字段名；普通索引名则为 idx_字段名。 小数类型为 decimal，禁止使用 float 和 double。 varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。 表的命名最好是加上“业务名称_表的作用”。 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询 时，保证被关联的字段需要有索引。 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合 索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort的情况，影响查询性能。 建组合索引的时候，区分度最高的在最左边。 防止因字段类型不同造成的隐式转换，导致索引失效。 不要使用 count(列名)或 count(常量)来替代 count()，count()是 SQL92 定义的 标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。 当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控 制在 1000 个之内。 POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行 字段与属性之间的映射。 sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。 @Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需 要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 自定义线程池]]></title>
      <url>%2F2017%2F06%2F28%2FJava-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
      <content type="text"><![CDATA[自定义线程池的逻辑:指定核心线程数,最大线程数,线程执行的最长时间,线程指定最长时间的单位,线程执行任务的缓存队列,线程工厂.代码: 自定义线程工厂:12345678910111213141516171819202122public class MyThreadFactory implements ThreadFactory &#123; //线程优先级 private int priority = 5; //是否是守护线程 private boolean daemon = false; private String name = &quot;自定义线程&quot;; private ClassLoader classLoader; private UncaughtExceptionHandler uncaughtExceptionHandler; @Override public Thread newThread(Runnable r) &#123; Thread thread = new Thread(r); thread.setName(this.name); thread.setPriority(this.priority); thread.setDaemon(this.daemon); thread.setContextClassLoader(this.classLoader); thread.setUncaughtExceptionHandler(this.uncaughtExceptionHandler); System.out.println(&quot;通过线程工厂开始执行线程:&quot;+this.name); return thread; &#125;&#125; 自定义线程池:1234567891011121314151617181920212223242526272829303132public class ThreadPool &#123; public static void main(String[] args) &#123; //自定义缓冲队列 LinkedBlockingQueue&lt;Runnable&gt; linkedBlockingDeque = new LinkedBlockingQueue&lt;&gt;() ; //自定义线程工厂 ThreadFactory threadFactory = new MyThreadFactory() ; //自定义线程池 ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5,10,10, TimeUnit.MINUTES,linkedBlockingDeque,threadFactory) ; //通过程工厂执行任务 for (int i = 0; i &lt; 20; i++) &#123; threadPoolExecutor.execute(() -&gt; &#123; for (int j = 0; j &lt;100000000; j++) &#123; int div = Math.floorDiv(++j, j * j);// System.out.println(div); &#125; System.out.println(&quot;线程启动&quot;) ; &#125;); int activeCount = threadPoolExecutor.getActiveCount(); System.out.println(&quot;当前进行中的线程数:&quot; +activeCount); System.out.println(&quot;当前队列中的缓存数:&quot; +linkedBlockingDeque.size()); &#125; //关闭线程池 threadPoolExecutor.shutdown(); &#125;&#125; 执行输出结果:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970通过线程工厂开始执行线程:自定义线程线程名:自定义线程当前进行中的线程数:1当前队列中的缓存数:0通过线程工厂开始执行线程:自定义线程线程名:自定义线程当前进行中的线程数:2当前队列中的缓存数:0通过线程工厂开始执行线程:自定义线程线程名:自定义线程当前进行中的线程数:3当前队列中的缓存数:0通过线程工厂开始执行线程:自定义线程线程名:自定义线程当前进行中的线程数:4当前队列中的缓存数:0通过线程工厂开始执行线程:自定义线程线程名:自定义线程当前进行中的线程数:5当前队列中的缓存数:0当前进行中的线程数:5当前队列中的缓存数:1当前进行中的线程数:5当前队列中的缓存数:2当前进行中的线程数:5当前队列中的缓存数:3当前进行中的线程数:5当前队列中的缓存数:4当前进行中的线程数:5当前队列中的缓存数:5当前进行中的线程数:5当前队列中的缓存数:6当前进行中的线程数:5当前队列中的缓存数:7当前进行中的线程数:5当前队列中的缓存数:8当前进行中的线程数:5当前队列中的缓存数:9当前进行中的线程数:5当前队列中的缓存数:10当前进行中的线程数:5当前队列中的缓存数:11当前进行中的线程数:5当前队列中的缓存数:12当前进行中的线程数:5当前队列中的缓存数:13当前进行中的线程数:5当前队列中的缓存数:14当前进行中的线程数:5当前队列中的缓存数:15线程启动线程启动线程启动线程启动线程启动线程启动线程启动线程启动线程启动线程启动线程启动线程启动线程启动线程启动线程启动线程启动线程启动线程启动线程启动线程启动 结果分析: 任务启动 -&gt; 线程工厂创建该线程 -&gt; 线程池判断当前线程执行数量 -&gt; 线程等待 -&gt; 加入缓冲队列. 任务启动 -&gt; 线程工厂创建该线程 -&gt; 线程池判断当前线程执行数量 -&gt; 线程执行 线程池当前执行任务数少于最大任务数 -&gt; 缓冲队列FIFO 获取任务. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySql 存储过程]]></title>
      <url>%2F2017%2F06%2F28%2FMySql-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySql 锁机制]]></title>
      <url>%2F2017%2F06%2F28%2FMySql-%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java中的集合删除方法注意点]]></title>
      <url>%2F2017%2F06%2F15%2Fjava%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95%E6%B3%A8%E6%84%8F%E7%82%B9%2F</url>
      <content type="text"><![CDATA[集合类的删除方法 最近做的业务遇到一个排名的需求.在remove的时候,数据出来的意志有问题.逻辑检查好几遍都没问题.debug之后,才找出这个问题.看示例代码:12345678910111213List&lt;Integer&gt; pp = new ArrayList&lt;&gt;() ;pp.add(1) ;pp.add(2) ;pp.add(3) ;pp.add(4) ;for (int i = 0; i &lt; pp.size(); i++) &#123; Integer integer = pp.get(i); System.out.println(&quot;当前遍历i:&quot; + i + &quot;对应集合数据:&quot; + integer); if (integer.equals(3))&#123; pp.remove(i) ; &#125;&#125; 输出:12345当前遍历i:0对应集合数据:1当前遍历i:1对应集合数据:2当前遍历i:2对应集合数据:3Process finished with exit code 0 why?数据4去了哪里?这其实是remove之后,size会立即变化.但是遍历的指针却并没有做出相应的变化.依旧是自增了一下.也就是说,当i = 2的时候,remove方法执行.然后对应的size变化为3.这时候i++变为了3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JAVA中的值类型,引用类型以及克隆]]></title>
      <url>%2F2017%2F06%2F06%2FJAVA%E4%B8%AD%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%85%8B%E9%9A%86%2F</url>
      <content type="text"><![CDATA[JAVA中的引用类型与值类型 1.引用类型数组,集合,接口,类都是引用类型. 2.值类型所有基本类型:int,short,long 及与之对应的Long,Integer,Double,以及布尔类型boolead,Boolead 也包括Bigdecimal都属于值类型. 3.区别这里不考虑实现,究其底层.只考虑Java中的二者之间的差异.值类型:也就是改变原值,对其之前赋的变量的值没有影响.123456BigDecimal d1 = BigDecimal.ONE ;BigDecimal d2 = d1 ;d1 = d1.add(BigDecimal.ONE) ;System.out.println(d1);System.out.println(d2); 结果如下:123456234234 引用类型:改变原值,对其之前使用=赋值的变量也会有影响.1234567891011121314int[] ar = &#123;1,2,3&#125; ;int[] br = ar ;ar[0] = 2 ;ar[1] = 3 ;ar[2] = 4 ;for (int i = 0; i &lt; ar.length; i++) &#123; int i1 = ar[i]; System.out.println(i1);&#125;for (int i = 0; i &lt; br.length; i++) &#123; int i1 = br[i]; System.out.println(i1);&#125; 结果如下:1221 4.浅析原理.有一种说法是java没有值类型.其实角度不一样.从原理上来说确实没有.但从表象上来说是有的.因为在赋值运算的时候.遇到基本类型是新开辟内存空间.遇到引用类型是改变指针指向的地址.这区别与java对赋值运算的实现. 所以,java官方说基本类型是值类型.那就是说,赋值运算在对待基本类型的赋值与引用类型时候,会采用不同的方式去处理.这区别于C/C++. 这一点其实在对待Long Integer 类的赋值的时候,就可以看出来了.至于为什么基本类型赋值是新开辟,而引用类型是修改指针地址.这可能是因为所占对象大小,基本类型占用低,使用修改频繁.所以新增这样的对象所消耗内存少.而引用类型的内存消耗完全取决用用户的定义.故赋值采用的是改变指针的指向.而非new 对象.但是java提供一个克隆的方法.用于新开辟内存而非改变指针指向内存地址. 至于如果引用类型需要拷贝而不是改变指针的地址进行的赋值时候.可以采用克隆或者直接new 对象.然后进行对基本类型的赋值操作.遇到引用类型,就需要new/克隆去开辟新的内存空间.这样才能改变原对象的值,不会影响克隆的变量. 克隆 1.实现Cloneable接口2.覆写Object的clone方法.3.如果对象存在非基本类型,还需要修改覆写的方法.eg: Java 自带的Calendar类覆写的clone方法12345678910111213141516171819202122@Overridepublic Object clone()&#123; try &#123; Calendar other = (Calendar) super.clone(); other.fields = new int[FIELD_COUNT]; other.isSet = new boolean[FIELD_COUNT]; other.stamp = new int[FIELD_COUNT]; for (int i = 0; i &lt; FIELD_COUNT; i++) &#123; other.fields[i] = fields[i]; other.stamp[i] = stamp[i]; other.isSet[i] = isSet[i]; &#125; other.zone = (TimeZone) zone.clone(); return other; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn&apos;t happen, since we are Cloneable throw new InternalError(e); &#125;&#125; 以上例子就是覆写clone方法.如果没有引用类型.那只需要调用超类的方法即可.1234@Overrideprotected Object clone() throws CloneNotSupportedException &#123; return super.clone();&#125; End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL 相关备忘录]]></title>
      <url>%2F2017%2F06%2F06%2FSQL%20%E7%9B%B8%E5%85%B3%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
      <content type="text"><![CDATA[函数 GREATEST() 取出多个表达式中最大的值. LEAST() 取出多个表达式中最小的值 在使用形如sum/count函数时候,limit将不起作用.limit是对返回内容的限制. 定义: 数据库 用于存储数据的文件. 数据库实例:用于执行数据增删改查的程序. 常用语句 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java中标志位的使用']]></title>
      <url>%2F2017%2F06%2F01%2Fjava%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Java 位操作 1.位左移(符号位不变)&lt;&lt;2.位右移(符号位不变)&gt;&gt;3.无符号的位移(空位补零,不考虑符号位)&lt;&lt;&lt; ‘&gt;&gt;&gt;’4.或|5.与&amp;6.按位取反~7.异或^ 用途 用途有点类似控制器上的拨码开关.00001001001 .一般来说,用0代表无,1代表有.每一个符号位代表一种权限.这种应用在多权限的场景下很容易解决N权限的问题. Java 代码 判断方法12345678910111213141516//复合权限判断 private static boolean isHasAllAuthority(long ready,long authority)&#123; return (ready &amp; authority) == authority ? true :false ; &#125; //添加权限 private static long addAuthority(long ready,long authority)&#123; return ready | authority; &#125; //删除权限 private static long removeAuthority(long ready,long authority)&#123; return (ready | authority) ^ authority ; &#125; 测试方法1234567891011121314151617181920212223long pp1 = 1&lt;&lt;1 ;long pp2 = 1&lt;&lt;2 ;long pp3 = 1&lt;&lt;3 ;long pp4 = 1&lt;&lt;4 ;//初始化权限long ready = 0L ;//添加1,4权限ready = addAuthority(ready,pp1) ;ready = addAuthority(ready,pp4) ;//删除1,3权限ready = removeAuthority(ready,pp1|pp3) ;//判断是否拥有1权限System.out.println(&quot;判断是否拥有1权限&quot; + isHasAllAuthority(ready,pp1));//判断是否拥有3权限System.out.println(&quot;判断是否拥有3权限&quot; + isHasAllAuthority(ready,pp3));//判断是否拥有4权限System.out.println(&quot;判断是否拥有4权限&quot; + isHasAllAuthority(ready,pp4));//判断是否拥有1,4权限System.out.println(&quot;判断是否拥有1,4权限&quot; + isHasAllAuthority(ready,pp1|pp4)); 结果123456判断是否拥有1权限false判断是否拥有3权限false判断是否拥有4权限true判断是否拥有1,4权限falseProcess finished with exit code 0 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java stream 流处理]]></title>
      <url>%2F2017%2F05%2F16%2Fjava-stream-%E6%B5%81%E5%A4%84%E7%90%86%2F</url>
      <content type="text"><![CDATA[Java Stream 流处理 jdk1.8之前,处理文字数字都是赋值给相应变量来进行处理.1.8之后,支持是用流来处理.这里的流处理,是对值进行的聚合处理.里面有python的map影子. 流的列别. IntStream、LongStream、DoubleStream。当然我们也可以用 Stream、Stream &gt;、Stream，但是 boxing 和 unboxing会很耗时. 流的获取. 使用集合类.Collection.stream() 或者Collection.parallelStream() 通过数组获取.Arrays.stream(T array) or Stream.of() 通过java的IO.java.io.BufferedReader.lines() 静态工厂.java.util.stream.IntStream.range() 或java.nio.file.Files.walk() 自己构建. java.util.Spliterator 其他: Random.ints() BitSet.stream() Pattern.splitAsStream(java.lang.CharSequence) JarFile.stream() 流处理的分类 Intermediate： 一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。 包含:map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered Terminal: 一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。 包含:forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator short-circuiting: 当操作一个无限大的 Stream，而又希望在有限时间内完成操作，则在管道内拥有一个 short-circuiting 操作是必要非充分条件. 包含:anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit 常见的流操作 查询流里面元素是否为nullArrays.asList(&quot;小明&quot;, &quot;小王&quot;, &quot;小李&quot;).stream().findAny().ifPresent(System.out::print); Arrays.asList(&quot;小明&quot;, &quot;小王&quot;, &quot;小李&quot;).stream().findFirst().ifPresent(System.out::print); 2.匹配Arrays.asList(&quot;小明&quot;, &quot;小王&quot;, &quot;小李&quot;).stream().anyMatch(s -&gt; s.equals(&quot;小王&quot;)) Arrays.asList(&quot;小明&quot;, &quot;小王&quot;, &quot;小李&quot;).stream().allMatch(s -&gt; s.equals(&quot;小王&quot;)) ; Arrays.asList(&quot;小明&quot;, &quot;小王&quot;, &quot;小李&quot;).stream().noneMatch(s -&gt; s.equals(&quot;小王&quot;)) ; 3.过滤Arrays.asList(&quot;小明&quot;, &quot;小王&quot;, &quot;小李&quot;).stream().filter(va -&gt; !va.equals(&quot;小王&quot;)).forEach(System.out::print); 4.映射(1对1)Arrays.asList(&quot;小明&quot;, &quot;小王&quot;, &quot;小李&quot;).stream().map(va -&gt; &quot;打豆豆&quot; + va ).forEachOrdered(System.out :: print); 5.映射(多对一)12345Arrays.asList( Arrays.asList(&quot;小明&quot;), Arrays.asList(&quot;小明&quot;, &quot;小王&quot;), Arrays.asList(&quot;小明&quot;, &quot;小王&quot;, &quot;小李&quot;) ).stream().flatMap(va -&gt; va.stream().map(a -&gt; a + &quot;不打豆豆&quot;)).forEach(s -&gt; System.out.println(s + &quot;了&quot;)); 6.排序Arrays.asList(1, 2, 3).stream().sorted(Comparator.naturalOrder()) ; Arrays.asList(1, 2, 3).stream().sorted(Integer::compareTo) ; 7.截取(limit是截取前N个,skip是丢弃前N个)Arrays.asList(&quot;小明&quot;, &quot;小王&quot;, &quot;小李&quot;).stream().limit(2).forEach(System.out::print); Arrays.asList(&quot;小明&quot;, &quot;小王&quot;, &quot;小李&quot;).stream().skip(2).forEach(System.out::print); 8.组合 (组合的第一个参数代表截止条件,第二个代表依次处理数据的方法) 类似与python的reduce.只是传参的方式不一样.使用组合可以实现字符串连接,取最大值,最小值,排序..String reduce = Arrays.asList(&quot;小明&quot;, &quot;小王&quot;, &quot;小李&quot;).stream().reduce(&quot;&quot;, (v1, v2) -&gt; v1 + v2); Integer reduce = Arrays.asList(1, 2, 3).stream().reduce(Integer.MAX_VALUE, Integer::min); 附录:参考文档:链接地址 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 开发入门]]></title>
      <url>%2F2017%2F05%2F10%2FAndroid-%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
      <content type="text"><![CDATA[End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python 笔记]]></title>
      <url>%2F2017%2F04%2F13%2Fpython-%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[变量类型python 是弱类型语言.但其也有标准的类型. Numbers（12）String（’abc’）List（[1,2]）Tuple（(1,2)）Dictionary（{‘Michael’: 95, ‘Bob’: 75, ‘Tracy’: 85}）Set (([1, 2, 3])) 变量不需要定义,直接使用变量名进行赋值. 赋值指定格式就是相应的类型.Numbers 相当于java的int,short,long 合集.String 跟java的一样.List 一样Set 一样.Tuple 相当于数组Dict 相当于Map C# 也是dict. ps: python 是根据缩进来判断作用域的. 函数定义/调用定义函数12def functionA(X): return x*x ; 调用函数print(functionA(3)) ; 特性1.切片,取出list或者tuple中部分元素.L = [‘aaa’,’bbb’,’ccc’] 正序取:第一个是取出位置(包括该位置的元素),第二个是截止位置(不包括该位置的元素)取出第一个元素L[0:1]取出前2个元素:L[0:2]倒序取:第一个是倒序截止位置(包括),第二个倒序是开始取值位置(不包括).取出最后一个元素:L[-1]取出倒数第二个元素:L[-1:-2] 2.迭代.遍历对象for var in object 可以通过isinstance(checkObject, Iterable)来判断该对象是否可以进行迭代.不推荐使用(objct) is type(object1) 来进行类型检查是因为type不可靠.123456class A(): pass;class B(): pass;type(A) is type(B) ;&gt;&gt;&gt;True 遍历dict对象的keyfor key in dict 遍历dict对象的valuefor var in dict.valuse() 遍历key与valuefor k,v in dict.items() 遍历list的下标与值for i,v in enumerate(list) 3.构造器生成1,2,3…9的listrange(1,10)生成 1,4,9…81的 list[x*x for x in range(1,10)] 4.赋值可以同时多个赋值.a,b,c = 1,2,3 ; 高阶函数1.map /reduce python的map不同于java.. map 是对每个子元素进行函数运算.1234def f(x) : return x*x ;map(f,range(1,10)); 输出:[1,4,9,25,36,49,64,81] reduce 是对没两个元素进行操作.123def fx(x,y): return x*y +x+y ;reduce(fx,range(1,10)) ; 2.filter 过滤函数filter 是对每个元素进行检查,返回true的保留.返回false的删除.123456def ff(x): if (x &gt; 5): return true ; else: return false ;filter(ff,range(1,10)) ; 3.sorted 排序升序sorted([36, 5, -12, 9, -21])绝对值升序排序sorted([36, 5, -12, 9, -21],key=abs)忽略大小写升序排序sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower倒序sorted([36, 5, -12, 9, -21],reverse=true) 4.lambda表达式传入x,y 返回 xy`lambda x,y:xy` 5.装饰器装饰器是面向切面编程的概念,主要目的是对程序进行相同代码块的冗余去除. 定义装饰器:参数:args 称作为数组参数，*kwargs 称作为字典参数.表示可以传进来任意类型任意值.1234def log(func): def proxy_f(*args,**avg): return func(*args,**avg) ; return proxy_f ; 使用装饰器.在对应的函数前加上@log就可以.123456@logdef now(): print(&apos;2015-3-25&apos;) ;//调用now() ; 也可以这样使用装饰器now = log(now) 6.偏函数目的:把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单.123456&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2(&apos;1000000&apos;)64&gt;&gt;&gt; int2(&apos;1010101&apos;)85 模块1.概述python 的模块有点类似于java的包–类这样的结构.一个python文件相当于一个模块.不同模块的函数名可以相同.单不要与内置的函数名重名.模块名之外,是包名,类似于java.不过包名目录必须有init.py这个文件. 2.使用模块导入模块 (模块名不含.py,跟java引入类一样,不含.class)import model_name 2.使用模块(模块名.函数名来调用相应模块的函数.)model_name.func_name 3.使用pip工具安装模块pip install 模块名 4.模块搜索路径123import syssys.path 5.添加自定义的搜索路径添加环境变量:PYTHONPATH 面向对象 类/对象(实例)与一般面向对象语言定义基本一致. 2.区别(下划线都是两个)可以不定义成员属性,直接使用self.XX来赋值.也可以定义一个默认的成员属性.也可以在实例化后定义…初始化构造器(连续两个下划线):def __init__ (paramter1,...) 以XX 定义的方法(函数)是特殊函数方法.例如:init以__XX定义的成员变量/方法(函数) 是私有的(private).不能被外部访问.以_XX定义的变量/方法 外部不应该去访问它.但实际是可以访问到的. 不能通过实例.__XX 来对私有变量进行赋值.这样赋值是赋值给一个新的变量,而非该实例的内部成员变量.这样是错误代码:123456&gt;&gt;&gt; bart = Student(&apos;Bart Simpson&apos;, 98)&gt;&gt;&gt; bart.get_name()&apos;Bart Simpson&apos;&gt;&gt;&gt; bart.__name = &apos;New Name&apos; # 设置__name变量！&gt;&gt;&gt; bart.__name&apos;New Name&apos; 3.继承与多态继承父类,覆写父类方法.符合李氏替换原则.遵循多态. 对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。 对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了： 4.成员属性限制:__slots__ = (&#39;name&#39;, &#39;age&#39;) # 用tuple定义允许绑定的属性名称 IO 编程 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java AIO NIO BIO]]></title>
      <url>%2F2017%2F04%2F10%2Fjava-AIO-NIO-BIO%2F</url>
      <content type="text"><![CDATA[AIO NIO BIO 概念AIO 异步非阻塞读写. NIO 非阻塞读写. BIO 阻塞读写. 同步与异步:表示目的. 阻塞与非阻塞:实现(同步/异步)方式. AIO 的异步非阻塞,是指的执行IO的线程异步.一个请求一个线程. NIO 查询IO时候非阻塞.使用IO时候阻塞. BIO 查询IO阻塞,执行IO时候阻塞. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sql 中 Where与Having的区别]]></title>
      <url>%2F2017%2F04%2F01%2Fsql-%E4%B8%AD-Where%E4%B8%8EHaving%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[关于Where与having的原理Where 的原理是根据条件去检索.Having 是根据条件从检索到的内容中根据条件来筛选. 使用场景能使用Where的尽量使用Where.虽然都是遍历.不过机制上来说,前置速度会快些. 但是涉及一些结果处理来筛选的时候.例如:两列的值相减大于某个数的行.SELECT *,(t.c1-t.c2) as tt FROM for_pan_test.new_table t having tt &gt;0; SELECT *,(t.c1-t.c2) as tt FROM for_pan_test.new_table t where (t.c1-t.c2) &gt;0; 这样都可以的.但是如果出现聚合,那就必须使用having了.因为在聚合之前,是不知道该值的(SQL92 标准不支持该查询.SQL99之后支持如果出现sql_model=only_full_group_by.disable该模式 详见). SELECT *,(sum(t.c1)-t.c2) as tt FROM for_pan_test.new_table t group by t.s1 having tt &gt;0; 这时候使用where的结果就行了.SELECT *,(sum(t.c1)-t.c2) as tt FROM for_pan_test.new_table t where (t.c1-t.c2) &gt;0 group by s1; End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jarsigner 签名]]></title>
      <url>%2F2017%2F03%2F31%2Fjarsigner-%E7%AD%BE%E5%90%8D%2F</url>
      <content type="text"><![CDATA[概要 要生成密钥(私钥/公钥/证书) 需要有相应的密钥库.而证书是保存公钥的一些信息. 命令 生成密钥库keytool -genkey -alias serverkey -keystore keyserver.keystorejarsigner -genkey -alias serverkey -keystore keyserver.keystore 导出证书keytool -export -alias serverkey -keystore keyserver.keystore -file server.crtjarsigner -export -alias serverkey -keystore keyserver.keystore -file server.crt 3.密钥库信任指定的证书keytool -import -alias serverkey -file server.crt -keystore tclient.keystore tclient.keystorejarsigner -import -alias serverkey -file server.crt -keystore tclient.keystore tclient.keystore 4.签名appjarsigner -verbose -keystore reaper.keystore -signedjar test_signed.apk test_unsign.apk reaper-verbose：输出详细信息-keystore：密钥库位置-signedjar：后面跟了3个参数：签名成功的apk的名字，等待签名的apk，生成签名的文件名 说明 密钥库相对于保存密钥的数据库.证书相当于公钥以及一些信息.证书一般式由机构来颁发.这样,客户端解析时候.会显示可信网站.当然,服务器之间的通信可能是双方相互制作传递给对方. 公钥用于客户端加密数据,揭秘需要私钥.公钥是不能用于解密的.非对称摘要算法.如果是对称摘要算法.那就是只有私钥.这样不是很安全.因为客户端可能会泄露. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTPS 认证模型]]></title>
      <url>%2F2017%2F03%2F31%2FHTTPS-%E8%AE%A4%E8%AF%81%E6%A8%A1%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[协议模型: 第一步(客户端/服务器的证书,随机数,算法,协议交换): 客户端产生随机数RNC 客户端发送客户端的证书,协议(SSL/TLS),算法信息,RNC给服务器. 服务断接收到请求,产生服务端的随机数RNS 服务端回复服务器的证书,协议(SSL/TLS),算法信息,RNS给客户. 第二步(客户端/服务器向认证机构校验证书信息): 客户端向第三方/本地信任库认证接收到的服务器证书信息. 服务器断向第三方/本地信任库校验客户端的证书信息 第三步(生成主密钥 Primary Master Secret): 客户端产生随机数PMS. 客户端根据协议(SSL/TLS),服务器的证书公钥生成加密过的PMS. 客户端向服务器发送加密过的PMS. 服务器与接收加密过的PMS,并根据服务器的证书私钥解密出PMS. 客户端与服务端保存公共私钥(RNC+RNS+PMS)作为共同的私钥. 第四步(会话密钥确认): 客户端通过PMS产生会话密钥. 客户端数据使用会话密钥加密发送给服务器. 服务器使用PMS产生对应的密钥. 服务使用会话密钥解密接收到的数据. 服务器发送确认信息给客户端. 终止握手. 第五步(正式会话): 客户端数据使用会话密钥加密 发送给服务端. 服务端接收数据使用相同的会话密钥解密出数据. 服务器使用会话密钥加密数据发送给客户端 客户端使用会话密钥解密出对应数据. 只要这5步中有一步校验异常,都会重新握手. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符编码解码以及内存储存]]></title>
      <url>%2F2017%2F03%2F27%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E5%82%A8%E5%AD%98%2F</url>
      <content type="text"><![CDATA[编码(encode)因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理,将字符–&gt;数字 称之为编码.反之为解码. ASCII : 美国指定的编码标准.只有大小写字母/数字/部分符号(字符占1个字节,不支持中文) GB2312 : 国标 (所有字符占两个字节) UNICODE : 国际通用标准.(所有字符占两个字节) UTF-8 : 国际通用标准的缩小版(字母只占一个字节) 解码(decode)将编码的数字,还原成对相应的字符数组.称之为解码. python中ord(‘’) ; 将字符串解析为编码之后的数字 chr() ; 将数字解析为对应的字符 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java Excel POI 使用]]></title>
      <url>%2F2017%2F03%2F24%2FJava-Excel-POI-%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[依赖的jar1234567891011121314151617&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.15&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.15&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml-schemas --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt; &lt;version&gt;3.15&lt;/version&gt;&lt;/dependency&gt; 对应的操作对象简介1.HSSFWorkbook 读取/写入.xls文件 2.XSSFWorkbook 读写 .xlsx文件 3.SXSSFWorkbook 读取/写入.xls 与.xlsx 简要使用1.读取操作顺序: 1&gt; 将需要读取的文件/流 传入,产生对应的Workbook对象. 2&gt; 取出每个sheet.根据行列数遍历取值2.写入操作顺序: 1&gt; 使用new Workbook()产生新的工作薄对象. 2&gt; 创建相应的sheet并插入数据. 3&gt; 使用workbook.writ(流)的方法,写出数据. 4&gt; 关闭流,关闭workbook. 示例代码1.HSSFWorkbook 写入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140// create a new fileFileOutputStream out = new FileOutputStream(&quot;workbook.xls&quot;);// create a new workbookWorkbook wb = new HSSFWorkbook();// create a new sheetSheet s = wb.createSheet();// declare a row object referenceRow r = null;// declare a cell object referenceCell c = null;// create 3 cell stylesCellStyle cs = wb.createCellStyle();CellStyle cs2 = wb.createCellStyle();CellStyle cs3 = wb.createCellStyle();DataFormat df = wb.createDataFormat();// create 2 fonts objectsFont f = wb.createFont();Font f2 = wb.createFont();//set font 1 to 12 point typef.setFontHeightInPoints((short) 12);//make it bluef.setColor( (short)0xc );// make it bold//arial is the default fontf.setBoldweight(Font.BOLDWEIGHT_BOLD);//set font 2 to 10 point typef2.setFontHeightInPoints((short) 10);//make it redf2.setColor( (short)Font.COLOR_RED );//make it boldf2.setBoldweight(Font.BOLDWEIGHT_BOLD);f2.setStrikeout( true );//set cell stlyecs.setFont(f);//set the cell format cs.setDataFormat(df.getFormat(&quot;#,##0.0&quot;));//set a thin bordercs2.setBorderBottom(cs2.BORDER_THIN);//fill w fg fill colorcs2.setFillPattern((short) CellStyle.SOLID_FOREGROUND);//set the cell format to text see DataFormat for a full listcs2.setDataFormat(HSSFDataFormat.getBuiltinFormat(&quot;text&quot;));// set the fontcs2.setFont(f2);// set the sheet name in Unicodewb.setSheetName(0, &quot;\u0422\u0435\u0441\u0442\u043E\u0432\u0430\u044F &quot; + &quot;\u0421\u0442\u0440\u0430\u043D\u0438\u0447\u043A\u0430&quot; );// in case of plain ascii// wb.setSheetName(0, &quot;HSSF Test&quot;);// create a sheet with 30 rows (0-29)int rownum;for (rownum = (short) 0; rownum &lt; 30; rownum++)&#123; // create a row r = s.createRow(rownum); // on every other row if ((rownum % 2) == 0) &#123; // make the row height bigger (in twips - 1/20 of a point) r.setHeight((short) 0x249); &#125; //r.setRowNum(( short ) rownum); // create 10 cells (0-9) (the += 2 becomes apparent later for (short cellnum = (short) 0; cellnum &lt; 10; cellnum += 2) &#123; // create a numeric cell c = r.createCell(cellnum); // do some goofy math to demonstrate decimals c.setCellValue(rownum * 10000 + cellnum + (((double) rownum / 1000) + ((double) cellnum / 10000))); String cellValue; // create a string cell (see why += 2 in the c = r.createCell((short) (cellnum + 1)); // on every other row if ((rownum % 2) == 0) &#123; // set this cell to the first cell style we defined c.setCellStyle(cs); // set the cell&apos;s string value to &quot;Test&quot; c.setCellValue( &quot;Test&quot; ); &#125; else &#123; c.setCellStyle(cs2); // set the cell&apos;s string value to &quot;\u0422\u0435\u0441\u0442&quot; c.setCellValue( &quot;\u0422\u0435\u0441\u0442&quot; ); &#125; // make this column a bit wider s.setColumnWidth((short) (cellnum + 1), (short) ((50 * 8) / ((double) 1 / 20))); &#125;&#125;//draw a thick black border on the row at the bottom using BLANKS// advance 2 rowsrownum++;rownum++;r = s.createRow(rownum);// define the third style to be the default// except with a thick black border at the bottomcs3.setBorderBottom(cs3.BORDER_THICK);//create 50 cellsfor (short cellnum = (short) 0; cellnum &lt; 50; cellnum++)&#123; //create a blank type cell (no value) c = r.createCell(cellnum); // set it to the thick black border style c.setCellStyle(cs3);&#125;//end draw thick black border// demonstrate adding/naming and deleting a sheet// create a sheet, set its title then delete its = wb.createSheet();wb.setSheetName(1, &quot;DeletedSheet&quot;);wb.removeSheetAt(1);//end deleted sheet// write the workbook to the output stream// close our file (don&apos;t blow out our file handleswb.write(out);out.close(); 2.HSSFWorkbook读取/修改.xls123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269package org.apache.poi.hssf.usermodel.examples;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.util.Locale;import org.apache.poi.hssf.usermodel.HSSFCell;import org.apache.poi.hssf.usermodel.HSSFCellStyle;import org.apache.poi.hssf.usermodel.HSSFDataFormat;import org.apache.poi.hssf.usermodel.HSSFFont;import org.apache.poi.hssf.usermodel.HSSFRichTextString;import org.apache.poi.hssf.usermodel.HSSFRow;import org.apache.poi.hssf.usermodel.HSSFSheet;import org.apache.poi.hssf.usermodel.HSSFWorkbook;import org.apache.poi.ss.usermodel.BorderStyle;import org.apache.poi.ss.usermodel.FillPatternType;import org.apache.poi.ss.util.CellRangeAddress;/** * File for HSSF testing/examples * * THIS IS NOT THE MAIN HSSF FILE!! This is a utility for testing functionality. * It does contain sample API usage that may be educational to regular API * users. */public final class HSSFReadWrite &#123; /** * creates an &#123;@link HSSFWorkbook&#125; with the specified OS filename. */ private static HSSFWorkbook readFile(String filename) throws IOException &#123; FileInputStream fis = new FileInputStream(filename); try &#123; return new HSSFWorkbook(fis); // NOSONAR - should not be closed here &#125; finally &#123; fis.close(); &#125; &#125; /** * given a filename this outputs a sample sheet with just a set of * rows/cells. */ private static void testCreateSampleSheet(String outputFilename) throws IOException &#123; HSSFWorkbook wb = new HSSFWorkbook(); try &#123; HSSFSheet s = wb.createSheet(); HSSFCellStyle cs = wb.createCellStyle(); HSSFCellStyle cs2 = wb.createCellStyle(); HSSFCellStyle cs3 = wb.createCellStyle(); HSSFFont f = wb.createFont(); HSSFFont f2 = wb.createFont(); f.setFontHeightInPoints((short) 12); f.setColor((short) 0xA); f.setBold(true); f2.setFontHeightInPoints((short) 10); f2.setColor((short) 0xf); f2.setBold(true); cs.setFont(f); cs.setDataFormat(HSSFDataFormat.getBuiltinFormat(&quot;($#,##0_);[Red]($#,##0)&quot;)); cs2.setBorderBottom(BorderStyle.THIN); cs2.setFillPattern(FillPatternType.SOLID_FOREGROUND); cs2.setFillForegroundColor((short) 0xA); cs2.setFont(f2); wb.setSheetName(0, &quot;HSSF Test&quot;); int rownum; for (rownum = 0; rownum &lt; 300; rownum++) &#123; HSSFRow r = s.createRow(rownum); if ((rownum % 2) == 0) &#123; r.setHeight((short) 0x249); &#125; for (int cellnum = 0; cellnum &lt; 50; cellnum += 2) &#123; HSSFCell c = r.createCell(cellnum); c.setCellValue(rownum * 10000 + cellnum + (((double) rownum / 1000) + ((double) cellnum / 10000))); if ((rownum % 2) == 0) &#123; c.setCellStyle(cs); &#125; c = r.createCell(cellnum + 1); c.setCellValue(new HSSFRichTextString(&quot;TEST&quot;)); // 50 characters divided by 1/20th of a point s.setColumnWidth(cellnum + 1, (int) (50 * 8 / 0.05)); if ((rownum % 2) == 0) &#123; c.setCellStyle(cs2); &#125; &#125; &#125; // draw a thick black border on the row at the bottom using BLANKS rownum++; rownum++; HSSFRow r = s.createRow(rownum); cs3.setBorderBottom(BorderStyle.THICK); for (int cellnum = 0; cellnum &lt; 50; cellnum++) &#123; HSSFCell c = r.createCell(cellnum); c.setCellStyle(cs3); &#125; s.addMergedRegion(new CellRangeAddress(0, 3, 0, 3)); s.addMergedRegion(new CellRangeAddress(100, 110, 100, 110)); // end draw thick black border // create a sheet, set its title then delete it wb.createSheet(); wb.setSheetName(1, &quot;DeletedSheet&quot;); wb.removeSheetAt(1); // end deleted sheet FileOutputStream out = new FileOutputStream(outputFilename); try &#123; wb.write(out); &#125; finally &#123; out.close(); &#125; &#125; finally &#123; wb.close(); &#125; &#125; /** * Method main * * Given 1 argument takes that as the filename, inputs it and dumps the * cell values/types out to sys.out.&lt;br/&gt; * * given 2 arguments where the second argument is the word &quot;write&quot; and the * first is the filename - writes out a sample (test) spreadsheet * see &#123;@link HSSFReadWrite#testCreateSampleSheet(String)&#125;.&lt;br/&gt; * * given 2 arguments where the first is an input filename and the second * an output filename (not write), attempts to fully read in the * spreadsheet and fully write it out.&lt;br/&gt; * * given 3 arguments where the first is an input filename and the second an * output filename (not write) and the third is &quot;modify1&quot;, attempts to read in the * spreadsheet, deletes rows 0-24, 74-99. Changes cell at row 39, col 3 to * &quot;MODIFIED CELL&quot; then writes it out. Hence this is &quot;modify test 1&quot;. If you * take the output from the write test, you&apos;ll have a valid scenario. */ public static void main(String[] args) &#123; if (args.length &lt; 1) &#123; System.err.println(&quot;At least one argument expected&quot;); return; &#125; String fileName = args[0]; try &#123; if (args.length &lt; 2) &#123; HSSFWorkbook wb = HSSFReadWrite.readFile(fileName); try &#123; System.out.println(&quot;Data dump:\n&quot;); for (int k = 0; k &lt; wb.getNumberOfSheets(); k++) &#123; HSSFSheet sheet = wb.getSheetAt(k); int rows = sheet.getPhysicalNumberOfRows(); System.out.println(&quot;Sheet &quot; + k + &quot; \&quot;&quot; + wb.getSheetName(k) + &quot;\&quot; has &quot; + rows + &quot; row(s).&quot;); for (int r = 0; r &lt; rows; r++) &#123; HSSFRow row = sheet.getRow(r); if (row == null) &#123; continue; &#125; System.out.println(&quot;\nROW &quot; + row.getRowNum() + &quot; has &quot; + row.getPhysicalNumberOfCells() + &quot; cell(s).&quot;); for (int c = 0; c &lt; row.getLastCellNum(); c++) &#123; HSSFCell cell = row.getCell(c); String value; if(cell != null) &#123; switch (cell.getCellTypeEnum()) &#123; case FORMULA: value = &quot;FORMULA value=&quot; + cell.getCellFormula(); break; case NUMERIC: value = &quot;NUMERIC value=&quot; + cell.getNumericCellValue(); break; case STRING: value = &quot;STRING value=&quot; + cell.getStringCellValue(); break; case BLANK: value = &quot;&lt;BLANK&gt;&quot;; break; case BOOLEAN: value = &quot;BOOLEAN value-&quot; + cell.getBooleanCellValue(); break; case ERROR: value = &quot;ERROR value=&quot; + cell.getErrorCellValue(); break; default: value = &quot;UNKNOWN value of type &quot; + cell.getCellTypeEnum(); &#125; System.out.println(&quot;CELL col=&quot; + cell.getColumnIndex() + &quot; VALUE=&quot; + value); &#125; &#125; &#125; &#125; &#125; finally &#123; wb.close(); &#125; &#125; else if (args.length == 2) &#123; if (args[1].toLowerCase(Locale.ROOT).equals(&quot;write&quot;)) &#123; System.out.println(&quot;Write mode&quot;); long time = System.currentTimeMillis(); HSSFReadWrite.testCreateSampleSheet(fileName); System.out.println(&quot;&quot; + (System.currentTimeMillis() - time) + &quot; ms generation time&quot;); &#125; else &#123; System.out.println(&quot;readwrite test&quot;); HSSFWorkbook wb = HSSFReadWrite.readFile(fileName); try &#123; FileOutputStream stream = new FileOutputStream(args[1]); try &#123; wb.write(stream); &#125; finally &#123; stream.close(); &#125; &#125; finally &#123; wb.close(); &#125; &#125; &#125; else if (args.length == 3 &amp;&amp; args[2].equalsIgnoreCase(&quot;modify1&quot;)) &#123; // delete row 0-24, row 74 - 99 &amp;&amp; change cell 3 on row 39 to string &quot;MODIFIED CELL!!&quot; HSSFWorkbook wb = HSSFReadWrite.readFile(fileName); try &#123; HSSFSheet sheet = wb.getSheetAt(0); for (int k = 0; k &lt; 25; k++) &#123; HSSFRow row = sheet.getRow(k); sheet.removeRow(row); &#125; for (int k = 74; k &lt; 100; k++) &#123; HSSFRow row = sheet.getRow(k); sheet.removeRow(row); &#125; HSSFRow row = sheet.getRow(39); HSSFCell cell = row.getCell(3); cell.setCellValue(&quot;MODIFIED CELL!!!!!&quot;); FileOutputStream stream = new FileOutputStream(args[1]); try &#123; wb.write(stream); &#125; finally &#123; stream.close(); &#125; &#125; finally &#123; wb.close(); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; HSSFWorkbook不使用SAX 来解析例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * This example shows how to use the event API for reading a file. */public class EventExample implements HSSFListener&#123; private SSTRecord sstrec; /** * This method listens for incoming records and handles them as required. * @param record The record that was found while reading. */ public void processRecord(Record record) &#123; switch (record.getSid()) &#123; // the BOFRecord can represent either the beginning of a sheet or the workbook case BOFRecord.sid: BOFRecord bof = (BOFRecord) record; if (bof.getType() == bof.TYPE_WORKBOOK) &#123; System.out.println(&quot;Encountered workbook&quot;); // assigned to the class level member &#125; else if (bof.getType() == bof.TYPE_WORKSHEET) &#123; System.out.println(&quot;Encountered sheet reference&quot;); &#125; break; case BoundSheetRecord.sid: BoundSheetRecord bsr = (BoundSheetRecord) record; System.out.println(&quot;New sheet named: &quot; + bsr.getSheetname()); break; case RowRecord.sid: RowRecord rowrec = (RowRecord) record; System.out.println(&quot;Row found, first column at &quot; + rowrec.getFirstCol() + &quot; last column at &quot; + rowrec.getLastCol()); break; case NumberRecord.sid: NumberRecord numrec = (NumberRecord) record; System.out.println(&quot;Cell found with value &quot; + numrec.getValue() + &quot; at row &quot; + numrec.getRow() + &quot; and column &quot; + numrec.getColumn()); break; // SSTRecords store a array of unique strings used in Excel. case SSTRecord.sid: sstrec = (SSTRecord) record; for (int k = 0; k &lt; sstrec.getNumUniqueStrings(); k++) &#123; System.out.println(&quot;String table value &quot; + k + &quot; = &quot; + sstrec.getString(k)); &#125; break; case LabelSSTRecord.sid: LabelSSTRecord lrec = (LabelSSTRecord) record; System.out.println(&quot;String cell found with value &quot; + sstrec.getString(lrec.getSSTIndex())); break; &#125; &#125; /** * Read an excel file and spit out what we find. * * @param args Expect one argument that is the file to read. * @throws IOException When there is an error processing the file. */ public static void main(String[] args) throws IOException &#123; // create a new file input stream with the input file specified // at the command line FileInputStream fin = new FileInputStream(args[0]); // create a new org.apache.poi.poifs.filesystem.Filesystem POIFSFileSystem poifs = new POIFSFileSystem(fin); // get the Workbook (excel part) stream in a InputStream InputStream din = poifs.createDocumentInputStream(&quot;Workbook&quot;); // construct out HSSFRequest object HSSFRequest req = new HSSFRequest(); // lazy listen for ALL records with the listener shown above req.addListenerForAllRecords(new EventExample()); // create our event factory HSSFEventFactory factory = new HSSFEventFactory(); // process our events based on the document input stream factory.processEvents(req, din); // once all the events are processed close our file input stream fin.close(); // and our document input stream (don&apos;t want to leak these!) din.close(); System.out.println(&quot;done.&quot;); &#125;&#125; XSSFWorkbook使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import java.io.InputStream;import java.util.Iterator;import org.apache.poi.xssf.eventusermodel.XSSFReader;import org.apache.poi.xssf.model.SharedStringsTable;import org.apache.poi.openxml4j.opc.OPCPackage;import org.xml.sax.Attributes;import org.xml.sax.ContentHandler;import org.xml.sax.InputSource;import org.xml.sax.SAXException;import org.xml.sax.XMLReader;import org.xml.sax.helpers.DefaultHandler;import org.xml.sax.helpers.XMLReaderFactory;public class ExampleEventUserModel &#123; public void processOneSheet(String filename) throws Exception &#123; OPCPackage pkg = OPCPackage.open(filename); XSSFReader r = new XSSFReader( pkg ); SharedStringsTable sst = r.getSharedStringsTable(); XMLReader parser = fetchSheetParser(sst); // To look up the Sheet Name / Sheet Order / rID, // you need to process the core Workbook stream. // Normally it&apos;s of the form rId# or rSheet# InputStream sheet2 = r.getSheet(&quot;rId2&quot;); InputSource sheetSource = new InputSource(sheet2); parser.parse(sheetSource); sheet2.close(); &#125; public void processAllSheets(String filename) throws Exception &#123; OPCPackage pkg = OPCPackage.open(filename); XSSFReader r = new XSSFReader( pkg ); SharedStringsTable sst = r.getSharedStringsTable(); XMLReader parser = fetchSheetParser(sst); Iterator&lt;InputStream&gt; sheets = r.getSheetsData(); while(sheets.hasNext()) &#123; System.out.println(&quot;Processing new sheet:\n&quot;); InputStream sheet = sheets.next(); InputSource sheetSource = new InputSource(sheet); parser.parse(sheetSource); sheet.close(); System.out.println(&quot;&quot;); &#125; &#125; public XMLReader fetchSheetParser(SharedStringsTable sst) throws SAXException &#123; XMLReader parser = XMLReaderFactory.createXMLReader( &quot;org.apache.xerces.parsers.SAXParser&quot; ); ContentHandler handler = new SheetHandler(sst); parser.setContentHandler(handler); return parser; &#125; /** * See org.xml.sax.helpers.DefaultHandler javadocs */ private static class SheetHandler extends DefaultHandler &#123; private SharedStringsTable sst; private String lastContents; private boolean nextIsString; private SheetHandler(SharedStringsTable sst) &#123; this.sst = sst; &#125; public void startElement(String uri, String localName, String name, Attributes attributes) throws SAXException &#123; // c =&gt; cell if(name.equals(&quot;c&quot;)) &#123; // Print the cell reference System.out.print(attributes.getValue(&quot;r&quot;) + &quot; - &quot;); // Figure out if the value is an index in the SST String cellType = attributes.getValue(&quot;t&quot;); if(cellType != null &amp;&amp; cellType.equals(&quot;s&quot;)) &#123; nextIsString = true; &#125; else &#123; nextIsString = false; &#125; &#125; // Clear contents cache lastContents = &quot;&quot;; &#125; public void endElement(String uri, String localName, String name) throws SAXException &#123; // Process the last contents as required. // Do now, as characters() may be called more than once if(nextIsString) &#123; int idx = Integer.parseInt(lastContents); lastContents = new XSSFRichTextString(sst.getEntryAt(idx)).toString(); nextIsString = false; &#125; // v =&gt; contents of a cell // Output after we&apos;ve seen the string contents if(name.equals(&quot;v&quot;)) &#123; System.out.println(lastContents); &#125; &#125; public void characters(char[] ch, int start, int length) throws SAXException &#123; lastContents += new String(ch, start, length); &#125; &#125; public static void main(String[] args) throws Exception &#123; ExampleEventUserModel example = new ExampleEventUserModel(); example.processOneSheet(args[0]); example.processAllSheets(args[0]); &#125;&#125; 5.SXSSFWorkbook 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import junit.framework.Assert;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.usermodel.Sheet;import org.apache.poi.ss.usermodel.Workbook;import org.apache.poi.ss.util.CellReference;import org.apache.poi.xssf.streaming.SXSSFWorkbook; public static void main(String[] args) throws Throwable &#123; SXSSFWorkbook wb = new SXSSFWorkbook(100); // keep 100 rows in memory, exceeding rows will be flushed to disk Sheet sh = wb.createSheet(); for(int rownum = 0; rownum &lt; 1000; rownum++)&#123; Row row = sh.createRow(rownum); for(int cellnum = 0; cellnum &lt; 10; cellnum++)&#123; Cell cell = row.createCell(cellnum); String address = new CellReference(cell).formatAsString(); cell.setCellValue(address); &#125; &#125; // Rows with rownum &lt; 900 are flushed and not accessible for(int rownum = 0; rownum &lt; 900; rownum++)&#123; Assert.assertNull(sh.getRow(rownum)); &#125; // ther last 100 rows are still in memory for(int rownum = 900; rownum &lt; 1000; rownum++)&#123; Assert.assertNotNull(sh.getRow(rownum)); &#125; FileOutputStream out = new FileOutputStream(&quot;/temp/sxssf.xlsx&quot;); wb.write(out); out.close(); // dispose of temporary files backing this workbook on disk wb.dispose(); &#125;The next example turns off auto-flushing (windowSize=-1) and the code manually controls how portions of data are written to diskimport org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.usermodel.Sheet;import org.apache.poi.ss.usermodel.Workbook;import org.apache.poi.ss.util.CellReference;import org.apache.poi.xssf.streaming.SXSSFWorkbook; public static void main(String[] args) throws Throwable &#123; SXSSFWorkbook wb = new SXSSFWorkbook(-1); // turn off auto-flushing and accumulate all rows in memory Sheet sh = wb.createSheet(); for(int rownum = 0; rownum &lt; 1000; rownum++)&#123; Row row = sh.createRow(rownum); for(int cellnum = 0; cellnum &lt; 10; cellnum++)&#123; Cell cell = row.createCell(cellnum); String address = new CellReference(cell).formatAsString(); cell.setCellValue(address); &#125; // manually control how rows are flushed to disk if(rownum % 100 == 0) &#123; ((SXSSFSheet)sh).flushRows(100); // retain 100 last rows and flush all others // ((SXSSFSheet)sh).flushRows() is a shortcut for ((SXSSFSheet)sh).flushRows(0), // this method flushes all rows &#125; &#125; FileOutputStream out = new FileOutputStream(&quot;/temp/sxssf.xlsx&quot;); wb.write(out); out.close(); // dispose of temporary files backing this workbook on disk wb.dispose(); &#125; End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于Sprintg注解与配置文件产生的bean]]></title>
      <url>%2F2017%2F03%2F22%2F%E5%85%B3%E4%BA%8ESprintg%E6%B3%A8%E8%A7%A3%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BA%A7%E7%94%9F%E7%9A%84bean%2F</url>
      <content type="text"><![CDATA[bean 的创建有XML与注解最近忘了这坑壁事情了.如果是配置生成的bean.里面的对象又是用注解注入的话.必须用扫描. 不然只有配置该bean的时候,去手动配置该bean. 之前遇到过,忘记了.现在又遇到了.搞了一天…郁闷. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[定时任务调度]]></title>
      <url>%2F2017%2F03%2F16%2F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%2F</url>
      <content type="text"><![CDATA[定时任务使用的方法1.最原始的使用java提供的延迟循环队列.2.使用Quartz提供的方法.3.使用spring提供的调度器. 使用循环延迟队列.123ScheduledExecutorService executorService = Executors.newScheduledThreadPool(10);//启动延迟,初始化延迟,多久执行一次.executorService.scheduleWithFixedDelay(new Runable(), 0, 9, TimeUnit.HOURS); 使用Quartz调度1.引入依赖或者Jar包123456&lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt;&lt;/dependency&gt; 2.配置执行参数12345678&lt;!--配置启动的bean,task以及执行的方法--&gt;&lt;bean id=&quot;job&quot; class=&quot; xx.xx.xx.Job&quot; /&gt;&lt;bean id=&quot;cronTask&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt; &lt;property name=&quot;targetObject&quot; ref=&quot;job&quot; /&gt; &lt;property name=&quot;targetMethod&quot; value=&quot;runWork&quot; /&gt; &lt;!-- false表示job不会并发执行，默认为true--&gt; &lt;property name=&quot;concurrent&quot; value=&quot;false&quot; /&gt;&lt;/bean&gt; 2.接下来配置触发器12345&lt;bean id=&quot;doWork&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerBean&quot;&gt; &lt;property name=&quot;jobDetail&quot; ref=&quot;cronTask&quot; /&gt; &lt;!—每天凌晨0点1分执行--&gt; &lt;property name=&quot;cronExpression&quot; value=&quot;0 01 00 * * ?&quot; /&gt;&lt;/bean&gt; 3.最后配置调度工厂12345678&lt;bean class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt; &lt;property name=&quot;triggers&quot;&gt; &lt;list&gt; &lt;!--调度多个任务--&gt; &lt;ref local=&quot;doWork&quot;/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 使用spring task来调度1.添加相应的命名空间123456&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; ...... xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xsi:schemaLocation=&quot; ...... http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.0.xsd&quot;&gt; 2.task 线程池配置123&lt;task:executor id=&quot;executor&quot; pool-size=&quot;5&quot; /&gt;&lt;task:scheduler id=&quot;scheduler&quot; pool-size=&quot;5&quot; /&gt;&lt;task:annotation-driven executor=&quot;executor&quot; scheduler=&quot;scheduler&quot; /&gt; 3.task配置,以及调度时间配置1234&lt;bean name = &quot;myTask&quot; class = &quot;xxx.xxx.MyTask&quot; /&gt;&lt;task:scheduled-tasks scheduler=&quot;reportTaskScheduler&quot; &gt; &lt;task:scheduled ref=&quot;myTask&quot; method=&quot;doTask&quot; cron=&quot;0/5 * * * * ?&quot; /&gt;&lt;/task:scheduled-tasks&gt; 总结1.方法一如果要采用Spring来启动的话.就需要实现Spring的初始化Bean的接口(InitializingBean).在初始化之后,调用该任务的延迟队列.2.Quartz与Spring的 Task的区别是一个可以异步,一个只能同步.3.Spring 与Quartz的时间配置都是采用cron表达式. 附录Cron表达式1234567891011121314151617181920212223242526“0/10 * * * * ?” 每10秒触发 “0 0 12 * * ?” 每天中午12点触发 “0 15 10 ? * *” 每天上午10:15触发 “0 15 10 * * ?” 每天上午10:15触发 “0 15 10 * * ? *” 每天上午10:15触发 “0 15 10 * * ? 2005” 2005年的每天上午10:15触发 “0 * 14 * * ?” 在每天下午2点到下午2:59期间的每1分钟触发 “0 0/5 14 * * ?” 在每天下午2点到下午2:55期间的每5分钟触发 “0 0/5 14,18 * * ?” 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 “0 0-5 14 * * ?” 在每天下午2点到下午2:05期间的每1分钟触发 “0 10,44 14 ? 3 WED” 每年三月的星期三的下午2:10和2:44触发 “0 15 10 ? * MON-FRI” 周一至周五的上午10:15触发 “0 15 10 15 * ?” 每月15日上午10:15触发 “0 15 10 L * ?” 每月最后一日的上午10:15触发 “0 15 10 ? * 6L” 每月的最后一个星期五上午10:15触发 “0 15 10 ? * 6L 2002-2005” 2002年至2005年的每月的最后一个星期五上午10:15触发 “0 15 10 ? * 6#3” 每月的第三个星期五上午10:15触发 每隔5秒执行一次：/5 * * * ? 每隔1分钟执行一次：0 /1 * * ? 每天23点执行一次：0 0 23 * * ? 每天凌晨1点执行一次：0 0 1 * * ? 每月1号凌晨1点执行一次：0 0 1 1 * ? 每月最后一天23点执行一次：0 0 23 L * ? 每周星期天凌晨1点实行一次：0 0 1 ? * L 在26分、29分、33分执行一次：0 26,29,33 * * * ? 每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ? End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[windows 下新建wifi热点]]></title>
      <url>%2F2017%2F03%2F15%2Fwindows-%E4%B8%8B%E6%96%B0%E5%BB%BAwifi%E7%83%AD%E7%82%B9%2F</url>
      <content type="text"><![CDATA[查看无线网卡是否支持Wifi热点 打开命令提示符:netsh wlan show drivers 设置Wifi名/密码 打开命令提示符:netsh wlan set hostednetwork mode=allow ssid=wifi名称 key=wifi密码 启动设置好的热点 打开命令提示符:netsh wlan start hostednetwork 关闭热点 打开命令提示符:netsh wlan stop hostednetwork 最后需要把能访问到互联网的链接共享给这个wifi热点控制面板–&gt;网络共享中心–&gt;属性–&gt;共享 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浏览器劫持启动页清除]]></title>
      <url>%2F2017%2F03%2F13%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%AB%E6%8C%81%E5%90%AF%E5%8A%A8%E9%A1%B5%E6%B8%85%E9%99%A4%2F</url>
      <content type="text"><![CDATA[主页劫持与启动劫持 启动劫持是主页明明是自己设定好的.但是启动的时候就是广告页面. 主页劫持是主页修改不了,或者修改了又自动变回来.查看启动劫持.找到浏览器快捷方式,右键属性.在目标一栏后面会多出一个链接地址.这就是启动的时候都会去运行这个链接.清除 简单的直接删除快捷方式—&gt;属性–&gt;目标后面的网址.2.如果修改之后,一段时间有自动变回来.一般式监听脚本引起的.开始–运行–wbemtest–连接–”root\subscription”–查询–”select from __EventFilter“–应用–选择_EventFilter:Name=”unown_filter”删除之–关闭–查询–”select from ActiveScriptEventConsumer”–应用–选择ActiveScriptEventConsumer Name=”unown”删除之–该关的窗口都关掉–编辑快捷方式 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 对象转Excel文件]]></title>
      <url>%2F2017%2F03%2F01%2FJava-%E5%AF%B9%E8%B1%A1%E8%BD%ACExcel%E6%96%87%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[所用到的依赖jar包.1.阿帕奇的POI2.阿里的fastjson3.阿帕奇公共工具类 代码逻辑1.通过反射获取对象成员变量名称作为Excel的标题.2.反射获取到的对象成员变量值作为Excel的行数据.3.写出文件. 代码1.工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177package my.test.org;import com.alibaba.fastjson.JSON;import org.apache.commons.collections.CollectionUtils;import org.apache.commons.lang3.StringUtils;import org.apache.poi.hssf.usermodel.*;import org.apache.poi.ss.usermodel.HorizontalAlignment;import javax.transaction.TransactionRequiredException;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.lang.reflect.Field;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.*;/** * Author: xinyi.pan * Date: 2017/3/1 * &lt;p&gt; * 工具类:excel 导出 */public class AccessUtils &#123; /** * 将对象List转换为HSSFWorkbook对象 * * @param objectList * @return */ public static &lt;T&gt; HSSFWorkbook ListObject2HSSFWorkbook(List&lt;T&gt;... objectList) &#123; if (objectList == null || objectList.length == 0) &#123; throw new IllegalArgumentException(&quot;待转换的对象为空&quot;); &#125; HSSFWorkbook workbook = new HSSFWorkbook(); for (int i = 0; i &lt; objectList.length; i++) &#123; List&lt;T&gt; tList = objectList[i]; if (CollectionUtils.isNotEmpty(tList)) &#123; String sheetName = objectList[i].get(0).getClass().getSimpleName(); if (StringUtils.isNotBlank(sheetName)) &#123; ListObject2HSSFWorkbook(objectList[i], sheetName, workbook); &#125; &#125; &#125; return workbook; &#125; /** * 将List对象添加到对应的页 * * @param objectList * @param sheetName * @param workbook * @return */ public static &lt;T&gt; HSSFWorkbook ListObject2HSSFWorkbook(List&lt;T&gt; objectList, String sheetName, HSSFWorkbook workbook) &#123; //创建该页的首行 HSSFSheet sheet = workbook.createSheet(sheetName); //创建基本样式居中 HSSFCellStyle style = workbook.createCellStyle(); style.setAlignment(HorizontalAlignment.CENTER); boolean isFirstRow = true; Map&lt;String, Integer&gt; keyMap = new HashMap&lt;String, Integer&gt;(); for (int i = 0; i &lt; objectList.size(); i++) &#123; T t1 = objectList.get(i); if (t1 == null) continue; Class oClass = t1.getClass(); Field[] fields = oClass.getDeclaredFields(); if (fields == null || fields.length == 0) continue; String key; String valueStr; if (isFirstRow) &#123; //创建标题 HSSFRow row = sheet.createRow(0); for (int j = 0, k = 0; j &lt; fields.length; j++) &#123; Field field = fields[j]; if (field == null) continue; HSSFCell cell = row.createCell(k); key = field.getName(); if (StringUtils.isBlank(key)) continue; if (&quot;serialVersionUID&quot;.equalsIgnoreCase(key)) continue; cell.setCellStyle(style); cell.setCellValue(key); keyMap.put(key, k); k++; &#125; isFirstRow = false; &#125; //添加数据 HSSFRow row = sheet.createRow(i + 1); for (int j = 0; j &lt; fields.length; j++) &#123; Field field = fields[j]; if (field == null) continue; try &#123; key = field.getName(); HSSFCell cell = row.createCell(keyMap.get(key)); if (StringUtils.isBlank(key)) continue; if (&quot;serialVersionUID&quot;.equalsIgnoreCase(key)) continue; field.setAccessible(true); Object value = field.get(t1); if (value == null) continue; //日期格式化 if (value instanceof Calendar) &#123; SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); valueStr = dateFormat.format(((Calendar) value).getTime()); &#125; else if (value instanceof Date) &#123; SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); valueStr = dateFormat.format(value); &#125; else &#123; //其他转换为JSON字符串,去掉引号 valueStr = JSON.toJSONString(value).replaceAll(&quot;\&quot;&quot;, &quot;&quot;); &#125; cell.setCellValue(valueStr); &#125; catch (IllegalAccessException e) &#123; //异常继续执行下一个成员变量 continue; &#125; catch (Exception e) &#123; //异常继续执行下一个成员变量 continue; &#125; &#125; &#125; //列宽自适应 for (int i = 0; i &lt; keyMap.size(); i++) &#123; sheet.autoSizeColumn(i); sheet.setColumnWidth(i, sheet.getColumnWidth(i) * 17 / 10); &#125; return workbook; &#125; public static void main(String[] args) &#123; List&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;(); List&lt;String&gt; stringList = new ArrayList&lt;String&gt;(); stringList.add(&quot;qqqq&quot;); stringList.add(&quot;wwww&quot;); stringList.add(&quot;eeee&quot;); Student student1 = new Student(); student1.set学生姓名(&quot;张三&quot;); student1.set学生成绩(new BigDecimal(&quot;90&quot;)); student1.setStringList(stringList); studentList.add(student1); Student student2 = new Student(); student2.set学生姓名(&quot;李四&quot;); student2.set学生成绩(new BigDecimal(&quot;80&quot;)); studentList.add(student2); Student student3 = new Student(); student3.set学生姓名(&quot;王五&quot;); student3.set学生成绩(new BigDecimal(&quot;50&quot;)); studentList.add(student3); Student student4 = new Student(); student4.set学生姓名(&quot;陈翔&quot;); student4.set学生成绩(new BigDecimal(&quot;0.0&quot;)); studentList.add(student4); HSSFWorkbook workbook = new HSSFWorkbook(); try &#123; workbook = AccessUtils.ListObject2HSSFWorkbook(studentList); FileOutputStream outputStream = new FileOutputStream(&quot;E:\\downloads\\test.xls&quot;); workbook.write(outputStream); &#125; catch (TransactionRequiredException e) &#123; e.printStackTrace(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 2.测试用到的对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package my.test.org;import java.io.Serializable;import java.math.BigDecimal;import java.util.List;/** * Author: xinyi.pan * Date: 2017/3/1 */public class Student implements Serializable &#123; private static final long serialVersionUID = 7911823052873591951L; private String 学生姓名 ; private BigDecimal 学生成绩 ; private List&lt;String&gt; stringList ; public String get学生姓名() &#123; return 学生姓名; &#125; public void set学生姓名(String 学生姓名) &#123; this.学生姓名 = 学生姓名; &#125; public BigDecimal get学生成绩() &#123; return 学生成绩; &#125; public void set学生成绩(BigDecimal 学生成绩) &#123; this.学生成绩 = 学生成绩; &#125; public List&lt;String&gt; getStringList() &#123; return stringList; &#125; public void setStringList(List&lt;String&gt; stringList) &#123; this.stringList = stringList; &#125;&#125;package my.test.org;import java.io.Serializable;import java.math.BigDecimal;import java.util.List;/** * Author: xinyi.pan * Date: 2017/3/1 */public class Student implements Serializable &#123; private static final long serialVersionUID = 7911823052873591951L; private String 学生姓名 ; private BigDecimal 学生成绩 ; private List&lt;String&gt; stringList ; public String get学生姓名() &#123; return 学生姓名; &#125; public void set学生姓名(String 学生姓名) &#123; this.学生姓名 = 学生姓名; &#125; public BigDecimal get学生成绩() &#123; return 学生成绩; &#125; public void set学生成绩(BigDecimal 学生成绩) &#123; this.学生成绩 = 学生成绩; &#125; public List&lt;String&gt; getStringList() &#123; return stringList; &#125; public void setStringList(List&lt;String&gt; stringList) &#123; this.stringList = stringList; &#125;&#125; 输出的结果 学生姓名 学生成绩 stringList 张三 90 [qqqq,wwww,eeee] 李四 80 王五 50 陈翔 0.0 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ubuntu 主题推荐]]></title>
      <url>%2F2017%2F02%2F20%2Fubuntu-%E4%B8%BB%E9%A2%98%E6%8E%A8%E8%8D%90%2F</url>
      <content type="text"><![CDATA[更换源打开系统设置 &gt; 软件和更新 选择中国服务器(官方用的是阿里云) 设置新建窗口居中打开终端:1sudo apt install compizconfig-settings-manager 然后打开compizconfig-settings-manager来配置.在窗口管理 &gt; 放置窗口 &gt; 安置模式 &gt; 居中 安装主题工具 unity-tweak-tool打开终端:1sudo apt-get install unity-tweak-tool 添加主题1.Arc 主题安装打开终端:1sudo sh -c &quot;echo &apos;deb http://download.opensuse.org/repositories/home:/Horst3180/xUbuntu_16.04/ /&apos; &gt;&gt; /etc/apt/sources.list.d/arc-theme.list&quot; 让 Arc GTK 主题源定期收到主题更新:123wget http://download.opensuse.org/repositories/home:Horst3180/xUbuntu_16.04/Release.keysudo apt-key add - &lt; Release.key 安装arc主题:12sudo apt updatesudo apt install arc-theme 换掉ubuntu启动器的图标将面板上的 ‘Ubuntu Desktop’ 文字替换 ‘Mac’123cd &amp;&amp; wget -O Mac.po http://drive.noobslab.com/data/Mac/change-name-on-panel/mac.pocd /usr/share/locale/en/LC_MESSAGES; sudo msgfmt -o unity.mo ~/Mac.po;rm ~/Mac.po;cd 语言上如果是其他非英语语言，将 /en 做相应修改： 恢复原来的桌面文字命令：123cd &amp;&amp; wget -O Ubuntu.po http://drive.noobslab.com/data/Mac/change-name-on-panel/ubuntu.pocd /usr/share/locale/en/LC_MESSAGES; sudo msgfmt -o unity.mo ~/Ubuntu.po;rm ~/Ubuntu.po;cd 启动器上苹果Logo123wget -O launcher_bfb.png http://drive.noobslab.com/data/Mac/launcher-logo/apple/launcher_bfb.pngsudo mv launcher_bfb.png /usr/share/unity/icons/ 恢复图标：123wget -O launcher_bfb.png http://drive.noobslab.com/data/Mac/launcher-logo/ubuntu/launcher_bfb.pngsudo mv launcher_bfb.png /usr/share/unity/icons/ 设置主题打开 Unity Tweak Tool 工具软件.找到主题 设置自己喜欢的主题即可. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ubuntu 清除Guest账户]]></title>
      <url>%2F2017%2F02%2F17%2Fubuntu-%E6%B8%85%E9%99%A4Guest%E8%B4%A6%E6%88%B7%2F</url>
      <content type="text"><![CDATA[删除:123sudo mkdir /etc/lightdm/lightdm.conf.dsudo sh -c &apos;printf &quot;[SeatDefaults]\nallow-guest=false\n&quot; &gt; /etc/lightdm/lightdm.conf.d/50-no-guest.conf&apos; 恢复:1sudo rm /etc/lightdm/lightdm.conf.d/50-no-guest.conf End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浅谈关系数据使用非关系型数据库处理方法]]></title>
      <url>%2F2017%2F01%2F26%2F%E6%B5%85%E8%B0%88%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[场景:多个数据表关联.需要查询多个表的信息.表1:用户名+性别表2:表1的id,密码表3:用户id+用户车辆信息 查询条件:需要查询某个用户的大众车辆,并查询该用户的密码.假色有很多台.采用分页查询.那么这里应该区分主表,附加表.我们需要的数据,必须是筛选过的数据才能准确分页.所以,最后的信息一定是主表,也就是表1. 可以采用先查询所有用户中,车辆为大众的用户id.然后,根据用户名,用户id去筛选出用户信息.再根据用户表的id.去查询用户密码. 为什么要如此做?1.筛选条件前置,才能去除分页之后再筛选造成的数据错误.2.查询速度其实是一样的,因为都需要去查询两个表.3.相对于没有筛选的条件的信息获取,先查寻出id,再根据id拉取数据,一般这个id都会做索引.所以,如此的话,速度应该也能满足. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[wondiws磁盘管理命令的使用]]></title>
      <url>%2F2017%2F01%2F25%2Fwondiws%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[diskpart命令 使用方式,打开cmd.输入diskpart.进入diskpart模式.切记,不要相信网上的坑逼教程.直接select disk 1来clean.这样你可能删掉的不是自己想要的磁盘.资料丢失.切记切记,教程参考.实际使用需理论考虑.坑逼教程在百度经验.别相信百度,选择谷歌! 查看1.查看磁盘list disk2.查看分区list partition3.查看卷list volume4.查看虚拟磁盘list vdisk 选择1.选择磁盘select disk 序号2.选择分区select partition 序号3.选择卷select volume 序号4.选择虚拟磁盘select vdisk 序号 清除1.清除磁盘clean disk2.清除分区delete partition3.清除盘符(卷)delete volume 设置1.创建主分区create partition primary [size=n] [offset=n]2.创建逻辑分区create partition logical [size=n] [offset=n]3.创建扩展分区create partition extended [size=n] [offset=n]4.分配盘符assign [letter=l] 其他1.快速格式化format [fs=ntfs] quick 操作的步骤是,先查询.然后选择.在执行清除.然后在分配. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Druid的坑]]></title>
      <url>%2F2017%2F01%2F25%2FDruid%E7%9A%84%E5%9D%91%2F</url>
      <content type="text"><![CDATA[1.高性能的Druid连接池,在没有引入驱动的时候.调用连接.线程直接死循环. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql日期处理函数]]></title>
      <url>%2F2017%2F01%2F23%2Fmysql%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[过滤指定日期 1.近1天123select * from table where to_days(column_time) = to_days(now());select * from table where date(column_time) = curdate(); 2.近7天1select * from table where DATE_SUB(CURDATE(), INTERVAL 7 DAY) &lt;= date(column_time); 3.近一个月1select * from table where DATE_SUB(CURDATE(), INTERVAL 1 MONTH) &lt;= date(column_time); 筛选出需要的日期的值1.筛选出年月日1select DATA(column_time) from table ; 2.筛选出年月1select Extract(year_month FROM column_time) from table ; 3.筛选出年.1select Extract(year FROM column_time) from table ; 4.筛选出月1select Extract(month FROM column_time) from table ; 5.筛选出日1select Extract(day FROM column_time) from table ; 6.筛选出时分秒1select time(day FROM column_time) from table ; 比较日期1.间隔天数1SELECT match_date,create_time FROM table_name WHERE datediff(match_date,create_time) = 60 详见: 官方文档 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xshell故障]]></title>
      <url>%2F2017%2F01%2F23%2Fxshell%E6%95%85%E9%9A%9C%2F</url>
      <content type="text"><![CDATA[故障1,登录成功.会话断开. 这种原因google了很久,都没找到.后来才知道是因为窗口太大了.服务器那边可能不支持大屏显示吧.缩小窗口就可以了. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java内存模型]]></title>
      <url>%2F2017%2F01%2F22%2Fjava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[运行时的内存模型 java目前使用的虚拟机是HotSpot.运行时的内存模型可以简单分为:方法栈,堆,程序计数器,虚拟机栈,本地方法栈. 其中堆与方法栈是所有线程共享的. 虚拟机栈与本地方法栈,程序计数器是线程独享的. 程序计数器,虚拟机栈的生命周期与线程的周期是一样的. 程序计数器 程序计数器可以看作是当前线程的运行状态.进行指令分配的一小段内存块.它的功能是记录当前线程的一些状态,值.以便于线程的唤醒,启动.异常处理等线程功能都由它来完成. 虚拟机栈 虚拟机栈中保存的是局部变量,操作数栈,程序的出口信息.动态连接等.它的主要作用是存储线程执行的一些数据(线程内部数据). 本地方法栈 本地方法栈也是用来保存方法内的变量(局部变量),动态连接,出口数据等线程私有的数据.只是它对应的是本地方法,而虚拟机栈对应的是java的方法. 方法栈 方法栈是所有线程共享的.它主要保存所有类的信息,常量,静态成员变量.方法模型的基本信息.非静态成员变量也保存在此.所以成员变量需要考虑线程安全性的问题. 堆 java堆是内存中最大的一部分,几乎所有的对象实例都保存于此.GC回收最主要部分也是这里. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[windows下删除文件过深命令]]></title>
      <url>%2F2017%2F01%2F19%2Fwindows%E4%B8%8B%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E8%BF%87%E6%B7%B1%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[命令: robocopy windows的可靠文件复制.原理: 新建一个文件夹,然后使用可靠复制命令.将新建的正常文件夹覆盖需要删除的文件夹.示例: robocopy /MIR 正常文件夹 需要删除的文件夹. 查看命令所有参数:robocopy /? End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java多线程概念]]></title>
      <url>%2F2017%2F01%2F16%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%2F</url>
      <content type="text"><![CDATA[概述 多线程是线程切换,多线程中的线程安全指的是在统一资源中.多线程在读取与修改的时候.资源是否同步.对于属于线程的资源,则无需考虑多线程安全问题.因为该资源是该县城独占.不存在线程安全问题. 并发 并发与多线程是一个意思.并发描述侧重于业务.多线程描述侧重于编码机制. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[list,map,queue,dequeue区别]]></title>
      <url>%2F2017%2F01%2F16%2Flist-map-queue-dequeue%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[list list是最常用的集合类.这里需要注意的是arraylist是非线程同步的.如果资源共享时候,需要考虑同步的话可以使用vector类.也可以使用同步队列.arraylist是一局数组的动态扩充来实现的.如果超过长度,则会一次性扩充当前长度的1.5倍. map map也是集合中最为常用的集合类.hashMap,tableMap的区别是多线程时候,该资源是否同步.hashmap的底层实现是根据hashcode与next来进行判断.对于不同对象的相同hashcode,hashmap会在该节点产生一个链表.hashmap的put依托于重写equals方法.hashmap中的hashcode也是重新生成的.null可以作为key. hashcode的无符号右位移16位的次方((h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)).hashmap的的对象是Entry类型.所以equals时候,需比较hashcode与key对象的equals.来判断是否相等.然后执行是插入还哦是更新 队列 队列比较特殊,它是集合类.但是它比一般的集合类功能要多一点.对于非阻塞无界队列来说,它功能上与list来说是一样的.队列有一个特性是阻塞,它表示的意义是只容许插入指定的数据,如果是插满,则在put方法时候会一直处于等待插入状态,add方法会抛出异常.offer方法则会插入失败,但不会抛出异常.功能上来说,队列优于list,set. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[项目命令规范]]></title>
      <url>%2F2017%2F01%2F16%2F%E9%A1%B9%E7%9B%AE%E5%91%BD%E4%BB%A4%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[Alpha： Alpha是内部测试版,一般不向外部发布,会有很多Bug.除非你也是测试人员,否则不建议使用.是希腊字母的第一位,表示最初级的版本，alpha 就是α，beta 就是β ，alpha 版就是比beta还早的测试版，一般都是内部测试的版本。Beta: 该版本相对于α版已有了很大的改进，消除了严重的错误，但还是存在着一缺陷，需要经过多次测试来进一步消除。这个阶段的版本会一直加入新的功能。 RC：(Release Candidate) Candidate是候选人的意思，用在软件上就是候选版本。Release.Candidate.就是发行候选版本。和Beta版最大的差别在于Beta阶段会一直加入新的功能，但是到了RC版本，几乎就不会加入新的功能了，而主要着重于除错! RC版本是最终发放给用户的最接近正式版的版本，发行后改正bug就是正式版了，就是正式版之前的最后一个测试版。GA：（general availability） 比如：Apache Struts 2 GA这是Apache Struts 2首次发行稳定的版本，GA意味着GeneralAvailability，也就是官方开始推荐广泛使用了。Release: 该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式版本，是最终交付用户使用的一个版本。该版本有时也称为标准版。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(R)。数字 第一位表示主版本,一般是产品重大迭代.第二位表示小版本.一般表示小功能的增加.第三位表示修复版本.如果是4位数字的,那么最后一位代表bug修复/优化版本. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java编程的一些建议]]></title>
      <url>%2F2017%2F01%2F16%2Fjava%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[集合类 list方法的subList是返回视图上的子类.使用该方法之后,不能对其父类再进行一些操作.否则会有size的异常.subList还是不要使用的好,因为它没有产生新的对象. 排序的打乱是用自带的shuffle方法. 多线程对统一资源的操作时,使用vector或者hashtable.也可以使用同步队列. 集合对象可以采用谷歌的Guava包. 未完待续]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[altimu-designer常用快捷键]]></title>
      <url>%2F2017%2F01%2F11%2Faltimu-designer%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[原理图快捷键列表 p 放置器件 tab 在放置之前,设置器件的属性设置 space 器件90度旋转. x 器件X轴镜像 y 器件Y轴镜像 鼠标左键 放置器件 鼠标右键 取消放置 按住右键, 拖拽图纸 ctrl+滚轮 放大/缩小 ctrl+按住鼠标右键,滑动鼠标 以器件为中心缩放 ltium Designer14 PCB快捷键：旋转：Space；X轴镜像：X；Y轴镜像：Y；板层管理：L；栅格设置：G；单位进制切换：Q； 对齐-水平：A，D；对齐-垂直：A，I，I，Enter；对齐-顶部：A，T；对齐-底部：A，B；对齐-左侧：A，L；对齐-右侧：A，R； 设计-类设置：D，C;设计-板层管理：D，K；设计-规则：D，R；设计-规则向导：D，W；设计-拷贝ROOM格式：D，M，C；设计-放置ROOM：D，M，R；设计-根据选择对象定义板子形状：D，S，D；设计-编辑网络：D，N，N； 编辑-删除：E，D；编辑-切断轨迹：E，K；编辑-设定原点：E，O，S；编辑-复位原点：E，O，R； 移动-移动：M，M；移动-拖拽：M，D；移动-器件：M，C；移动-打断走线：M，B；移动-器件翻转板层：M，I； 网络-显示网络：N，S，N；网络-显示器件：N，S，O；网络-显示全部：N，S，A；网络-隐藏网络：N，H，N；网络-隐藏器件：N，H，O；网络-隐藏全部：N，H，A； 放置-坐标：P，O；放置-焊盘：P，P；放置-字符：P，S；放置-过孔：P，V；放置-多边形：P，R；放置-填充：P，F；放置-敷铜：P，G；放置-线性尺寸：P，D，L；放置-走线：P，T；放置-差分对布线：P，I；放置-多根布线：P，M，Enter； 选择-全选：S，A；选择-线选：S，L；选择-区域（内部）：S，I；选择-区域（外部）：S，O； 工具-交叉探测对象：T，C；( Ctrl:跳转到目标文件) 工具-泪滴选项：T，E；工具-设计规则检查：T，D；工具-复位错误标志：T，M；工具-从选择元素创建板剪切：T，V，B工具-网络等长调节：T，R； 取消布线-全部：U，A；取消布线-网络：U，N；取消布线-连接：U，C；取消布线-器件：U，O；取消布线-ROOM：U，R； 查看-合适区域：V，A；查看-翻转板子：V，B；查看-适合文件：V，D；查看-合适板子：V，F；查看-合适图纸：V，H； 测距：Ctrl M； 清除蒙板： Shift Ｃ；查找相似对象： Shift F;显示走线长度： Shift G；单层显示： Shift S；改变走线模式：Shift Space； 切换二维显示：2(主键盘)；切换三维显示：3(主键盘)；顶层底层切换：*(小键盘 )；板层切换： /-(小键盘)；智能走线：在放置走线状态， Ctrl； 移动多边形顶点：右键，Y，V；器件联合：右键，U； 增大弧度：长按 &gt;；减小弧度：长按 &lt;；减小多根交互式布线间距：长按Shift B；增加多根交互式布线间距：长按Shift B； 3D模式下：0°旋转：0（主键盘）；90°旋转：9（主键盘）； 布等长线状态下：增加蛇形线拐角弧度：1；减少蛇形线拐角弧度：2；增加蛇形线宽度：3；减少蛇形线宽度：4；增加蛇形线拐角振幅：。；减少蛇形线拐角振幅：，； Altium Designer14 SCH快捷键： 对齐-水平：A，D；对齐-垂直：A，I；对齐-顶部：A，T；对齐-底部：A，B；对齐-左侧：A，L；对齐-右侧：A，R； 打破线：E，W； 放置总线：P，B；放置总线入库：P，U；放置节点：P，J；放置网络标号：P，N；放置端口：P，R；放置字符串：P，T；放置走线：P，W；放置线：P，D，L；放置差分对标示：P，V，F；放置Blanket：P，V，L；放置网络类：P，V，C； 从原理图选择PCB器件： T，S；封装管理器：T，G；强制标注所有器件：T，N； 查看-合适区域：V，A；查看-适合文件：V，D；查看-合适板子：V，F； 清除蒙板： Shift Ｃ；改变走线模式：Shift Space End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java的lambda表达式]]></title>
      <url>%2F2017%2F01%2F09%2Fjava%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[介绍lambda 表达式是1.8的特性.原预计是1.7的需求,但是因为竞争,收购,资金等等原因到1.8才出现.另外,java的lambda表达式与.net的有一定区别的.两者实现的方式不一样.java的lambda表达式是建立在匿名类(接口)之下延伸的.而.net是使用委托这一特性实现的.增加该特性的话,代码会简洁一些. 使用方式无论是java还是.net使用方式都差不多.就是() -&gt; “return data” .入参 -&gt; 回参. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java消息队列]]></title>
      <url>%2F2017%2F01%2F07%2Fjava%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%2F</url>
      <content type="text"><![CDATA[Queue队列的所有已知实现类: 该接口继承Iterable,Collection接口.除了继承的接口的方法外,它有自身操作队列的一些公有的方法:offer/poll/peek. 队列里面的插入:offer,取出顶层元素:poll,查询顶层元素:peek/element.不建议使用集合类的方法,add,remove,addAll.因为操作失败是报异常,需要去捕获异常然后调用线程等待之类的方法. 另外,队列的传入值一般不建议插入null.子接口: BlockingQueue 不容许插入null对象,如果取出顶层元素失败(执行poll),则返回null.可能是有边界的,这种情况下,该队列如果制定边界.那么超过边界的对象不再被接受.如果没指名边界,那么边界就是整行的最大值.不支持close/shutdown这样的方法,线程安全. 是BlockingDeque,Transfer的父接口.一般该实现类都有边界.因为是阻塞的.集合类方法:add/remove/addAll等,在操作失败抛出异常.队列方法:offer/poll/peek,在操作失败返回null或者false.队列方法put/take/操作失败一直重试.队列方法:put(e,time,unit),重试最大时间,如果还是失败就退出. Deque, 双端队列接口,继承自Queue.子接口BlockingDeque.该接口的实现类一般都是无边界的队列(大小自由).首端元素的添加/取出/查询:offerFrist/pollFrist/peekFrist.尾端为Last.也可以使用Queue接口的方法:poll,peek.操作首端元素.这里的offer方法操作的是尾端元素.从尾端添加.首端添加是Stack的push方法.或者offerFrist方法.使用Stack方法:push,pop,peek操作首端元素. BlockingDeque, 继承自BlockingQueue与Deque接口.具有二者的共性.双端阻塞队列,所以操作方法是addFrist/addLast,removeFrist/removeLast…这样的方法.操作失败特性与BrokingQueue一样. TransferQueue, 继承自BlockingQueue接口.使用场景:生产者–&gt;消费者.生产这产生对象,添加到转移队列,消费者从转移队列取出对象.一般该接口的实现类是有边界的.这种情况下,如果消费者一直没有去走元素,那么该生产这就不能在队列满的情况下继续添加.必须要等到队列空出位置.getWaitingConsumerCount()方法:查询消费者的数量.hasWaitConsumer() :是否有消费者正在等待消费.transfer(E e) :转移对象给消费者.如果没有消费者,则一直等待.tryTransfer(E e) :立即转移给消费者.没有返回false.tryTransfer(E e,long time,timeUnit unit) :尝试转移,等待最大时间之后就不再等待.其他方法与其父接口一致.子实现类: AbstractQueue, 抽象类,所有子队列的顶层.实现Queue的接口.所以Queue接口的方法都具有.下面的类都是该类的子类.下面不再重复说明. ArrayBlockingQueue, 基于数组实现的阻塞队列.拥有边界.实现BlockingQueue接口与序列化接口. ArrayDeque, 基于数组的双端队列.无界,初始化未指定大小,默认为16容量.实现Deque接口,克隆接口,序列化接口.关于克隆接口:Cloneable ConcurrentLinkedDeque, 基于链表实现的没有边界的同步双端队列.适用线程安全的多线程并发插入/移除/访问等操作.因为是双端操作,所以集合类的方法遍历可能结果不准确.不容许插入null值. ConcurrentLinkedQueue, 基于链表实现的没边界的同步队列.与之前的一样,也是线程安全的.同样不容许插入null.这一条之后不再重复.一般队列都不容许插入null. DelayQueue, 无界延迟队列.只有到达时间的对象才能被消费.实现BlockingQueue接口.传入参数必须是实现Delayed接口的对象方法多了个size/take.. LinkedBlockingDeque, 基于链表的双端队列.有界,如果初始化未指定容量大小,则默认为整型最大值.实现BlcokingDeque与序列化接口.方法定义与BlockingQueue一致性. LinkedBlockingQueue, 基于链表的阻塞队列,如果初始化时候没有制定大小.默认为整型最大值.遵循FIFO,连接的节点在插入新的对象时候动态创建,知道超出容量限制. LinkedList, 实现List, Deque, Cloneable, Serializable,接口.实现模式是双端队列,使用两条链表操作.该队列是非同步的.官方给出同步的处理方式:Collections.synchronizedList(new LinkedList(…) LinkedTransferQueue, 基于链表实现的传输队列.无界实现TransferQueue与序列化接口.跟大部分非同步队列一样,由于多线程异步的原因,size方法取到的值不能作为准确的判断队列的数量.建议使用队列的方法取出. PriorityQueue, 指定顺序的队列(优先级),无界.继承自AbstractQueue抽象类.传入对象需要实现排序接口 Comparator 来排序.初始化未指定参数,默认容量为11,排序方式为自然排序: natural ordering. PriorityBlockingQueue, 优先阻塞队列,无界.实现阻塞接口与序列化接口.与阻塞队列相比,它多了一个排序的功能. SynchronousQueue 同步队列,无界.实现BlockingQueue接口与序列化接口.可以指定是否FIFO,初始化默认是非公平队列.即不保证先插入的元素一定最先取出.了解队列特性,建议先了解接口特性.例外的就只有同步队列/排序队列(姑且这么翻译)不是实现接口而产生的功能,其他大体都是接口定义的特性. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[idea快捷键]]></title>
      <url>%2F2017%2F01%2F07%2Fidea%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
      <content type="text"><![CDATA[最重要的两个快捷键 ctrl+shfit+a 查询所有命令快捷键ctrl+j 查询所有语句快捷键(eg:sout等于输出语句) 编辑快捷键 Alt+Insert get/set/constructor/overrider..Alt+Enter 编译器建议.代码提示建议修改为Alt+/Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）Shift+F6，重构 - 重命名Ctrl+O，覆写父类方法OverriderAlt+Insert 自动生成Get/Set方法.Ctrl+Alt+T 自动生成try/catch方法.Ctrl+Shift+Up/Down，向上/下移动语句Ctrl+D 复制当前行Ctrl+Y 删除当前行Ctrl+X，剪切行Ctrl+V 粘贴Ctrl+Alt+L 自动格式化代码块.Ctrl+Alt+I 自动缩进排版Ctrl+Alt+O 删除多余的导入类.Ctrl+Enter 自动导入需要的Jar包.Ctrl+”+/-“，当前方法展开、折叠Ctrl+Shift+”+/-“，全部展开、折叠Ctrl+Shift+U，大小写转化 查找定位快捷键 Ctrl+W/Ctrl+Shift+W 智能选择对应代码块.F2 或 Shift+F2，错误快速定位Ctrl+U，转到父类Ctrl+Alt+B 跳到实现类/实现方法Ctrl+B 跳到定义Ctrl+Q 查看注释Ctrl+H，显示类结构图Ctrl+F12 列出当前类的所有方法,变量.Ctrl+F 查找文本Ctrl+Shift+F，全局查找Ctrl+R 替换文本Ctrl+G，定位行Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择Alt+F7，查找整个工程中使用的某一个类、方法或者变量的位置Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失Ctrl+N 根据类名查找类Ctrl+Shift+N 根据文件名查找文件(包括类)Ctrl+Shift+Alt+N，查找所有类中的方法或变量Ctrl+Shift+S，高级搜索Alt+F3，逐个往下查找相同文本，并高亮显示Alt+F8，计算变量值Ctrl+Alt+left/right，返回至上次浏览的位置Ctrl+Alt+F7，显示用法Ctrl+Shift+A 查看所有快捷键Ctrl+Tab 工作界面切换. Debug快捷键 Alt+Shift+F9，选择 DebugAlt+Shift+F10，选择 RunF7，步入F8，步过Shift+F8 跳出方法F9，恢复程序Alt+F9 跳到鼠标指定的位置/断点/直接跳出Alt+F10，查看当前断点Ctrl+Shift+F8 查看全部断点Shift+F7，智能步入Shift+F8，智能步出Alt+Shift+F7，强制步入Alt+Shift+F8，强制步过 CVS快捷键 Alt+~，VCS 操作菜单Ctrl+K，提交更改Ctrl+T，更新项目Ctrl+Alt+Shift+D，显示变化【常规】 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之命令模式]]></title>
      <url>%2F2017%2F01%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[概念 命令模式是对调用者与执行者的解耦.解耦之后,调用者需要添加新的功能或者执行者添加新的功能时,很容易实现.命令模式与代理模式有一定共性.但也有一定区别.都是对源对象的解耦.增加对需求变化的应变能力. 命令模式调用者–&gt;发出命令–&gt;命令接收对象–&gt;具体执行者执行.需要对命令的跟踪,以方便对其暂停/结束之类的操作.代理模式无需保存具体执行的一些信息.只是作为中间件来调用具体的对象.进行一些处理. 成员 命令接口 命令接口的实现类 命令接收接口 命令接收的实现类 命令执行接口 命令执行实现类 类图End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用反射将Object转换为HashMap]]></title>
      <url>%2F2017%2F01%2F06%2F%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%B0%86Object%E8%BD%AC%E6%8D%A2%E4%B8%BAHashMap%2F</url>
      <content type="text"><![CDATA[代码123456789101112131415161718192021222324252627282930313233public class MapUtils &#123; /** * 使用反射获取对象的成员名作为key,值作为value * * @param o * @return */ public static Map&lt;String, String&gt; objectField2Map(Object o) &#123; Map&lt;String, String&gt; result = new HashMap&lt;&gt;(); if (o == null) return result; Class oClass = o.getClass(); Field[] fields = oClass.getDeclaredFields() ; String key; String value; if (fields != null &amp;&amp; fields.length != 0) &#123; for (Field field : fields) &#123; try &#123; key = field.getName(); if (&quot;serialVersionUID&quot;.equalsIgnoreCase(key)) continue; field.setAccessible(true); Object o1 = field.get(o) ; value = o1.toString(); result.put(key, value); &#125; catch (IllegalAccessException e) &#123; continue; &#125; &#125; &#125; return result; &#125;&#125; End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[apache httpclient工具类]]></title>
      <url>%2F2017%2F01%2F06%2Fapache-httpclient%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[httpclient的简单封装 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158public class IntelliHttpClientUtils &#123; private static final Logger logger = LoggerFactory.getLogger(IntelliHttpClientUtils.class); //HttpClient private volatile static CloseableHttpClient httpClient; //设置请求和传输超时时间 1000*6 秒 private static final RequestConfig requestConfig = RequestConfig.custom().setSocketTimeout(0b1011101110000).setConnectTimeout(0b1011101110000).build(); /** * HTTP GET * * @param url * @param encode * @return */ public static String httpGet(String url, String encode) &#123; if (encode == null) encode = &quot;utf-8&quot;; String resultStr = null; CloseableHttpClient closeableHttpClient = getHttpClient(); HttpGet httpGet = new HttpGet(url); httpGet.setConfig(requestConfig); CloseableHttpResponse httpResponse = null; try &#123; httpResponse = closeableHttpClient.execute(httpGet); if (httpResponse.getStatusLine().getStatusCode() &lt; HttpStatus.SC_BAD_REQUEST) &#123; HttpEntity entity = httpResponse.getEntity(); resultStr = EntityUtils.toString(entity, encode); &#125; //请求失败 直接返回null &#125; catch (Exception e) &#123; logger.info(&quot;Intelli.IntelliHttpClientUtils.httpGet 产生异常:&#123;&#125;&quot;, e.getMessage()); &#125; finally &#123; HttpClientUtils.closeQuietly(httpResponse); &#125; return resultStr; &#125; /** * HTTP POST 请求 * * @param url * @param encode * @return */ public static String httpPost(String url, Map&lt;String, String&gt; params, String encode) &#123; if (encode == null) &#123; encode = &quot;utf-8&quot;; &#125; CloseableHttpClient closeableHttpClient = getHttpClient(); HttpPost httpPost = new HttpPost(url); httpPost.setConfig(requestConfig); //组织请求参数 List&lt;NameValuePair&gt; paramList = new ArrayList&lt;NameValuePair&gt;(); Set&lt;String&gt; keySet = params.keySet(); for (String key : keySet) &#123; paramList.add(new BasicNameValuePair(key, params.get(key))); &#125; try &#123; httpPost.setEntity(new UrlEncodedFormEntity(paramList, encode)); &#125; catch (UnsupportedEncodingException e1) &#123; logger.info(&quot;Intelli.IntelliHttpClientUtils.httpPost (Map请求添加参数时)产生异常:&#123;&#125;&quot;, e1.getMessage()); return null; &#125; String resultStr = getResponse2Str(encode, closeableHttpClient, httpPost); return resultStr; &#125; /** * Http Post 请求 * * @param url * @param jsonStr * @param encode * @return */ public static String httpPost(String url, String jsonStr, String encode) &#123; if (encode == null) &#123; encode = &quot;utf-8&quot;; &#125; CloseableHttpClient closeableHttpClient = HttpClients.createDefault(); HttpPost httpPost = new HttpPost(url); httpPost.setConfig(requestConfig); httpPost.setHeader(&quot;Content-type&quot;, &quot;application/json&quot;); //组织请求参数 StringEntity stringEntity = new StringEntity(jsonStr, encode); httpPost.setEntity(stringEntity); String resultStr = getResponse2Str(encode, closeableHttpClient, httpPost); return resultStr; &#125; /** * 获取 CloseableHttpClient * * @return */ private static CloseableHttpClient getHttpClient() &#123; if (httpClient == null) &#123; synchronized (IntelliHttpClientUtils.class) &#123; if (httpClient == null) &#123; HttpClientBuilder httpClientBuilder = HttpClientBuilder.create(); httpClientBuilder.setConnectionManager(new BasicHttpClientConnectionManager()); httpClient = httpClientBuilder.build(); &#125; &#125; &#125; return httpClient; &#125; /** * 关闭httpClient */ private void closeHttpClient() &#123; if (IntelliHttpClientUtils.httpClient == null) return; HttpClientUtils.closeQuietly(IntelliHttpClientUtils.httpClient); &#125; /*** * 关闭httpClient */ @Override protected void finalize() throws Throwable &#123; this.closeHttpClient(); super.finalize(); &#125; /** * 执行 POST 请求 * * @param encode * @param closeableHttpClient * @param httpPost * @return */ private static String getResponse2Str(String encode, CloseableHttpClient closeableHttpClient, HttpPost httpPost) &#123; CloseableHttpResponse httpResponse = null; String resultStr = null; try &#123; httpResponse = closeableHttpClient.execute(httpPost); if (httpResponse.getStatusLine().getStatusCode() &lt; HttpStatus.SC_BAD_REQUEST) &#123; HttpEntity entity = httpResponse.getEntity(); resultStr = EntityUtils.toString(entity, encode); &#125; &#125; catch (Exception e) &#123; logger.info(&quot;Intelli.IntelliHttpClientUtils.getResponse2Str 产生异常:&#123;&#125;&quot;, e.getMessage()); &#125; finally &#123; HttpClientUtils.closeQuietly(httpResponse); &#125; return resultStr; &#125;&#125; End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[http协议状态码]]></title>
      <url>%2F2017%2F01%2F05%2Fhttp%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
      <content type="text"><![CDATA[代码列表 概述 200 服务器成功返回网页 404 – 请求的网页不存在 503 – 服务不可用1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。代码 说明100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx (成功)表示成功处理了请求的状态代码。 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。201 （已创建） 请求成功并且服务器创建了新的资源。202 （已接受） 服务器已接受请求，但尚未处理。203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204 （无内容） 服务器成功处理了请求，但没有返回任何内容。205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。206 （部分内容） 服务器成功处理了部分 GET 请求。 3xx （重定向） 表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx（请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。 400 （错误请求） 服务器不理解请求的语法。401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403 （禁止） 服务器拒绝请求。404 （未找到） 服务器找不到请求的网页。405 （方法禁用） 禁用请求中指定的方法。406 （不接受） 无法使用请求的内容特性响应请求的网页。407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。408 （请求超时） 服务器等候请求时发生超时。409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415 （不支持的媒体类型） 请求的格式不受请求页面的支持。416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5xx（服务器错误） 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 500 （服务器内部错误） 服务器遇到错误，无法完成请求。501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 新 RFC 6585 最近刚刚发布，该文档描述了 4 个新的 HTTP 状态码。 HTTP 协议还在变化？是的，HTTP 协议一直在演变，新的状态码对于开发 REST 服务或者说是基于 HTTP 的服务非常有用，下面我们为你详细介绍这四个新的状态码以及是否应该使用。 428 Precondition Required (要求先决条件) 先决条件是客户端发送 HTTP 请求时，如果想要请求能成功必须满足一些预设的条件。 一个好的例子就是 If-None-Match 头，经常在 GET 请求中使用，如果指定了 If-None-Match ，那么客户端只在响应中的 ETag 改变后才会重新接收回应。 先决条件的另外一个例子就是 If-Match 头，这个一般用在 PUT 请求上用于指示只更新没被改变的资源，这在多个客户端使用 HTTP 服务时用来防止彼此间不会覆盖相同内容。 当服务器端使用 428 Precondition Required 状态码时，表示客户端必须发送上述的请求头才能执行请求，这个方法为服务器提供一种有效的方法来阻止 ‘lost update’ 问题。 429 Too Many Requests (太多请求) 当你需要限制客户端请求某个服务数量时，该状态码就很有用，也就是请求速度限制。 在此之前，有一些类似的状态码，例如 ‘509 Bandwidth Limit Exceeded’. Twitter 使用 420 （这不是HTTP定义的状态码） 如果你希望限制客户端对服务的请求数，可使用 429 状态码，同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务。 431 Request Header Fields Too Large (请求头字段太大) 某些情况下，客户端发送 HTTP 请求头会变得很大，那么服务器可发送 431 Request Header Fields Too Large 来指明该问题。 我不太清楚为什么没有 430 状态码，而是直接从 429 跳到 431，我尝试搜索但没有结果。唯一的猜测是 430 Forbidden 跟 403 Forbidden 太像了，为了避免混淆才这么做的，天知道！ 511 Network Authentication Required (要求网络认证) 对我来说这个状态码很有趣，如果你在开发一个 HTTP 服务器，你不一定需要处理该状态码，但如果你在编写 HTTP 客户端，那这个状态码就非常重要。 如果你频繁使用笔记本和智能手机，你可能会注意到大量的公用 WIFI 服务要求你必须接受一些协议或者必须登录后才能使用。 这是通过拦截HTTP流量，当用户试图访问网络返回一个重定向和登录，这很讨厌，但是实际情况就是这样的。 使用这些“拦截”客户端，会有一些讨厌的副作用。在 RFC 中有提到这两个的例子： 如果你在登录WIFI前访问某个网站，网络设备将会拦截首个请求，这些设备往往也有自己的网站图标 ‘favicon.ico’。登录后您会发现，有一段时间内你访问的网站图标一直是WIFI登录网站的图标。如果客户端使用HTTP请求来查找文档（可能是JSON），网络将会响应一个登录页，这样你的客户端就会解析错误并导致客户端运行异常，在现实中这种问题非常常见。因此 511 状态码的提出就是为了解决这个问题。 如果你正在编写 HTTP 的客户端，你最好还是检查 511 状态码以确认是否需要认证后才能访问。End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之装饰者模式]]></title>
      <url>%2F2017%2F01%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[装饰者模式简述 装饰者模式可以形象的比喻一所大房子,外面只有一个门.打开门里面还有门.打开门获取一点金钱.你可以无限的进门.. Component（被装饰对象的基类） ConcreteComponent（具体被装饰对象） Decorator（装饰者抽象类） ConcreteDecorator（具体装饰者） 类图 代码 定义一个抽象类(非必须) 1234567891011121314151617181920package com.pan.component;/** * 抽象类 * * @author xinyi.pan * */public abstract class Animal &#123; private String name; public Animal(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 定义一个被装饰的接口(定义公共的方法). 12345678package com.pan.component;public interface Fight &#123; //公共方法(门) public String fightPower() ; &#125; 单独类cat 12345678910111213package com.pan.component;public class Cat extends Animal implements Fight &#123; public Cat(String name) &#123; super(name); &#125; //基类的门,里面不再有门.. public String fightPower() &#123; return super.getName() +&quot; fighting&quot; ; &#125; &#125; 单独类cattle 123456789101112package com.pan.component;public class Cattle extends Animal implements Fight &#123; public Cattle(String name) &#123; super(name); &#125; public String fightPower() &#123; return super.getName() + &quot; sleep&quot;; &#125;&#125; 定义抽象装饰类 123456789101112131415161718192021222324package com.pan.decorator;import com.pan.component.Fight;public abstract class AnimalDecorator implements Fight &#123; private Fight fight; // 构造函数添加被装饰着对象 public AnimalDecorator(Fight fight) &#123; this.fight = fight; &#125; //拆包装饰者 public String fightPower() &#123; //调用装饰者公共方法 doDecoratorFight(); //打开下一个门 return fight.fightPower(); &#125; //装饰者的公共方法. public abstract void doDecoratorFight() ;&#125; cattle装饰类 123456789101112131415161718192021package com.pan.decorator;import com.pan.component.Fight;public class CattleDecorator extends AnimalDecorator &#123; public CattleDecorator(Fight fight) &#123; super(fight); &#125; @Override public String fightPower() &#123; return super.fightPower(); &#125; @Override public void doDecoratorFight() &#123; System.out.println(&quot;cattle 打豆豆&quot;); &#125; &#125; 测试方法 123456789101112131415161718192021package com.pan.test;import com.pan.component.Cat;import com.pan.decorator.CatDecorator;import com.pan.decorator.CattleDecorator;public class CalTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;==================未装饰cat==================&quot;); System.out.println(new Cat(&quot;cat&quot;).fightPower()); System.out.println(&quot;===================装饰cat======================&quot;); CatDecorator catDecorator = new CatDecorator(new Cat(&quot;cat&quot;)) ; System.out.println(catDecorator.fightPower()); CattleDecorator cattleDecorator = new CattleDecorator(catDecorator) ; System.out.println(&quot;====================cattle装饰cat装饰=====================&quot;); System.out.println(cattleDecorator.fightPower()); &#125;&#125; 结果 123456789==================未装饰cat==================cat fighting===================装饰cat======================cat 打豆豆cat fighting====================cattle装饰cat装饰=====================cattle 打豆豆cat 打豆豆cat fighting End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[去百度右侧推广方法]]></title>
      <url>%2F2017%2F01%2F02%2F%E5%8E%BB%E7%99%BE%E5%BA%A6%E6%8E%A8%E5%B9%BF%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[百度越来越恶心了… 下面介绍一种简单的去百度推广方法,采用的是chrome浏览器. 安装adb去广告插件. 添加自定义规则. 右侧推广去掉的结果 但是还有搜索的推广 添加清除左侧推广规则 全部结果7.规则: ##div[class*=&quot;cr-content&quot;] ##div[class*=&quot;opr-recommends-merge-panel&quot;] ##div[id*=&quot;con-ar&quot;] ##div[style*=&quot;!important&quot;] End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之观察者模式]]></title>
      <url>%2F2016%2F12%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[观察者模式 观察者模式一般使用在订阅/推送功能下,数据提供方推送数据–&gt;数据接收方.其实在开发中该模式使用应该是很普遍的.例如站内信/信息中心/订阅都是用的是该设计模式. 方式1:数据推送方—&gt;查询订购对象—&gt;推送给订购对象. 方式2:订购的对象 —&gt;查询订阅的数据—&gt;拉取需要的数据. 本质上其实就是发送方与接收方的依赖隔离,也就是说数据发送方发送数据,不是直接发送给订购的对象,而是先查询哪些订购了.然后统一发送出 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java volatile 关键字]]></title>
      <url>%2F2016%2F12%2F29%2Fjava-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
      <content type="text"><![CDATA[volatile关键字的使用 volatile关键字的作用是告诉编译器,该变量是易变的.不要将该变量的值存储在寄存器中,而是放在内存中(一般指的是静态也就是栈). 某些静态变量,如果使用频繁.可能会直接存放于寄存器中,以便加快计算的速度.但是,如果我们期望该值不应 该存在多个不一样的值时候,除了使用final定义为常量.还可以使用该关键字. 该关键字既可以避免一个变量出现多个值的可能,也可以避免常量的不可改变性. 注意点: 使用场景应该如下: 多个线程中,该变量只能拥有一个对象. 该变量可能需要变化.即该变量需要动态创建/销毁. 它本身无法保证运行中只存在一个对象.它只是告诉jvm,它的值需要从内存中去读取,而不是在寄存器(1级缓存/2级缓存/3级缓存)中获取该值. 如果只是需要一个对象,使用final关键字即可.如果该对象使用不频繁,减少内存开销.可以使用该关键字,配合多线程的同步锁,可以实现单例. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之策略模式]]></title>
      <url>%2F2016%2F12%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[策略模式 策略模式是用于解决面向对象中的抽象类与接口的局限性.即一般的对类别进行抽象,对行为进行抽象为接口.这种方式在代码复用上有一定的局限性.而策略模式可以提高代码的复用. eg://定义一个接口,用于在抽象类都能调用到.(里氏替换原则)interface Speak{ void doSpeak() ;}// 实现接口1,其他类只要功能一样都可以采用它.class SpeakCn implements Speak{@Overridepublic void doSpeak() { System.out.println(&quot;中文&quot;); }}//实现接口2,其他类只要功能一样都可以采用它.class SpeakEn implements Speak{@Overridepublic void doSpeak() { System.out.println(&quot;English&quot;); }}//抽象类 使用接口来实现.将具体实现放到子类来实现接口.abstract class man{Speak speak ;void speak(){ speak.doSpeak(); }}class CnMan extends man{//初始化赋值父类接口的实现,也可以采用Spring的初始化加载实现.public CnMan() { speak = new SpeakCn() ; }}//使用class test{public void main(String[] args) { new CnMan().speak(); }} End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 基础语法]]></title>
      <url>%2F2016%2F12%2F28%2FMarkdown-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[markdown基本语法.文字类 标题大小用#来标记,等同于html的&lt;h1&gt;&lt;/h1&gt;标签. 内容的强调使用*或_ 来标记. 有序列表使用数字.来标记. 无序列表使用* 或- 或+来标记. 小代码使用2个`来标记.代码块使用6个`来标记. 如果需要显示单个代码,也可以使用\来标记该字符不被解析. 代码块一种更简便的方式是在开头使用一个tab+4个空格. 列表的嵌套使用tab+列表标记. 空行直接使用html的标记&lt;br/&gt; 连接类 页面内的跳转. 使用&lt;span id =&quot;bijiao&quot;&gt;&lt;/span&gt; 定义一个要跳转的地方. 使用&lt;a href=&quot;#biaoqian&quot;&gt;跳&lt;/a&gt;或者[跳](#biaoqian)来实现跳转. 其他跳转.使用&lt;a href=&quot;地址&quot;&gt;跳&lt;/a&gt;或者[跳](地址)来实现跳转. 图片类 使用&lt;img src=&quot;地址&quot;&gt;名称&lt;/img&gt;或者![名称](地址)来实现. 音视频 声音:使用&lt;audio src=&quot;地址&quot; autoplay=&quot;true&quot;&gt;声音&lt;/audio&gt;来实现 视频:使用&lt;video src=&quot;地址&quot; autoplay=&quot;true&quot;&gt;视频&lt;/video&gt;来实现总结来说,mardown完全可以使用html标签来写.不过,html写起来麻烦.但是一些功能目前来说,markdown还不支持,所以只能采用html的标签来实现.来外,颜色样式的定义.好像也不可以.也只能用html.个人理解markdown只是html的一个框架.对html的一个封装.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git的使用]]></title>
      <url>%2F2016%2F12%2F27%2Fgit%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Git初次使用一般来说就5步. cd 你的目录 //进入你需要提交的目录. git init //初始化. git add * //添加需要提交的文件. git commit -m “第一次提交” //提交的说明. git remote add origin https://github.com/lmxy1990/test.git //添加远程仓库地址 git push -u origin master //提交 到主干]]></content>
    </entry>

    
  
  
</search>
