<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[设计模式之装饰者模式]]></title>
      <url>%2F2017%2F01%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[装饰者模式简述 装饰者模式可以形象的比喻一所大房子,外面只有一个门.打开门里面还有门.打开门获取一点金钱.你可以无限的进门.. Component（被装饰对象的基类） ConcreteComponent（具体被装饰对象） Decorator（装饰者抽象类） ConcreteDecorator（具体装饰者） 类图 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321. 定义一个抽象类(非必须)package com.pan.component;/** * 抽象类 * * @author xinyi.pan * */public abstract class Animal &#123; private String name; public Animal(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;2. 定义一个被装饰的接口(定义公共的方法).package com.pan.component;public interface Fight &#123; //公共方法(门) public String fightPower() ; &#125;3. 单独类catpackage com.pan.component;public class Cat extends Animal implements Fight &#123; public Cat(String name) &#123; super(name); &#125; //基类的门,里面不再有门.. public String fightPower() &#123; return super.getName() +&quot; fighting&quot; ; &#125; &#125;4. 单独类cattlepackage com.pan.component;public class Cattle extends Animal implements Fight &#123; public Cattle(String name) &#123; super(name); &#125; public String fightPower() &#123; return super.getName() + &quot; sleep&quot;; &#125;&#125;5. 定义抽象装饰类package com.pan.decorator;import com.pan.component.Fight;public abstract class AnimalDecorator implements Fight &#123; private Fight fight; // 构造函数添加被装饰着对象 public AnimalDecorator(Fight fight) &#123; this.fight = fight; &#125; //打开装饰者(开门) public String fightPower() &#123; //调用装饰者公共方法(开门得到的一点金钱) doDecoratorFight(); //返回基类(继续开门) return fight.fightPower(); &#125; //装饰者的公共方法. public abstract void doDecoratorFight() ;&#125;6. cattle装饰类package com.pan.decorator;import com.pan.component.Fight;public class CattleDecorator extends AnimalDecorator &#123; public CattleDecorator(Fight fight) &#123; super(fight); &#125; @Override public String fightPower() &#123; return super.fightPower(); &#125; @Override public void doDecoratorFight() &#123; System.out.println(&quot;cattle 打豆豆&quot;); &#125; &#125;7. 测试方法package com.pan.test;import com.pan.component.Cat;import com.pan.component.Cattle;import com.pan.decorator.CatDecorator;public class CalTest &#123; public static void main(String[] args) &#123; System.out.println(new Cat(&quot;cat&quot;).fightPower()); System.out.println(&quot;=========================================&quot;); System.out.println(new CatDecorator(new CatDecorator(new Cattle(&quot;cattle&quot;))).fightPower()); &#125;&#125;8. 结果cat fighting=========================================cat 打豆豆cat 打豆豆cattle sleep End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[去百度右侧推广方法]]></title>
      <url>%2F2017%2F01%2F02%2F%E5%8E%BB%E7%99%BE%E5%BA%A6%E6%8E%A8%E5%B9%BF%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[百度越来越恶心了… 下面介绍一种简单的去百度推广方法,采用的是chrome浏览器. 安装adb去广告插件. 添加自定义规则. 右侧推广去掉的结果 但是还有搜索的推广 添加清除左侧推广规则 全部结果7.规则: ##div[class*=&quot;cr-content&quot;] ##div[class*=&quot;opr-recommends-merge-panel&quot;] ##div[id*=&quot;con-ar&quot;] ##div[style*=&quot;!important&quot;] End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之观察者模式]]></title>
      <url>%2F2016%2F12%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[观察者模式 观察者模式一般使用在订阅/推送功能下,数据提供方推送数据–&gt;数据接收方.其实在开发中该模式使用应该是很普遍的.例如站内信/信息中心/订阅都是用的是该设计模式. 方式1:数据推送方—&gt;查询订购对象—&gt;推送给订购对象. 方式2:订购的对象 —&gt;查询订阅的数据—&gt;拉取需要的数据. 本质上其实就是发送方与接收方的依赖隔离,也就是说数据发送方发送数据,不是直接发送给订购的对象,而是先查询哪些订购了.然后统一发送出 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java volatile 关键字]]></title>
      <url>%2F2016%2F12%2F29%2Fjava-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
      <content type="text"><![CDATA[volatile关键字的使用 volatile关键字的作用是告诉编译器,该变量是易变的.不要将该变量的值存储在寄存器中,而是放在内存中(一般指的是静态也就是栈). 某些静态变量,如果使用频繁.可能会直接存放于寄存器中,以便加快计算的速度.但是,如果我们期望该值不应 该存在多个不一样的值时候,除了使用final定义为常量.还可以使用该关键字. 该关键字既可以避免一个变量出现多个值的可能,也可以避免常量的不可改变性. 注意点: 使用场景应该如下: 多个线程中,该变量只能拥有一个对象. 该变量可能需要变化.即该变量需要动态创建/销毁. 它本身无法保证运行中只存在一个对象.它只是告诉jvm,它的值需要从内存中去读取,而不是在寄存器(1级缓存/2级缓存/3级缓存)中获取该值. 如果只是需要一个对象,使用final关键字即可.如果该对象使用不频繁,减少内存开销.可以使用该关键字,配合多线程的同步锁,可以实现单例. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之策略模式]]></title>
      <url>%2F2016%2F12%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[策略模式 策略模式是用于解决面向对象中的抽象类与接口的局限性.即一般的对类别进行抽象,对行为进行抽象为接口.这种方式在代码复用上有一定的局限性.而策略模式可以提高代码的复用. eg://定义一个接口,用于在抽象类都能调用到.(里氏替换原则)interface Speak{ void doSpeak() ;}// 实现接口1,其他类只要功能一样都可以采用它.class SpeakCn implements Speak{@Overridepublic void doSpeak() { System.out.println(&quot;中文&quot;); }}//实现接口2,其他类只要功能一样都可以采用它.class SpeakEn implements Speak{@Overridepublic void doSpeak() { System.out.println(&quot;English&quot;); }}//抽象类 使用接口来实现.将具体实现放到子类来实现接口.abstract class man{Speak speak ;void speak(){ speak.doSpeak(); }}class CnMan extends man{//初始化赋值父类接口的实现,也可以采用Spring的初始化加载实现.public CnMan() { speak = new SpeakCn() ; }}//使用class test{public void main(String[] args) { new CnMan().speak(); }} End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 基础语法]]></title>
      <url>%2F2016%2F12%2F28%2FMarkdown-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[markdown基本语法.文字类 标题大小用#来标记,等同于html的&lt;h1&gt;&lt;/h1&gt;标签. 内容的强调使用*或_ 来标记. 有序列表使用数字.来标记. 无序列表使用* 或- 或+来标记. 小代码使用2个`来标记.代码块使用6个`来标记. 如果需要显示单个代码,也可以使用\来标记该字符不被解析. 代码块一种更简便的方式是在开头使用一个tab+4个空格. 列表的嵌套使用tab+列表标记. 空行直接使用html的标记&lt;br/&gt; 连接类 页面内的跳转. 使用&lt;span id =&quot;bijiao&quot;&gt;&lt;/span&gt; 定义一个要跳转的地方. 使用&lt;a href=&quot;#biaoqian&quot;&gt;跳&lt;/a&gt;或者[跳](#biaoqian)来实现跳转. 其他跳转.使用&lt;a href=&quot;地址&quot;&gt;跳&lt;/a&gt;或者[跳](地址)来实现跳转. 图片类 使用&lt;img src=&quot;地址&quot;&gt;名称&lt;/img&gt;或者![名称](地址)来实现. 音视频 声音:使用&lt;audio src=&quot;地址&quot; autoplay=&quot;true&quot;&gt;声音&lt;/audio&gt;来实现 视频:使用&lt;video src=&quot;地址&quot; autoplay=&quot;true&quot;&gt;视频&lt;/video&gt;来实现总结来说,mardown完全可以使用html标签来写.不过,html写起来麻烦.但是一些功能目前来说,markdown还不支持,所以只能采用html的标签来实现.来外,颜色样式的定义.好像也不可以.也只能用html.个人理解markdown只是html的一个框架.对html的一个封装.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git的使用]]></title>
      <url>%2F2016%2F12%2F27%2Fgit%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Git初次使用一般来说就5步. cd 你的目录 //进入你需要提交的目录. git init //初始化. git add * //添加需要提交的文件. git commit -m “第一次提交” //提交的说明. git remote add origin https://github.com/lmxy1990/test.git //添加远程仓库地址 git push -u origin master //提交 到主干]]></content>
    </entry>

    
  
  
</search>
