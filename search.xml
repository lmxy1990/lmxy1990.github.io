<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[设计模式之观察者模式]]></title>
      <url>%2F2016%2F12%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[观察者模式 观察者模式一般使用在订阅/推送功能下,数据提供方推送数据–&gt;数据接收方.其实在开发中该模式使用应该是很普遍的.例如站内信/信息中心/订阅都是用的是该设计模式. 方式1:数据推送方—&gt;查询订购对象—&gt;推送给订购对象. 方式2:订购的对象 —&gt;查询订阅的数据—&gt;拉取需要的数据. 本质上其实就是发送方与接收方的依赖隔离,也就是说数据发送方发送数据,不是直接发送给订购的对象,而是先查询哪些订购了.然后统一发送出 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java volatile 关键字]]></title>
      <url>%2F2016%2F12%2F29%2Fjava-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
      <content type="text"><![CDATA[volatile关键字的使用 volatile关键字的作用是告诉编译器,该变量是易变的.不要将该变量的值存储在寄存器中,而是放在内存中(一般指的是静态也就是栈). 某些静态变量,如果使用频繁.可能会直接存放于寄存器中,以便加快计算的速度.但是,如果我们期望该值不应 该存在多个不一样的值时候,除了使用final定义为常量.还可以使用该关键字. 该关键字既可以避免一个变量出现多个值的可能,也可以避免常量的不可改变性. 注意点: 使用场景应该如下: 多个线程中,该变量只能拥有一个对象. 该变量可能需要变化.即该变量需要动态创建/销毁. 它本身无法保证运行中只存在一个对象.它只是告诉jvm,它的值需要从内存中去读取,而不是在寄存器(1级缓存/2级缓存/3级缓存)中获取该值. 如果只是需要一个对象,使用final关键字即可.如果该对象使用不频繁,减少内存开销.可以使用该关键字,配合多线程的同步锁,可以实现单例. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之策略模式]]></title>
      <url>%2F2016%2F12%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[策略模式 策略模式是用于解决面向对象中的抽象类与接口的局限性.即一般的对类别进行抽象,对行为进行抽象为接口.这种方式在代码复用上有一定的局限性.而策略模式可以提高代码的复用. eg://定义一个接口,用于在抽象类都能调用到.(里氏替换原则)interface Speak{ void doSpeak() ;}// 实现接口1,其他类只要功能一样都可以采用它.class SpeakCn implements Speak{@Overridepublic void doSpeak() { System.out.println(&quot;中文&quot;); }}//实现接口2,其他类只要功能一样都可以采用它.class SpeakEn implements Speak{@Overridepublic void doSpeak() { System.out.println(&quot;English&quot;); }}//抽象类 使用接口来实现.将具体实现放到子类来实现接口.abstract class man{Speak speak ;void speak(){ speak.doSpeak(); }}class CnMan extends man{//初始化赋值父类接口的实现,也可以采用Spring的初始化加载实现.public CnMan() { speak = new SpeakCn() ; }}//使用class test{public void main(String[] args) { new CnMan().speak(); }} End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 基础语法]]></title>
      <url>%2F2016%2F12%2F28%2FMarkdown-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[markdown基本语法.文字类 标题大小用#来标记,等同于html的&lt;h1&gt;&lt;/h1&gt;标签. 内容的强调使用*或_ 来标记. 有序列表使用数字.来标记. 无序列表使用* 或- 或+来标记. 小代码使用2个`来标记.代码块使用6个`来标记. 如果需要显示单个代码,也可以使用\来标记该字符不被解析. 代码块一种更简便的方式是在开头使用一个tab+4个空格. 列表的嵌套使用tab+列表标记. 空行直接使用html的标记&lt;br/&gt; 连接类 页面内的跳转. 使用&lt;span id =&quot;bijiao&quot;&gt;&lt;/span&gt; 定义一个要跳转的地方. 使用&lt;a href=&quot;#biaoqian&quot;&gt;跳&lt;/a&gt;或者[跳](#biaoqian)来实现跳转. 其他跳转.使用&lt;a href=&quot;地址&quot;&gt;跳&lt;/a&gt;或者[跳](地址)来实现跳转. 图片类 使用&lt;img src=&quot;地址&quot;&gt;名称&lt;/img&gt;或者![名称](地址)来实现. 音视频 声音:使用&lt;audio src=&quot;地址&quot; autoplay=&quot;true&quot;&gt;声音&lt;/audio&gt;来实现 视频:使用&lt;video src=&quot;地址&quot; autoplay=&quot;true&quot;&gt;视频&lt;/video&gt;来实现总结来说,mardown完全可以使用html标签来写.不过,html写起来麻烦.但是一些功能目前来说,markdown还不支持,所以只能采用html的标签来实现.来外,颜色样式的定义.好像也不可以.也只能用html.个人理解markdown只是html的一个框架.对html的一个封装.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git的使用]]></title>
      <url>%2F2016%2F12%2F27%2Fgit%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Git初次使用一般来说就5步. cd 你的目录 //进入你需要提交的目录. git init //初始化. git add * //添加需要提交的文件. git commit -m “第一次提交” //提交的说明. git remote add origin https://github.com/lmxy1990/test.git //添加远程仓库地址 git push -u origin master //提交 到主干]]></content>
    </entry>

    
  
  
</search>
