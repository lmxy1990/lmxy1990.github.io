<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[http协议状态码]]></title>
      <url>%2F2017%2F01%2F05%2Fhttp%E5%8D%8F%E8%AE%AE%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
      <content type="text"><![CDATA[状态200 服务器成功返回网页 404 – 请求的网页不存在 503 – 服务不可用1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。 代码 说明100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx (成功)表示成功处理了请求的状态代码。 代码 说明200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。201 （已创建） 请求成功并且服务器创建了新的资源。202 （已接受） 服务器已接受请求，但尚未处理。203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。204 （无内容） 服务器成功处理了请求，但没有返回任何内容。205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。206 （部分内容） 服务器成功处理了部分 GET 请求。 3xx （重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 代码 说明300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。 代码 说明400 （错误请求） 服务器不理解请求的语法。401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。403 （禁止） 服务器拒绝请求。404 （未找到） 服务器找不到请求的网页。405 （方法禁用） 禁用请求中指定的方法。406 （不接受） 无法使用请求的内容特性响应请求的网页。407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。408 （请求超时） 服务器等候请求时发生超时。409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。415 （不支持的媒体类型） 请求的格式不受请求页面的支持。416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5xx（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 代码 说明500 （服务器内部错误） 服务器遇到错误，无法完成请求。501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 新RFC 6585 最近刚刚发布，该文档描述了 4 个新的 HTTP 状态码。 HTTP 协议还在变化？是的，HTTP 协议一直在演变，新的状态码对于开发 REST 服务或者说是基于 HTTP 的服务非常有用，下面我们为你详细介绍这四个新的状态码以及是否应该使用。 428 Precondition Required (要求先决条件) 先决条件是客户端发送 HTTP 请求时，如果想要请求能成功必须满足一些预设的条件。 一个好的例子就是 If-None-Match 头，经常在 GET 请求中使用，如果指定了 If-None-Match ，那么客户端只在响应中的 ETag 改变后才会重新接收回应。 先决条件的另外一个例子就是 If-Match 头，这个一般用在 PUT 请求上用于指示只更新没被改变的资源，这在多个客户端使用 HTTP 服务时用来防止彼此间不会覆盖相同内容。 当服务器端使用 428 Precondition Required 状态码时，表示客户端必须发送上述的请求头才能执行请求，这个方法为服务器提供一种有效的方法来阻止 ‘lost update’ 问题。 429 Too Many Requests (太多请求) 当你需要限制客户端请求某个服务数量时，该状态码就很有用，也就是请求速度限制。 在此之前，有一些类似的状态码，例如 ‘509 Bandwidth Limit Exceeded’. Twitter 使用 420 （这不是HTTP定义的状态码） 如果你希望限制客户端对服务的请求数，可使用 429 状态码，同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务。 431 Request Header Fields Too Large (请求头字段太大) 某些情况下，客户端发送 HTTP 请求头会变得很大，那么服务器可发送 431 Request Header Fields Too Large 来指明该问题。 我不太清楚为什么没有 430 状态码，而是直接从 429 跳到 431，我尝试搜索但没有结果。唯一的猜测是 430 Forbidden 跟 403 Forbidden 太像了，为了避免混淆才这么做的，天知道！ 511 Network Authentication Required (要求网络认证) 对我来说这个状态码很有趣，如果你在开发一个 HTTP 服务器，你不一定需要处理该状态码，但如果你在编写 HTTP 客户端，那这个状态码就非常重要。 如果你频繁使用笔记本和智能手机，你可能会注意到大量的公用 WIFI 服务要求你必须接受一些协议或者必须登录后才能使用。 这是通过拦截HTTP流量，当用户试图访问网络返回一个重定向和登录，这很讨厌，但是实际情况就是这样的。 使用这些“拦截”客户端，会有一些讨厌的副作用。在 RFC 中有提到这两个的例子： 如果你在登录WIFI前访问某个网站，网络设备将会拦截首个请求，这些设备往往也有自己的网站图标 ‘favicon.ico’。登录后您会发现，有一段时间内你访问的网站图标一直是WIFI登录网站的图标。如果客户端使用HTTP请求来查找文档（可能是JSON），网络将会响应一个登录页，这样你的客户端就会解析错误并导致客户端运行异常，在现实中这种问题非常常见。因此 511 状态码的提出就是为了解决这个问题。 如果你正在编写 HTTP 的客户端，你最好还是检查 511 状态码以确认是否需要认证后才能访问。 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之装饰者模式]]></title>
      <url>%2F2017%2F01%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[装饰者模式简述 装饰者模式可以形象的比喻一所大房子,外面只有一个门.打开门里面还有门.打开门获取一点金钱.你可以无限的进门.. Component（被装饰对象的基类） ConcreteComponent（具体被装饰对象） Decorator（装饰者抽象类） ConcreteDecorator（具体装饰者） 类图 代码 定义一个抽象类(非必须) 1234567891011121314151617181920package com.pan.component;/** * 抽象类 * * @author xinyi.pan * */public abstract class Animal &#123; private String name; public Animal(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 定义一个被装饰的接口(定义公共的方法). 12345678package com.pan.component;public interface Fight &#123; //公共方法(门) public String fightPower() ; &#125; 单独类cat 12345678910111213package com.pan.component;public class Cat extends Animal implements Fight &#123; public Cat(String name) &#123; super(name); &#125; //基类的门,里面不再有门.. public String fightPower() &#123; return super.getName() +&quot; fighting&quot; ; &#125; &#125; 单独类cattle 123456789101112package com.pan.component;public class Cattle extends Animal implements Fight &#123; public Cattle(String name) &#123; super(name); &#125; public String fightPower() &#123; return super.getName() + &quot; sleep&quot;; &#125;&#125; 定义抽象装饰类 123456789101112131415161718192021222324package com.pan.decorator;import com.pan.component.Fight;public abstract class AnimalDecorator implements Fight &#123; private Fight fight; // 构造函数添加被装饰着对象 public AnimalDecorator(Fight fight) &#123; this.fight = fight; &#125; //拆包装饰者 public String fightPower() &#123; //调用装饰者公共方法 doDecoratorFight(); //打开下一个门 return fight.fightPower(); &#125; //装饰者的公共方法. public abstract void doDecoratorFight() ;&#125; cattle装饰类 123456789101112131415161718192021package com.pan.decorator;import com.pan.component.Fight;public class CattleDecorator extends AnimalDecorator &#123; public CattleDecorator(Fight fight) &#123; super(fight); &#125; @Override public String fightPower() &#123; return super.fightPower(); &#125; @Override public void doDecoratorFight() &#123; System.out.println(&quot;cattle 打豆豆&quot;); &#125; &#125; 测试方法 123456789101112131415161718192021package com.pan.test;import com.pan.component.Cat;import com.pan.decorator.CatDecorator;import com.pan.decorator.CattleDecorator;public class CalTest &#123; public static void main(String[] args) &#123; System.out.println(&quot;==================未装饰cat==================&quot;); System.out.println(new Cat(&quot;cat&quot;).fightPower()); System.out.println(&quot;===================装饰cat======================&quot;); CatDecorator catDecorator = new CatDecorator(new Cat(&quot;cat&quot;)) ; System.out.println(catDecorator.fightPower()); CattleDecorator cattleDecorator = new CattleDecorator(catDecorator) ; System.out.println(&quot;====================cattle装饰cat装饰=====================&quot;); System.out.println(cattleDecorator.fightPower()); &#125;&#125; 结果 123456789==================未装饰cat==================cat fighting===================装饰cat======================cat 打豆豆cat fighting====================cattle装饰cat装饰=====================cattle 打豆豆cat 打豆豆cat fighting End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[去百度右侧推广方法]]></title>
      <url>%2F2017%2F01%2F02%2F%E5%8E%BB%E7%99%BE%E5%BA%A6%E6%8E%A8%E5%B9%BF%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[百度越来越恶心了… 下面介绍一种简单的去百度推广方法,采用的是chrome浏览器. 安装adb去广告插件. 添加自定义规则. 右侧推广去掉的结果 但是还有搜索的推广 添加清除左侧推广规则 全部结果7.规则: ##div[class*=&quot;cr-content&quot;] ##div[class*=&quot;opr-recommends-merge-panel&quot;] ##div[id*=&quot;con-ar&quot;] ##div[style*=&quot;!important&quot;] End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之观察者模式]]></title>
      <url>%2F2016%2F12%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[观察者模式 观察者模式一般使用在订阅/推送功能下,数据提供方推送数据–&gt;数据接收方.其实在开发中该模式使用应该是很普遍的.例如站内信/信息中心/订阅都是用的是该设计模式. 方式1:数据推送方—&gt;查询订购对象—&gt;推送给订购对象. 方式2:订购的对象 —&gt;查询订阅的数据—&gt;拉取需要的数据. 本质上其实就是发送方与接收方的依赖隔离,也就是说数据发送方发送数据,不是直接发送给订购的对象,而是先查询哪些订购了.然后统一发送出 End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java volatile 关键字]]></title>
      <url>%2F2016%2F12%2F29%2Fjava-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
      <content type="text"><![CDATA[volatile关键字的使用 volatile关键字的作用是告诉编译器,该变量是易变的.不要将该变量的值存储在寄存器中,而是放在内存中(一般指的是静态也就是栈). 某些静态变量,如果使用频繁.可能会直接存放于寄存器中,以便加快计算的速度.但是,如果我们期望该值不应 该存在多个不一样的值时候,除了使用final定义为常量.还可以使用该关键字. 该关键字既可以避免一个变量出现多个值的可能,也可以避免常量的不可改变性. 注意点: 使用场景应该如下: 多个线程中,该变量只能拥有一个对象. 该变量可能需要变化.即该变量需要动态创建/销毁. 它本身无法保证运行中只存在一个对象.它只是告诉jvm,它的值需要从内存中去读取,而不是在寄存器(1级缓存/2级缓存/3级缓存)中获取该值. 如果只是需要一个对象,使用final关键字即可.如果该对象使用不频繁,减少内存开销.可以使用该关键字,配合多线程的同步锁,可以实现单例. End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之策略模式]]></title>
      <url>%2F2016%2F12%2F28%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[策略模式 策略模式是用于解决面向对象中的抽象类与接口的局限性.即一般的对类别进行抽象,对行为进行抽象为接口.这种方式在代码复用上有一定的局限性.而策略模式可以提高代码的复用. eg://定义一个接口,用于在抽象类都能调用到.(里氏替换原则)interface Speak{ void doSpeak() ;}// 实现接口1,其他类只要功能一样都可以采用它.class SpeakCn implements Speak{@Overridepublic void doSpeak() { System.out.println(&quot;中文&quot;); }}//实现接口2,其他类只要功能一样都可以采用它.class SpeakEn implements Speak{@Overridepublic void doSpeak() { System.out.println(&quot;English&quot;); }}//抽象类 使用接口来实现.将具体实现放到子类来实现接口.abstract class man{Speak speak ;void speak(){ speak.doSpeak(); }}class CnMan extends man{//初始化赋值父类接口的实现,也可以采用Spring的初始化加载实现.public CnMan() { speak = new SpeakCn() ; }}//使用class test{public void main(String[] args) { new CnMan().speak(); }} End]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 基础语法]]></title>
      <url>%2F2016%2F12%2F28%2FMarkdown-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[markdown基本语法.文字类 标题大小用#来标记,等同于html的&lt;h1&gt;&lt;/h1&gt;标签. 内容的强调使用*或_ 来标记. 有序列表使用数字.来标记. 无序列表使用* 或- 或+来标记. 小代码使用2个`来标记.代码块使用6个`来标记. 如果需要显示单个代码,也可以使用\来标记该字符不被解析. 代码块一种更简便的方式是在开头使用一个tab+4个空格. 列表的嵌套使用tab+列表标记. 空行直接使用html的标记&lt;br/&gt; 连接类 页面内的跳转. 使用&lt;span id =&quot;bijiao&quot;&gt;&lt;/span&gt; 定义一个要跳转的地方. 使用&lt;a href=&quot;#biaoqian&quot;&gt;跳&lt;/a&gt;或者[跳](#biaoqian)来实现跳转. 其他跳转.使用&lt;a href=&quot;地址&quot;&gt;跳&lt;/a&gt;或者[跳](地址)来实现跳转. 图片类 使用&lt;img src=&quot;地址&quot;&gt;名称&lt;/img&gt;或者![名称](地址)来实现. 音视频 声音:使用&lt;audio src=&quot;地址&quot; autoplay=&quot;true&quot;&gt;声音&lt;/audio&gt;来实现 视频:使用&lt;video src=&quot;地址&quot; autoplay=&quot;true&quot;&gt;视频&lt;/video&gt;来实现总结来说,mardown完全可以使用html标签来写.不过,html写起来麻烦.但是一些功能目前来说,markdown还不支持,所以只能采用html的标签来实现.来外,颜色样式的定义.好像也不可以.也只能用html.个人理解markdown只是html的一个框架.对html的一个封装.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git的使用]]></title>
      <url>%2F2016%2F12%2F27%2Fgit%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[Git初次使用一般来说就5步. cd 你的目录 //进入你需要提交的目录. git init //初始化. git add * //添加需要提交的文件. git commit -m “第一次提交” //提交的说明. git remote add origin https://github.com/lmxy1990/test.git //添加远程仓库地址 git push -u origin master //提交 到主干]]></content>
    </entry>

    
  
  
</search>
